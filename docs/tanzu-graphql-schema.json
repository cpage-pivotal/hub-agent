{"json_version":"1","data":{"introspection_response":"schema {\n  query: Query\n  mutation: Mutation\n}\n\"An 8-bit signed integer\"\nscalar Byte\nscalar Date\n\"A slightly refined version of RFC-3339 compliant DateTime Scalar\"\nscalar DateTime\n\"A canonical inventory entityId String in a parsable format\"\nscalar EntityId\n\"Custom scalar to represent JSON Schema and JSON inputs in fleet management. This scalar represents a JSON object. We're not using the JSON scalar as we need to de-serialise to JsonNode objects.\"\nscalar FleetManagementJsonScalar\n\"A JSON scalar\"\nscalar JSON\n\"\"\"\nCustom scalar to represent JSON Schema and JSON inputs.\nThis scalar represents an object of type com.fasterxml.jackson.databind.JsonNode.\nWe're not using the JSON scalar as we need to serialise/de-serialise from/to JsonNode objects.\n\"\"\"\nscalar JsonNodeScalar\n\"A localized String\"\nscalar LocalizedString\n\"A 64-bit signed integer\"\nscalar Long\n\"An object scalar\"\nscalar Object\nscalar SpringArtifactUpload\ntype AdminMutation {\n  \"Defines mutations related to system troubleshooting, including generating support bundles for diagnostics.\"\n  supportMutation: AdminSupportMutation\n}\ntype AdminSupportMutation {\n  \"\"\"\n  Triggers the creation of a support bundle containing diagnostic information, which can be used for troubleshooting.\n  ### API Permissions:\n  - `platform:SupportBundle:create`\n  \"\"\"\n  createSupportBundle: Document\n}\n\"Slack Oauth2 access response to exchange auth code for access token\"\ntype AriaNotificationSlackOauth2Response {\n  \"Access token to call any of slack method\"\n  token: String!\n  \"Id of the slack workspace\"\n  workspaceId: String!\n  \"Name of the slack workspace\"\n  workspaceName: String!\n}\ntype AriaNotificationTarget implements Node & NodeVersion & NotificationTarget {\n  \"The time this notification target was created\"\n  creationTime: DateTime!\n  \"Name of this notification target\"\n  displayName: String!\n  \"Enabled turns the notification target on/off\"\n  enabled: Boolean!\n  \"Node-compatible opaque global identifier\"\n  id: ID!\n  \"The last time this notification target was successfully updated\"\n  lastUpdateTime: DateTime!\n  \"Opaque version string for this graph node instance\"\n  nodeVersion: ID!\n  notificationTargetId: String!\n  \"The list of properties specific for the selected notification target type\"\n  properties: [NotificationTargetProperty!]\n  \"Name for this notification target provider.\"\n  providerName: String!\n  \"Scoping entities that are included\"\n  scopingEntities: [Entity!]\n  \"Status holds details about the healthiness of the notification target\"\n  status: NotificationTargetStatus!\n  \"Notification target type\"\n  type: AriaNotificationTargetType!\n}\ntype AriaNotificationTargetConnection implements Connection & NotificationTargetConnection {\n  \"Count of notification targets in current page\"\n  count: Int!\n  \"Relay-compatible connection edge\"\n  edges: [AriaNotificationTargetEdge!]\n  \"List of Tanzu Hub notification targets in current page\"\n  notificationTargets: [AriaNotificationTarget!]\n  \"Relay-compatible paging information\"\n  pageInfo: PageInfo!\n  \"\"\"\n  Total count of notification targets\n  ### API Permissions:\n  - `notification:Target-Platform:read`\n  \"\"\"\n  totalCount: Int\n}\n\"Delete response for deleting a notification target\"\ntype AriaNotificationTargetDeleteResult {\n  \"Error message on failed deletion\"\n  errorMessage: String\n  \"Notification target id\"\n  notificationTargetId: String!\n  \"Deletion status\"\n  status: NotificationTargetDeleteStatusValue!\n}\ntype AriaNotificationTargetEdge implements ConnectionEdge & NotificationTargetEdge {\n  cursor: String!\n  node: AriaNotificationTarget!\n}\n\"AriaTestNotificationTarget holds details about the result of the performed test\"\ntype AriaNotificationTargetTestResult {\n  \"A description of the result. In case of error from the 3rd party service the error message will be included here.\"\n  message: String\n  \"Status of the test\"\n  status: NotificationTargetTestStatus!\n}\n\"Describes a notification target type for Aria\"\ntype AriaNotificationTargetType implements Node & NotificationTargetType {\n  \"Node-compatible opaque global identifier\"\n  id: ID!\n  \"The list of input properties specific for the selected notification target type\"\n  inputProperties: [NotificationTargetTypeInputProperty]\n  \"The list of properties specific for the selected notification target type\"\n  properties: [NotificationTargetProperty]\n  \"\"\"\n  RequiresAddress shows whether notification targets of this type need an address to be passed in order to work.\n  Examples of address are email address, Slack channel, etc.\n  \"\"\"\n  requiresAddress: Boolean!\n  \"Notification target type\"\n  type: String!\n}\ntype AriaNotificationTargetTypeConnection implements Connection & NotificationTargetTypeConnection {\n  \"Count of notification target types in current page\"\n  count: Int!\n  \"Relay-compatible connection edge\"\n  edges: [AriaNotificationTargetTypeEdge!]\n  \"List of Tanzu Hub notification target types in current page\"\n  notificationTargetTypes: [AriaNotificationTargetType!]\n  \"Relay-compatible paging information\"\n  pageInfo: PageInfo!\n  \"Total count of notification target types\"\n  totalCount: Int\n}\ntype AriaNotificationTargetTypeEdge implements ConnectionEdge & NotificationTargetTypeEdge {\n  cursor: String!\n  node: AriaNotificationTargetType!\n}\ntype AriaNotificationTargetsMutationProvider implements NotificationTargetsMutationProvider {\n  \"\"\"\n  Delete Tanzu Hub notification targets\n  ### API Permissions:\n  - `notification:Target-Platform:delete`\n  \"\"\"\n  deleteNotificationTarget(notificationTargetIds: [String!]!): [AriaNotificationTargetDeleteResult!]\n  \"\"\"\n  Exchange slack oauth code with access token for given Tanzu Hub notification target as slack\n  ### API Permissions:\n  - `notification:Target-Platform:create`,\n  - `notification:Target-Platform:update`\n  \"\"\"\n  exchangeSlackOauthCode(\n    \"The code param returned via the OAuth callback\"\n    code: String!,\n    \"The URI where Slack will send the user back to, along with the temporary authorization code\"\n    redirectUri: String\n  ): AriaNotificationSlackOauth2Response!\n  \"Name of the provider\"\n  name: String\n  \"\"\"\n  Test a Tanzu Hub notification target existing/new configuration without create/updating it\n  ### API Permissions:\n  - `notification:Target-Platform:create`,\n  - `notification:Target-Platform:update`\n  \"\"\"\n  testNotificationTarget(input: AriaTestNotificationTargetInput!): AriaNotificationTargetTestResult!\n  \"\"\"\n  Create or update a Tanzu Hub notification target\n  ### API Permissions:\n  - `notification:Target-Platform:create`,\n  - `notification:Target-Platform:update`\n  \"\"\"\n  upsertNotificationTarget(input: AriaNotificationUpsertTargetInput!): AriaNotificationTarget\n}\n\"Describes a notification target provider for Aria\"\ntype AriaNotificationTargetsProvider implements NotificationTargetsProvider {\n  \"Information about this provider\"\n  providerInfo: NotificationTargetsProviderInfo!\n  \"\"\"\n  \n  ### API Permissions:\n  - `notification:Target-Platform:read`\n  \"\"\"\n  queryNotificationTargetTypes(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,filter: QueryFilter, \n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10\n  ): AriaNotificationTargetTypeConnection\n  \"\"\"\n  \n  ### API Permissions:\n  - `notification:Target-Platform:read`\n  \"\"\"\n  queryNotificationTargets(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,filter: QueryFilter, \n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Sort order for results in the connection\"\n    sort: [QuerySort!]\n  ): AriaNotificationTargetConnection\n}\ntype ArtifactAssessmentAggregationItem implements CommonAggregationItem {\n  \"Count of instances of the given value\"\n  count: Long!\n  subAggregations: [ArtifactAssessmentAggregationItems!]\n  \"field value\"\n  value: String!\n}\ntype ArtifactAssessmentAggregationItems implements CommonAggregationItems {\n  \"Aggregation type\"\n  aggregationType: ArtifactAssessmentAggregationType\n  \"Number of distinct buckets\"\n  bucketCount: Long!\n  buckets: [ArtifactAssessmentAggregationItem!]\n  \"\"\"\n  Field key for which values are being aggregated.\n  This should be of value AssessmentAggregationField\n  \"\"\"\n  field: String!\n}\ntype ArtifactAssessmentAggregations implements CommonAggregations {\n  aggregations: [ArtifactAssessmentAggregationItems!]\n  totalCount: Long!\n}\ntype ArtifactAssessmentStats {\n  count: ArtifactAssessmentSummaryCount!\n  type: SpringArtifactAssessmentType!\n}\n\"Assessment summary - captures counts of different assessment parameters\"\ntype ArtifactAssessmentSummaryCount {\n  \"Total assessments done\"\n  totalAssessments: Long!\n  \"Total generated assessment findings\"\n  totalFindings: Long!\n  \"Total generated assessment recommendations\"\n  totalRecommendations: Long!\n}\ntype ArtifactMetadataProviderInfo {\n  \"name of provider\"\n  name: String!\n}\ntype ArtifactMetadataQuery {\n  \"Direct access to individual artifact metadata provider queries through per-provider fields.\"\n  artifactQueryProviders: ArtifactMetadataQueryProviders!\n  \"\"\"\n  Query latest SBOM for an entity, return latest SBOM content json for requested entity\n  throws exception if either entity does not have an sbom mapping or if the mapped sbom is not available\n  \"\"\"\n  querySBOMForEntity(entityId: EntityId!): ArtifactSbomContent!\n}\ntype ArtifactMetadataQueryProviders {\n  \"Query provider for Spring Artifacts\"\n  springArtifact: SpringArtifactMetadataQueryProvider!\n}\ntype ArtifactRemediationStats {\n  cveFixPercentage: Float!\n  cveFixed: Int!\n  entitiesUpdated: Int!\n  remediationAvailable: Int!\n  totalCve: Int!\n  totalEntities: Int!\n  updatedEntitiesPercentage: Float!\n}\n\"Artifact repository recommendation - captures vulnerability and support posture improvement with different upgrade efforts\"\ntype ArtifactRepositoryRecommendation {\n  \"Total libraries which require upgrade\"\n  libraryUpgradeCount: Int!\n  \"Repository\"\n  repository: SpringArtifactRepository!\n  \"Support Status Summary Projections by upgrade effort\"\n  supportStatusProjection: SpringArtifactSummaryItems\n  \"Represents effort needed to upgrade a spring artifact version\"\n  upgradeEffort: SpringArtifactUpgradeEffort!\n  \"Vulnerability Summary Projections by upgrade effort\"\n  vulnerabilityProjection: SpringArtifactSummaryItems\n}\n\"SBOM content\"\ntype ArtifactSbomContent {\n  \"base64 encoded sbom content string\"\n  content: String\n  \"sbom content type\"\n  contentType: ArtifactSbomContentType\n  \"sbom document unique identifier\"\n  documentId: String!\n}\n\"Aggregation bucket returned in aggregation query\"\ntype ArtifactVulnerabilityEntityAggregationBucket implements CommonAggregationItem {\n  \"Count of this aggregation , may be null if nested aggregation is requested. This will contain the count only for leaf level aggregation\"\n  count: Long!\n  \"This will contain sub aggregations if requested\"\n  subAggregations: [ArtifactVulnerabilityEntityAggregationItems!]\n  \"Actual value of the field requested\"\n  value: String!\n}\ntype ArtifactVulnerabilityEntityAggregationItems implements CommonAggregationItems {\n  \"Number of distinct buckets\"\n  bucketCount: Long!\n  \"One or more aggregation buckets\"\n  buckets: [ArtifactVulnerabilityEntityAggregationBucket!]\n  \"Name of the field for which aggregation requested can be one of (entityId, entityType, entityName, applicationEntityId, applicationEntityName, packageName, packageVersion)\"\n  field: String!\n}\n\"Response for queryEntitiesForVulnerability query\"\ntype ArtifactVulnerabilityEntityAggregations implements CommonAggregations {\n  \"vulnerability aggregation items\"\n  aggregations: [CommonAggregationItems!]\n  \"Sum of all counts across all buckets\"\n  totalCount: Long!\n}\n\"Count of vulnerability for a given severity\"\ntype ArtifactVulnerabilityEntityCountBySeverity {\n  \"Count of vulnerability for this severity\"\n  count: Int!\n  \"Severity of vulnerability\"\n  severity: ArtifactVulnerabilitySeverity!\n}\n\"Result of queryVulnerabilityOvertime, is an ascending ordered list of dates with vulnerability counts\"\ntype ArtifactVulnerabilityEntityCountOvertime {\n  buckets: [ArtifactVulnerabilityEntityCountWithTime!]\n}\n\"Vulnerability count over time\"\ntype ArtifactVulnerabilityEntityCountWithTime {\n  \"\"\"\n  Vulnerability count by severity\n  if overtime count is requested for a single CVE, there will be a single entry in countBySeverity\n  \"\"\"\n  countBySeverity: [ArtifactVulnerabilityEntityCountBySeverity!]!\n  \"Timestamp for this instance\"\n  date: Date!\n  \"Total counts of vulnerability\"\n  totalCount: Int!\n}\n\"Details of how a vulnerability affects an Entity\"\ntype ArtifactVulnerabilityEntityDetails implements Node {\n  \"Entity on which this vulnerability is detected\"\n  entity: Entity!\n  \"Opaque global node ID , as per Node specification\"\n  id: ID!\n  \"Affected packages for this vulnerability on this entity\"\n  packages: [HubArtifactVulnerabilityDetectionInfo!]\n  \"ArtifactVulnerability that is affecting this entity\"\n  vulnerability: ArtifactVulnerability!\n}\n\"Connection type for ArtifactVulnerabilityEntityDetails\"\ntype ArtifactVulnerabilityEntityDetailsConnection implements Connection {\n  \"List vulnerability entity details\"\n  artifactVulnerabilityEntityDetails: [ArtifactVulnerabilityEntityDetails!]\n  \"Count of vulnerabilities on this page\"\n  count: Int!\n  \"Relay-compatible Package edges\"\n  edges: [ArtifactVulnerabilityEntityDetailsEdge!]\n  \"Relay-compatible page info\"\n  pageInfo: PageInfo!\n  \"Total count of vulnerabilities, may not always be an exact number and hence consumers should not rely only on this\"\n  totalCount: Int\n}\n\"Edge type for ArtifactVulnerabilityEntityDetails\"\ntype ArtifactVulnerabilityEntityDetailsEdge implements ConnectionEdge {\n  \"Cursor is an opaque string, you can use it to request subsequent or preceding items in the list\"\n  cursor: String\n  \"Vulnerability entity mapping  node\"\n  node: ArtifactVulnerabilityEntityDetails!\n}\n\"Relationship between a ArtifactVulnerability and Entities\"\ntype ArtifactVulnerabilityEntityRelationship implements Node {\n  \"\"\"\n  Connection of entities that have this vulnerability,\n  If entityId and entityType filters are not passed, then all entities on which this vulnerability is reported and related application(Tanzu.Hub.Application) entities will be returned.\n  even if the vulnerability is not directly reported on the application but is reported on any related entity\n  \n  If entityId is passed and entityType is Tanzu.Hub.Application,\n  then all vulnerabilities reported on entities that are related to passed Application Entity on which the vulnerability is reported will be returned.\n  If this vulnerability is directly reported on the Application Entity it will also be returned\n  \n  If entityId is passed and entityType is not Tanzu.Hub.Application, then only Entity with requested entityId will be returned\n  \n  If entityType is passed then all entities of given type on which this vulnerability is reported will be returned\n  \"\"\"\n  affectedEntities(after: String, before: String, entityId: [EntityId!], entityName: [String!], entityType: [String!], first: Int): ArtifactVulnerabilityEntityDetailsConnection!\n  \"When the vulnerability was first detected in any affected entity\"\n  creationTime: DateTime!\n  \"Opaque global node ID , as per Node specification\"\n  id: ID!\n  \"Summary containing affected entity counts, and impacted package version\"\n  summary: ArtifactVulnerabilityEntityRelationshipSummary\n  \"ArtifactVulnerability that represents the vulnerability for this mapping\"\n  vulnerability: HubArtifactVulnerability!\n}\n\"Connection type for ArtifactVulnerabilityEntityRelationship\"\ntype ArtifactVulnerabilityEntityRelationshipConnection implements Connection {\n  \"List vulnerability mappings\"\n  artifactVulnerabilityEntityRelationships: [ArtifactVulnerabilityEntityRelationship!]\n  \"Count of vulnerabilities on this page\"\n  count: Int!\n  \"Relay-compatible Package edges\"\n  edges: [ArtifactVulnerabilityEntityRelationshipEdge!]\n  \"Relay-compatible page info\"\n  pageInfo: PageInfo!\n  \"Total count of vulnerabilities, may not always be an exact number and hence consumers should not rely only on this\"\n  totalCount: Int\n}\n\"Edge type for ArtifactVulnerabilityEntityRelationship\"\ntype ArtifactVulnerabilityEntityRelationshipEdge implements ConnectionEdge {\n  \"Cursor is an opaque string, you can use it to request subsequent or preceding items in the list\"\n  cursor: String\n  \"Vulnerability entity mapping  node\"\n  node: ArtifactVulnerabilityEntityRelationship!\n}\n\"Summary information for artifact vulnerability and associated entities\"\ntype ArtifactVulnerabilityEntityRelationshipSummary {\n  \"Count of entities by type that are affected by this vulnerability, currently the affected entities counts will be of type Tanzu.Hub.Application\"\n  affectedEntityCounts: [ArtifactVulnerabilityEntityTypeCounts!]\n  \"Contains a unique list of Package versions where this vulnerability if fixed.\"\n  packageFixVersions: [String!]\n  \"Unique names of package names in which this vulnerability is detected\"\n  packageNames: [String!]\n  \"Contains a unique list of Package versions used by entities affected by this vulnerability.\"\n  packageVersions: [String!]\n}\n\"Count of entities by type that are affected by this vulnerability\"\ntype ArtifactVulnerabilityEntityTypeCounts {\n  count: Int!\n  entityType: String!\n}\n\"Queries for ArtifactVulnerabilityEntityRelationship\"\ntype ArtifactVulnerabilityQuery {\n  \"\"\"\n  Query application vulnerabilities with filtering, pagination, and aggregations\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `springassessment:Assessment:read`\n  \"\"\"\n  queryApplicationVulnerabilities: ComponentApplicationVulnerabilityProvider!\n  \"Query vulnerabilities with associated entities\"\n  queryArtifactVulnerabilitiesEntityRelationship(after: String, artifactEntityCategory: ArtifactEntityCategory = APPLICATION, before: String, first: Int, \n    \"Supported fields on which sorting is supported: severity, cveId, affectedEntityCount, creationTime\"\n    sort: [QuerySort!],vulnerabilityFilter: ArtifactVulnerabilityEntityFilterInput  ): ArtifactVulnerabilityEntityRelationshipConnection!\n  \"\"\"\n  Query component vulnerabilities with filtering and pagination\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `springassessment:Assessment:read`\n  \"\"\"\n  queryComponentVulnerabilities(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Input filters to filter component vulnerabilities\"\n    componentFilter: ComponentFilterInput,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Supported fields on which sorting is supported: foundationName, componentName, currentVersion, criticalCveCount, highCveCount, lastPatchDate\"\n    sort: [QuerySort!]\n  ): ComponentVulnerabilityConnection!\n  \"Query event tracking with filtering, sorting, and pagination\"\n  queryEvent(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Filter events by type and other criteria\"\n    filter: AssessmentEventFilterInput,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Sort events by one or more attributes, default sort: eventTime descending\"\n    sort: [QuerySort!]\n  ): AssessmentEventConnection!\n  \"Query to populate remediation stats for entities\"\n  queryRemediationStats(entityIds: [EntityId!]): ArtifactRemediationStats!\n  \"Query to generate upgrade planner url\"\n  queryUpgradePlannerURL(foundationId: String!): HyperLink!\n  \"Query aggregations for HubEntityVulnerability\"\n  queryVulnerabilityAggregations(artifactEntityCategory: ArtifactEntityCategory = APPLICATION, input: ArtifactVulnerabilityEntityAggregationInput!): ArtifactVulnerabilityEntityAggregations!\n  \"Query vulnerability counts over time\"\n  queryVulnerabilityOvertime(vulnerabilityOvertimeFilter: ArtifactVulnerabilityEntityOvertimeFilterInput): ArtifactVulnerabilityEntityCountOvertime!\n  \"\"\"\n  Internal method to execute TVS (Tanzu Vulnerability Scanner) tasks.\n  Executes specific TVS-related tasks based on the provided task type.\n  @internal\n  \"\"\"\n  runTvsTask(type: ComponentTaskType!): JSON\n}\ntype ArtifactVulnerabilityScore {\n  \"Numeric score for a vulnerability\"\n  score: Float\n  \"ArtifactVulnerabilityScoreType can be CVSS Version 3 or CVSS Version 2\"\n  type: ArtifactVulnerabilityScoreType!\n  \"Attack vector string\"\n  vector: String\n}\n\"Connection type for AssessmentEventTracking\"\ntype AssessmentEventConnection implements Connection {\n  \"Count of events on this page\"\n  count: Int!\n  \"Relay-compatible event edges\"\n  edges: [AssessmentEventEdge!]\n  \"Relay-compatible page info\"\n  pageInfo: PageInfo!\n  \"Total count of events, may not always be an exact number and hence consumers should not rely only on this\"\n  totalCount: Int\n}\n\"Edge type for AssessmentEventTracking\"\ntype AssessmentEventEdge implements ConnectionEdge {\n  \"Cursor is an opaque string, you can use it to request subsequent or preceding items in the list\"\n  cursor: String\n  \"Event tracking node\"\n  node: AssessmentEventTracking!\n}\n\"Event tracking information for system events\"\ntype AssessmentEventTracking implements Node {\n  \"Type of the event\"\n  eventName: AssessmentEventName!\n  \"When the event occurred\"\n  eventTime: DateTime!\n  \"Opaque global node ID, as per Node specification\"\n  id: ID!\n  \"Optional descriptive message about the event\"\n  message: String\n  \"Organization ID where the event occurred\"\n  orgId: String\n  \"Status of the event\"\n  status: AssessmentEventStatus!\n  \"Optional timing data for performance monitoring (JSON string)\"\n  timeTracker: String\n}\ntype AssessmentMutation {\n  repositoryAssessmentMutation: RepositoryAssessmentMutation!\n}\ntype AssessmentPortfolioChallenge {\n  description: String\n  documentation: [HyperLink!]\n  key: String!\n  labels: [String!]\n  name: String!\n  rules: [Entity!]\n}\ntype AssessmentPortfolioTraits {\n  challenges: [AssessmentPortfolioChallenge!]\n  triggeredRules: [AssessmentPortfolioTriggeredRule!]\n}\ntype AssessmentPortfolioTriggeredRule {\n  hits: Int\n  rule: Entity\n}\ntype AssessmentQuery {\n  repositoryAssessmentQuery: RepositoryAssessmentQuery!\n}\ntype AssessmentRule implements Node {\n  \"Rule advice\"\n  advice: String\n  createdAt: DateTime\n  \"Pattern to be used for matching\"\n  defaultPattern: String\n  \"Migration effort required\"\n  effort: Int!\n  \"Whether the rule is enabled\"\n  enabled: Boolean!\n  \"Entity id of the rule\"\n  entityId: EntityId!\n  excludePatterns: [AssessmentRulePattern!]\n  \"Pattern of the name of the file to apply rule to\"\n  fileNamePattern: String\n  \"Type of file to apply rule to\"\n  fileType: String!\n  \"Opaque global node ID\"\n  id: ID!\n  \"Name of the rule\"\n  name: String!\n  patterns: [AssessmentRulePattern!]\n  \"Type of rule\"\n  ruleType: AssessmentRuleType!\n  \"Source type of the rule\"\n  sourceType: AssessmentRuleSourceType\n  tags: [Tag!]\n  \"Rule application target e.g. line\"\n  target: AssessmentRuleTargetType!\n  type: AssessmentRuleMatchType!\n  updatedAt: DateTime\n}\ntype AssessmentRuleConnection implements Connection {\n  \"Count of elements in the current page\"\n  count: Int!\n  edges: [AssessmentRuleEdge!]\n  \"Errors that might occur during create / update / delete of a rule\"\n  error: AssessmentRuleResponseError\n  \"Paging support\"\n  pageInfo: PageInfo!\n  rules: [AssessmentRule!]\n  \"Optional total elements count across all pages when available\"\n  totalCount: Int\n}\ntype AssessmentRuleEdge implements ConnectionEdge {\n  \"Optional cursor to refer to this node\"\n  cursor: String\n  \"Node element available through this edge\"\n  node: AssessmentRule!\n}\ntype AssessmentRulePattern {\n  advice: String\n  effort: Int\n  tag: Tag\n  value: String\n}\ntype AssessmentRuleResponseError {\n  \"Entity Id of the errored entity\"\n  entityId: EntityId\n  \"The name of the entity\"\n  entityName: String\n  \"The error that was hit when creating/updating this entity\"\n  errorMsg: String!\n  \"The type of the error that was hit when creating/updating a rule entity\"\n  errorType: AssessmentRuleResponseErrorType!\n}\n\"Type defining common audit event schema for a mutation\"\ntype AuditEvent implements Node {\n  \"Creation time of an audit event Note: Expressed in UTC ISO-8601 timestamp\"\n  creationTime: DateTime!\n  \"Optional details of an audit event\"\n  details: String\n  \"Opaque global event ID\"\n  id: ID!\n  \"Unique identifier for this specific mutation invocation which may have one or more audit events associated to it\"\n  mutationInstanceId: String!\n  \"Optional status of an audit event set by mutation provider\"\n  status: String\n}\ntype AuditEventConnectionEdge implements ConnectionEdge {\n  cursor: String!\n  node: AuditEvent!\n}\n\"Authentication Access Token response\"\ntype AuthAccessToken {\n  \"JWT access token\"\n  accessToken: String!\n  \"Pre-prepared HTTP authorization header\"\n  authorization: String!\n  \"Token expiration time. Note: Expressed in UTC ISO-8601 timestamp\"\n  expirationTime: DateTime!\n}\ntype AuthContext implements Node {\n  \"Entity representing this context\"\n  entity: Entity!\n  \"Globally unique ID for Node interface\"\n  id: ID!\n  \"\"\"\n  Boolean that indicates whether the user can create role bindings on this context\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  \"\"\"\n  isAssignableContext: Boolean\n  \"List of permissions this context has\"\n  permissions: [String!]\n}\ntype AuthContextConnection implements Connection {\n  \"Count of elements in the current page\"\n  count: Int!\n  \"Edges to nodes available through the connection\"\n  edges: [AuthContextEdge!]\n  \"Paging support\"\n  pageInfo: PageInfo!\n  \"Optional total elements count across all pages when available\"\n  totalCount: Int\n}\ntype AuthContextEdge implements ConnectionEdge {\n  \"Optional cursor to refer to this node\"\n  cursor: String\n  \"Node element available through this edge\"\n  node: AuthContext!\n}\ntype AuthCreateRoleBindingResult {\n  \"Unique Role Binding ID\"\n  bindingId: String!\n  \"The time of creation\"\n  createdAt: DateTime!\n  \"The user who created the role binding\"\n  createdBy: User\n  \"Opaque global node ID\"\n  id: ID!\n  \"Role to assign\"\n  role: AuthRole!\n  \"The type of scope\"\n  scopeType: AuthRoleBindingScopeType!\n  \"Scoping Entity of role binding\"\n  scopingEntity: Entity\n  \"Status of the role binding creation operation\"\n  status: AuthRoleBindingResultStatus!\n  \"The subject Id string value. For user role binding, this field will contain user's email id. For group role binding, this field will contain the group name.\"\n  subjectId: String!\n  \"The type of the subject\"\n  subjectType: AuthRoleBindingSubjectType!\n  \"User (or group or oauth app) identifier to which the rolebinding is assigned\"\n  user: User\n}\ntype AuthDeleteRoleBindingResult {\n  \"Role Binding ID\"\n  bindingId: String!\n  \"The time of creation\"\n  createdAt: DateTime!\n  \"The user who created the role binding\"\n  createdBy: User\n  \"Opaque global node ID\"\n  id: ID!\n  \"Role to assign\"\n  role: AuthRole\n  \"The type of scope.\"\n  scopeType: AuthRoleBindingScopeType!\n  \"Scoping Entity of role binding\"\n  scopingEntity: Entity\n  \"Status of the role binding delete operation\"\n  status: AuthRoleBindingResultStatus!\n  \"The subject Id string value. For user role binding, this field will contain user's email id. For group role binding, this field will contain the group name.\"\n  subjectId: String!\n  \"The type of the subject\"\n  subjectType: AuthRoleBindingSubjectType!\n  \"User (or group or oauth app) identifier to which the rolebinding is assigned\"\n  user: User\n}\ntype AuthMutation {\n  \"\"\"\n  Mutation for performing RBAC\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  \"\"\"\n  authRoleMutation: AuthRoleMutation\n  \"Support generation of a session access token from a user token\"\n  generateAccessToken(userToken: String!): AuthAccessToken!\n  \"Support generation of a session access token from a client ID and secret\"\n  generateAccessTokenClientCredentials(clientID: String!, clientSecret: String!): AuthAccessToken!\n  \"Mutation to perform OAuth Apps management\"\n  oAuthAppMutation: OAuthAppMutation!\n}\ntype AuthPermission implements Node {\n  \"Localized description\"\n  description: LocalizedString\n  \"Localized display name\"\n  displayName: LocalizedString!\n  \"Opaque global node ID\"\n  id: ID!\n  \"Permission identifier\"\n  name: String!\n  \"provider who is registering the permission\"\n  provider: String!\n  \"Localized provider display name\"\n  providerDisplayName: LocalizedString!\n}\ntype AuthPermissionCheckResult {\n  \"Indicates whether the user has required permissions\"\n  hasPermissions: Boolean!\n  \"Lists the user permissions that are missing from the provided permissions.\"\n  missingPermissionNames: [String!]\n}\ntype AuthPermissionConnection implements Connection {\n  \"Count of elements in the current page\"\n  count: Int!\n  \"Edges to nodes available through the connection\"\n  edges: [AuthPermissionEdge!]\n  \"Paging support\"\n  pageInfo: PageInfo!\n  \"Permissions in this page\"\n  permissions: [AuthPermission!]\n  \"Optional total elements count across all pages when available\"\n  totalCount: Int\n}\ntype AuthPermissionEdge implements ConnectionEdge {\n  \"Optional cursor to refer to this node\"\n  cursor: String\n  \"Node element available through this edge\"\n  node: AuthPermission!\n}\ntype AuthQuery {\n  \"Process the list of permissions, and evaluate whether the user auth headers is authorized to perform the requested action.\"\n  hasPermissions(authPermissions: [String!]!): AuthPermissionCheckResult!\n  \"\"\"\n  Query OAuth Apps\n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  \"\"\"\n  oAuthAppQuery: OAuthAppQuery!\n  \"\"\"\n  Query all role bindings created in the org. Requires additional permission to view all role bindings. To query the current user's role bindings, please use queryRoleBindings query.\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `auth:RoleBindingAll:read`\n  \"\"\"\n  queryAllRoleBindings(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Optionally filter by roles containing all the given permissions(s)\"\n    permissionName: [String!],\n    \"Optionally filter by the given role(s)\"\n    roleName: [String!],\n    \"Optionally filter return role bindings by specified scope types.\"\n    scopeType: [AuthRoleBindingScopeType!],\n    \"Optionally filter by list of scoping entity ids\"\n    scopingEntityId: [EntityId!],\n    \"Optional user id which needs to be searched for. The search is done as CONTAINS, hence all users or groups which contain the input string will be returned.\"\n    subjectId: String,\n    \"Optional subject type. If specified, the role bindings of subject type are returned. If not specified, role bindings of all subject types are returned\"\n    subjectType: [AuthRoleBindingSubjectType!]\n  ): AuthRoleBindingConnection\n  \"\"\"\n  Get Auth User Context\n  ### API Permissions:\n  - `auth:UserContext:read`\n  \"\"\"\n  queryAuthUserContext: AuthUserContext!\n  \"\"\"\n  Query roles available in the system\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `auth:Role:read`\n  \"\"\"\n  queryPermissions(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Optionally filter permissions by name prefix\"\n    namePrefix: String\n  ): AuthPermissionConnection!\n  \"\"\"\n  Query current (default) or specified user's role bindings\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  \"\"\"\n  queryRoleBindings(\n    \"Optionally filter by roles containing all the given permission name(s)\"\n    permissionName: [String!],\n    \"Optionally filter by the given role name(s)\"\n    roleName: [String!],\n    \"Optionally filter return role bindings by specified scope types.\"\n    scopeType: [AuthRoleBindingScopeType!],\n    \"Optionally filter by list of scoping entity ids\"\n    scopingEntityId: [EntityId!],\n    \"Optionally search role bindings of another user - requires additional permissions. The search is done as CONTAINS, hence all users or groups which contain the input string will be returned.\"\n    subjectId: String,\n    \"Optional subject type. If specified, the role bindings of subject type are returned. If not specified, role bindings of all subject types are returned\"\n    subjectType: [AuthRoleBindingSubjectType!]\n  ): [AuthRoleBinding!]\n  \"\"\"\n  Query roles in the system\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `auth:Role:read`\n  \"\"\"\n  queryRoles(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Optionally filter roles by custom role or not\"\n    isCustom: Boolean,\n    \"Optionally filter roles by name prefix\"\n    namePrefix: String,\n    \"Optionally filter roles that contain (all of) the specified permission name(s)\"\n    permissionName: [String!]\n  ): AuthRoleConnection!\n  \"Query authorization permissions for a given query string\"\n  queryRequiredPermissions(\n    \"GraphQL request string\"\n    graphQLRequest: String!\n  ): AuthQueryRequiredPermissions!\n}\ntype AuthQueryPermission {\n  \"GraphQL type name\"\n  type: String!\n  \"name of field in GraphQL type\"\n  field: String!\n  \"dot separated query path to the field requiring the permissions\"\n  path: String!\n  \"list of permission names required to access field\"\n  permissionNames: [String!]\n}\ntype AuthQueryPermissionCheckResult {\n  \"Boolean indicating if the user has appropriate permissions to make this request\"\n  hasPermissions: Boolean!\n  \"permissions required but missing to execute the provided graphQLRequest successfully.\"\n  missingPermissionNames: [String!]\n}\ntype AuthQueryRequiredPermissions {\n  \"List of permissions required for request\"\n  permissionNames: [String!]\n  \"Details of which fields require which permissions\"\n  permissionInfo: [AuthQueryPermission!]\n  \"Processes the provided graphQLRequest, evaluates the user authentication headers to determine authorization for the requested action, and identifies any required but missing permissions.\"\n  hasPermissions: AuthQueryPermissionCheckResult\n}\ntype AuthRole implements Node {\n  \"Assignable scope types for this role during creation of role bindings. If list is empty, all scope types of AuthRbacAssignableScopeType is allowed\"\n  assignableScopeTypes: [AuthRbacAssignableScopeType!]\n  \"Assignable subject type. If this list of empty, then all subject types can be assigned with this role.\"\n  assignableSubjectTypes: [AuthRoleBindingSubjectType!]\n  \"The time of creation\"\n  createdAt: DateTime!\n  createdBy: User\n  description: LocalizedString\n  \"Localized display name\"\n  displayName: LocalizedString!\n  \"Opaque global node ID\"\n  id: ID!\n  \"Specifies whether this role can be assigned\"\n  isAssignable: Boolean!\n  isCustom: Boolean!\n  lastModifiedBy: User\n  \"Last updated time\"\n  lastUpdatedTime: DateTime!\n  name: String!\n  permissionNames: [String!]\n  permissions: [AuthPermission!]\n  \"provider who is registering the role. Will be empty for custom roles\"\n  provider: String!\n  \"Localized provider display name\"\n  providerDisplayName: LocalizedString\n}\ntype AuthRoleBinding implements Node {\n  \"Unique Role Binding ID\"\n  bindingId: String!\n  \"The time of creation\"\n  createdAt: DateTime!\n  \"The user who created the role binding\"\n  createdBy: User\n  \"Group to which role binding is assigned. This field will be populated if role binding is created for a group which the user is part of. This field will be null for USER/OAUTH_APP role bindings\"\n  group: UserGroup\n  \"Opaque global node ID\"\n  id: ID!\n  \"Boolean indicating whether this role bindings is read only. If true, this role binding cannot be deleted by users. This field will be true for auto-synced role bindings\"\n  isReadOnly: Boolean!\n  \"Oauth App to which role binding is assigned. This field will be populated if role binding is created for an oauth app. This field will be null for USER/GROUP role bindings\"\n  oauthApp: OAuthApp\n  \"The provider of this role binding\"\n  provider: AuthRoleBindingProviderEnum!\n  \"Role to assign\"\n  role: AuthRole!\n  \"The type of scope.\"\n  scopeType: AuthRoleBindingScopeType\n  \"Scoping Entity of role binding\"\n  scopingEntity: Entity\n  \"The subject Id string value. For user role binding, this field will contain user's email id. For group role binding, this field will contain the group name.\"\n  subjectId: String!\n  \"The type of the subject\"\n  subjectType: AuthRoleBindingSubjectType!\n  \"User to which the role binding is assigned. This field will be populated if the role binding is created for an user. If a role binding is created for GROUP/OAUTH_APP, this field will be null.\"\n  user: User\n}\ntype AuthRoleBindingConnection implements Connection {\n  \"Count of elements in the current page\"\n  count: Int!\n  \"Edges to nodes available through the connection\"\n  edges: [AuthRoleBindingEdge!]\n  \"Paging support\"\n  pageInfo: PageInfo!\n  \"Role bindings in this page\"\n  roleBindings: [AuthRoleBinding!]\n  \"Optional total elements count across all pages when available\"\n  totalCount: Int\n}\ntype AuthRoleBindingEdge implements ConnectionEdge {\n  \"Optional cursor to refer to this node\"\n  cursor: String\n  \"Node element available through this edge\"\n  node: AuthRoleBinding!\n}\ntype AuthRoleBindingResultStatus {\n  errorMessage: LocalizedString\n  status: AuthRoleBindingStatusEnum!\n}\ntype AuthRoleConnection implements Connection {\n  \"Count of elements in the current page\"\n  count: Int!\n  \"Edges to nodes available through the connection\"\n  edges: [AuthRoleEdge!]\n  \"Paging support\"\n  pageInfo: PageInfo!\n  \"Roles present in this page\"\n  roles: [AuthRole!]\n  \"Optional total elements count across all pages when available\"\n  totalCount: Int\n}\ntype AuthRoleEdge implements ConnectionEdge {\n  \"Optional cursor to refer to this node\"\n  cursor: String\n  \"Node element available through this edge\"\n  node: AuthRole!\n}\ntype AuthRoleMutation {\n  \"\"\"\n  Bulk create scoped bindings between users and roles.\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `auth:RoleBinding:create`\n  \"\"\"\n  authCreateRoleBindings(input: [AuthRoleCreateBindingInput!]!): [AuthCreateRoleBindingResult!]!\n  \"\"\"\n  Bulk delete scoped bindings between users and roles\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `auth:RoleBinding:delete`\n  \"\"\"\n  authDeleteRoleBindings(roleBindingIds: [String!]!): [AuthDeleteRoleBindingResult!]!\n}\ntype AuthUserContext {\n  \"\"\"\n  Get all applicable Auth Contexts\n  ### API Permissions:\n  - `auth:UserContext:read`,\n  - `auth:RoleBinding:create`\n  \"\"\"\n  authContexts(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Get from this parent context id. If not provided, get from root context\"\n    contextId: [EntityId!],\n    \"Optionally filter contexts based on name substring.\"\n    contextNameSearch: String,\n    \"Optional list of scope types to filter\"\n    contextType: [AuthRbacAssignableScopeType!],\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Sort order for records\"\n    sort: [QuerySort!]\n  ): AuthContextConnection!\n}\ntype BusinessAppMergeResponse {\n  entity: Entity\n  error: BusinessAppUpsertResponseError\n}\ntype BusinessAppMutation {\n  \"\"\"\n  Delete the specified list of business applications. Note that this only deletes the business application itself,\n  and not the members of the business application.\n  ### API Permissions:\n  - `businessAppMgmt:BusinessApp:delete`\n  \"\"\"\n  deleteBusinessApplications(entityId: [EntityId!]!): [Boolean!]\n  \"\"\"\n  Merge the specified list of business applications into a single one. Note that this will delete the passed in set of BAs\n  and create a single BA which is the aggregation of the requested BA.\n  ### API Permissions:\n  - `businessAppMgmt:BusinessApp:update`\n  \"\"\"\n  mergeBusinessApplications(entityId: [EntityId!]!, \n    \"The name of the aggregated BA. If not specified, the first input BA's name will be inherited.\"\n    entityName: String\n  ): BusinessAppMergeResponse\n  \"\"\"\n  Group of bunch of applications and services into a business application.\n  ### API Permissions:\n  - `businessAppMgmt:BusinessApp:create`,\n  - `businessAppMgmt:BusinessApp:update`\n  \"\"\"\n  upsertBusinessApplications(input: [BusinessAppDefinitionInput!]!): BusinessAppUpsertResponse\n}\ntype BusinessAppSourceTree {\n  \"The children of this node in the tree.\"\n  children: [BusinessAppSourceTree!]\n  \"The entity that represents this node, if this node exists in EDS.\"\n  entity: Entity\n  \"The name of this node in the tree\"\n  name: String!\n  \"The URL at which this node can be visualized in the UI, if applicable.\"\n  url: HyperLink\n}\ntype BusinessAppTraits {\n  \"The URLs at which this application can be reached, if available.\"\n  applicationEndpointUrl: [HyperLink!]\n  \"The code repositories that are associated with this application.\"\n  repositories: [HyperLink!]\n  \"\"\"\n  The source information of this application. This represents the hierarchy from where this application is\n  obtained. For example, in CloudFoundry applications, this would represent the foundation/org/space in which\n  the application is present.\n  \"\"\"\n  source: BusinessAppSourceTree\n}\ntype BusinessAppUpsertResponse {\n  entities: [Entity!]\n  errors: [BusinessAppUpsertResponseError!]\n}\ntype BusinessAppUpsertResponseError {\n  entityId: EntityId\n  \"The name of the entity\"\n  entityName: String\n  \"The error that was hit when upserting this entity\"\n  errorMsg: String!\n  \"The type of the error that was hit when upserting this entity\"\n  errorType: BusinessAppUpsertResponseErrorType!\n}\n\"\"\"\nA balancing action that redistributes workloads across foundations or deployments.\nIncludes specific resource information for balancing decisions.\n\"\"\"\ntype CapacityBalanceAction implements CapacityAction {\n  \"Description of the balancing action.\"\n  description: String!\n  id: ID!\n  \"Resource info grouped by labels, foundations, or deployments.\"\n  resourceInfo: [CapacityResourceInfo!]\n}\n\"Resource info associated with deployment-specific (vCenter) resources.\"\ntype CapacityDeploymentResourceInfo implements CapacityResourceInfo {\n  \"Entities representing deployment-level resources.\"\n  deploymentResourceEntity: [Entity!]\n  \"Entities representing associated resources.\"\n  resourceEntities: [Entity!]\n}\n\"\"\"\nA specific implementation of a `CapacityRecommendation` for Diego environments.\nIncludes recommended actions and configuration for the associated entity.\n\"\"\"\ntype CapacityDiegoRecommendation implements CapacityRecommendation & Node {\n  \"Actions suggested to fulfill this recommendation.\"\n  actions: [CapacityAction!]\n  \"The target entity for which the recommendation is made.\"\n  entity: Entity!\n  \"Unique identifier of the recommendation.\"\n  id: ID!\n}\n\"\"\"\nRepresents an action to expand foundation resources such as memory, CPU, or disk.\nProvides detailed configuration and estimated impact of the expansion.\n\"\"\"\ntype CapacityExpandAction implements CapacityAction {\n  \"The type of action suggested\"\n  actionType: CapacityActionType!\n  \"Number of cells to be added.\"\n  cellCount: Long!\n  \"Description of the expansion action.\"\n  description: String!\n  \"Dimension to which the Action targets\"\n  dimension: CapacityDimension!\n  id: ID!\n  \"Optional priority or level of this recommendation.\"\n  recommendationLevel: Long\n  \"Tags to store labels\"\n  tags: [Tag!]\n  \"Recommended resource configuration for the foundation.\"\n  vmType: Entity!\n}\n\"\"\"\nResource info for a specific foundation group.\nIncludes the group entity and its associated resources.\n\"\"\"\ntype CapacityFoundationGroupResourceInfo implements CapacityResourceInfo {\n  \"Entity representing the foundation group.\"\n  foundationGroupEntity: Entity!\n  \"Entities representing the resources within the group.\"\n  resourceEntities: [Entity!]\n}\n\"\"\"\nA paginated connection object for `CapacityIAASInfo` results.\nFollows the Relay specification with edges and pageInfo for pagination metadata.\n\"\"\"\ntype CapacityIAASInfoConnection implements Connection {\n  \"A list of `CapacityIAASInfo` nodes returned in the current page.\"\n  capacityIAASInfo: [CapacityIAASInfo!]\n  \"Number of nodes returned in the current page.\"\n  count: Int!\n  \"A list of edges, each containing a node and its associated pagination cursor.\"\n  edges: [CapacityIAASInfoEdge!]\n  \"Pagination metadata used to fetch the next or previous pages.\"\n  pageInfo: PageInfo!\n  \"\"\"\n  Total number of matching `CapacityIAASInfo` entries (across all pages).\n  May be null if not calculated.\n  \"\"\"\n  totalCount: Int\n}\n\"\"\"\nRepresents an edge in the `CapacityIAASInfoConnection`.\nContains a node and its cursor for pagination.\n\"\"\"\ntype CapacityIAASInfoEdge implements ConnectionEdge {\n  \"A cursor for pagination that points to this node.\"\n  cursor: String!\n  \"The `CapacityIAASInfo` node at the end of this edge.\"\n  node: CapacityIAASInfo!\n}\ntype CapacityInfo implements Node {\n  classification: CapacityClassification!\n  dimension: CapacityDimension\n  dimensionUnit: CapacityDimensionUnit!\n  dimensionValue: Float!\n  entityInfo: Entity!\n  id: ID!\n  lastUpdateTime: DateTime\n  recommendations: [CapacityRecommendation!]\n  tags: [Tag!]\n  thresholdValue: Float\n}\ntype CapacityInfoConnection implements Connection {\n  capacityInfo: [CapacityInfo!]\n  count: Int!\n  edges: [CapacityInfoEdge!]\n  pageInfo: PageInfo!\n  totalCount: Int\n}\ntype CapacityInfoEdge implements ConnectionEdge {\n  cursor: String!\n  node: CapacityInfo!\n}\n\"\"\"\nResource info grouped by entity labels.\nUsed for recommendations involving label-based resource decisions.\n\"\"\"\ntype CapacityLabelsResourceInfo implements CapacityResourceInfo {\n  \"List of tags/labels associated with the resources.\"\n  labels: [Tag!]\n  \"Entities representing the resources with these labels.\"\n  resourceEntities: [Entity!]\n}\n\"\"\"\nAn optimization action recommending changes to application placement or configuration.\nFocuses on optimizing current resource usage.\n\"\"\"\ntype CapacityOptimizeAction implements CapacityAction {\n  \"List of application entities involved in the optimization.\"\n  applicationEntities: [Entity!]\n  \"Description of the optimization action.\"\n  description: String!\n  id: ID!\n}\ntype CapacityQuery {\n  \"\"\"\n  Capacity Information of entity(s)\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `capacity:CapacityInfo:read`\n  \"\"\"\n  queryCapacityInfo(\n    \"After cursor for next page\"\n    after: String,\n    \"Filter for selecting capacity info\"\n    filter: CapacityInfoFilter!,\n    \"Returns first N records\"\n    first: Int = 5,\n    \"Optional additional field filters.\"\n    queryFilter: QueryFilter,\n    \"Optionally specify sort order\"\n    sortOrder: QuerySortOrder = DESC\n  ): CapacityInfoConnection\n  \"\"\"\n  Capacity Recommendations of entity(s)\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `capacity:CapacityInfo:read`\n  \"\"\"\n  queryCapacityRecommendations(\n    \"Entity Id to fetch recommendations\"\n    entityIds: [EntityId!]!\n  ): CapacityRecommendationConnection\n  \"\"\"\n  \n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `capacity:CapacityInfo:read`\n  \"\"\"\n  queryCapacitySummary(\n    \"Optionally aggregate using the specified function\"\n    aggregationType: CapacityAggregationType,\n    \"Entity types\"\n    aggregations: [CapacityAggregationInput!]!,\n    \"Root Entity to Aggregate around\"\n    entityIds: [EntityId!],\n    \"Optional additional field filters.\"\n    queryFilter: QueryFilter\n  ): CapacitySummary\n  \"\"\"\n  Capacity Resource Configurations of entity(s)\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `capacity:CapacityInfo:read`\n  \"\"\"\n  queryIAASCapacityInfo(dimension: CapacityDimension!, \n    \"Entity Id to fetch resource configuration for\"\n    entityIds: [EntityId!]!,entityType: String!  ): CapacityIAASInfoConnection\n}\n\"\"\"\nA paginated connection object for `CapacityRecommendation` results.\nFollows the Relay specification with edges and pageInfo for pagination metadata.\n\"\"\"\ntype CapacityRecommendationConnection implements Connection {\n  \"A list of `CapacityRecommendation` nodes returned in the current page.\"\n  capacityRecommendations: [CapacityRecommendation!]\n  \"Number of nodes returned in the current page.\"\n  count: Int!\n  \"A list of edges, each containing a node and its associated pagination cursor.\"\n  edges: [CapacityRecommendationEdge!]\n  \"Pagination metadata used to fetch the next or previous pages.\"\n  pageInfo: PageInfo!\n  \"\"\"\n  Total number of matching `CapacityRecommendation` entries (across all pages).\n  May be null if not calculated.\n  \"\"\"\n  totalCount: Int\n}\n\"\"\"\nRepresents an edge in the `CapacityRecommendationConnection`.\nContains a node and its cursor for pagination.\n\"\"\"\ntype CapacityRecommendationEdge implements ConnectionEdge {\n  \"A cursor for pagination that points to this node.\"\n  cursor: String!\n  \"The `CapacityRecommendation` node at the end of this edge.\"\n  node: CapacityRecommendation!\n}\ntype CapacitySummary implements CommonAggregations {\n  aggregations: [CapacitySummaryItems!]\n  totalCount: Long!\n}\ntype CapacitySummaryItem implements CommonAggregationItem {\n  \"Count of instances of the given value\"\n  count: Long!\n  lastUpdateTime: DateTime\n  subAggregations: [CapacitySummaryItems!]\n  sum: Float!\n  \"field value\"\n  value: String!\n}\ntype CapacitySummaryItems implements CommonAggregationItems {\n  \"Number of distinct buckets\"\n  bucketCount: Long!\n  buckets: [CapacitySummaryItem!]\n  \"Field key for which values are being aggregated.\"\n  field: String!\n}\ntype CapacityVCAZConfig implements CapacityAZConfig & Node {\n  azName: String!\n  computeEntities: [CapacityVCEntityInfo!]!\n  dataStoreEntities: [CapacityVCEntityInfo!]!\n  \"Capacity allocated for the AZ by the Deployment\"\n  diskAllocatedByAZ: Float!\n  \"Unique identifier of the Vcenter AZ Config.\"\n  id: ID!\n  \"Capacity allocated for the AZ by the Deployment\"\n  memAllocatedByAZ: Float!\n  \"Total VMs deployed in the AZ by the Deployment\"\n  totalVMsDeployed: Int!\n  \"Total VMs with CPU contention deployed in the AZ by the Deployment\"\n  totalVMsWithCPUContention: Int!\n}\ntype CapacityVCEntityInfo {\n  \"Total Capacity of the VC Entity\"\n  totalCapacity: Float!\n  \"Capacity Usage of the VC Entity\"\n  usage: Float!\n  \"The vCenter Entity mapped\"\n  vCenterEntity: Entity!\n}\n\"\"\"\nA specific implementation of a `CapacityIAASInfo` for Diego environments.\nIncludes VCenter Specific IAAS information.\n\"\"\"\ntype CapacityVcenterInfo implements CapacityIAASInfo & Node {\n  \"Configuration parameters associated with the recommendation.\"\n  azConfig: [CapacityVCAZConfig!]!\n  \"The target entity for which the recommendation is made.\"\n  entity: Entity!\n  \"Unique identifier of the recommendation.\"\n  id: ID!\n}\n\"Application vulnerability information\"\ntype ComponentApplicationVulnerability implements Node {\n  \"Application type\"\n  applicationType: String!\n  \"Count of affected critical CVEs (Exploitable or In Triage)\"\n  criticalCveCount: Int!\n  \"Application entity ID\"\n  entityId: String!\n  \"Application entity name\"\n  entityName: String!\n  \"Count of fixed CVEs\"\n  fixedCveCount: Int!\n  \"Count of affected high CVEs (Exploitable or In Triage)\"\n  highCveCount: Int!\n  \"Hub entity ID\"\n  hubEntityId: String\n  \"Opaque global node ID, as per Node specification\"\n  id: ID!\n}\n\"Aggregations for application vulnerabilities\"\ntype ComponentApplicationVulnerabilityAggregations {\n  \"Total count of applications\"\n  appCount: Int!\n  \"Total sum of affected critical CVE counts across all applications (Exploitable or In Triage)\"\n  criticalCveCount: Int!\n  \"Total sum of fixed CVE counts across all applications\"\n  fixedCveCount: Int!\n  \"Total sum of affected high CVE counts across all applications (Exploitable or In Triage)\"\n  highCveCount: Int!\n  \"Total count of related components\"\n  relatedComponentCount: Int!\n}\n\"Connection type for ComponentApplicationVulnerability\"\ntype ComponentApplicationVulnerabilityConnection implements Connection {\n  \"Count of application vulnerabilities on this page\"\n  count: Int!\n  \"Relay-compatible application vulnerability edges\"\n  edges: [ComponentApplicationVulnerabilityEdge!]\n  \"Relay-compatible page info\"\n  pageInfo: PageInfo!\n  \"Total count of application vulnerabilities, may not always be an exact number and hence consumers should not rely only on this\"\n  totalCount: Int\n}\n\"Edge type for ComponentApplicationVulnerability\"\ntype ComponentApplicationVulnerabilityEdge implements ConnectionEdge {\n  \"Cursor is an opaque string, you can use it to request subsequent or preceding items in the list\"\n  cursor: String\n  \"Application vulnerability node\"\n  node: ComponentApplicationVulnerability!\n}\n\"Provider for application vulnerability queries\"\ntype ComponentApplicationVulnerabilityProvider {\n  \"List of application vulnerabilities with pagination\"\n  list(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Input filters to filter application vulnerabilities\"\n    applicationFilter: ComponentApplicationFilterInput,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Supported fields on which sorting is supported: entityName\"\n    sort: [QuerySort!]\n  ): ComponentApplicationVulnerabilityConnection\n  \"Aggregations for application vulnerabilities\"\n  vulnerabilityAggregations(\n    \"Input filters to filter application vulnerabilities\"\n    applicationFilter: ComponentApplicationFilterInput\n  ): ComponentApplicationVulnerabilityAggregations\n}\ntype ComponentFoundationGroupInfo {\n  entityId: EntityId\n  entityName: String\n}\ntype ComponentTraits {\n  \"Info related to the current version of the component\"\n  componentVersionMetadata: ComponentVersionMetadata\n  foundationGroupInfo: ComponentFoundationGroupInfo\n}\ntype ComponentVersionMetadata {\n  currentVersion: String\n  cveFixed: String\n  lastPatchDate: DateTime\n  latestPatchVersion: String\n}\n\"Component vulnerability information\"\ntype ComponentVulnerability implements Node {\n  \"Component entity ID\"\n  componentId: String!\n  \"Count of affected critical CVEs (Exploitable or In Triage)\"\n  criticalCveCount: Int!\n  \"Current version of the component\"\n  currentVersion: String!\n  \"Number of CVEs fixed by the patch\"\n  cveFixed: Int!\n  \"Component type (TILE, STEMCELL, BUILDPACK, FOUNDATION_MANAGEMENT)\"\n  entityEdsType: String!\n  \"Component name\"\n  entityName: String!\n  \"Component type (TILE, STEMCELL, BUILDPACK, FOUNDATION_MANAGEMENT)\"\n  entityTvsType: String!\n  \"Foundation group ID\"\n  foundationGroupId: String!\n  \"Foundation group name\"\n  foundationGroupName: String!\n  \"Foundation entity ID\"\n  foundationId: String!\n  \"Foundation name\"\n  foundationName: String!\n  \"Count of affected high CVEs (Exploitable or In Triage)\"\n  highCveCount: Int!\n  \"Opaque global node ID, as per Node specification\"\n  id: ID!\n  \"Last patch date\"\n  lastPatchDate: DateTime!\n  \"Latest patch version available\"\n  latestPatchVersion: String!\n  \"URL to download the patch\"\n  patchUrl: String!\n}\n\"Connection type for ComponentVulnerability\"\ntype ComponentVulnerabilityConnection implements Connection {\n  \"Count of component vulnerabilities on this page\"\n  count: Int!\n  \"Relay-compatible component vulnerability edges\"\n  edges: [ComponentVulnerabilityEdge!]\n  \"Relay-compatible page info\"\n  pageInfo: PageInfo!\n  \"Total count of component vulnerabilities, may not always be an exact number and hence consumers should not rely only on this\"\n  totalCount: Int\n}\n\"Edge type for ComponentVulnerability\"\ntype ComponentVulnerabilityEdge implements ConnectionEdge {\n  \"Cursor is an opaque string, you can use it to request subsequent or preceding items in the list\"\n  cursor: String\n  \"Component vulnerability node\"\n  node: ComponentVulnerability!\n}\ntype ConversationalConfiguration implements Node {\n  \"Global unique id for the prompt\"\n  id: ID!\n  \"Enabled flag\"\n  isEnabled: Boolean!\n  \"Optional configuration metadata\"\n  metadata: String\n}\ntype ConversationalEventStream implements Node {\n  \"Count of streams in this page.\"\n  count: Int\n  \"Creation Timestamp for stream: UTC datetime eg 2022-01-31T12:00:00.000Z\"\n  creationTime: DateTime!\n  \"relay-compatible connection edge\"\n  edges: [ConversationalEventStreamConnectionEdge!]\n  \"List of events in the stream\"\n  events: ConversationalStreamEventConnection\n  id: ID!\n  pageInfo: PageInfo\n  \"The type of payload the stream will contain. This can help the client in rendering of payload as charts,graphs etc\"\n  payloadType: String!\n  \"Unique name of the stream across all possible conversational services(Global Search, IaC, QA) like Status, GraphQLQuery\"\n  streamName: String!\n  \"Optional total count of streams\"\n  totalCount: Int\n}\ntype ConversationalEventStreamConnection implements Connection {\n  \"Count of streams in this page.\"\n  count: Int!\n  \"relay-compatible connection edge\"\n  edges: [ConversationalEventStreamEdge!]\n  pageInfo: PageInfo!\n  \"List of streams for a conversational prompt within a session for the user\"\n  streams: [ConversationalEventStream!]\n  \"Optional total count of streams\"\n  totalCount: Int\n}\ntype ConversationalEventStreamConnectionEdge implements ConnectionEdge {\n  cursor: String\n  node: ConversationalStreamEvent!\n}\ntype ConversationalEventStreamEdge implements ConnectionEdge {\n  cursor: String\n  node: ConversationalEventStream!\n}\ntype ConversationalHistorySessionConnection implements Connection {\n  \"Count of sessions in this page.\"\n  count: Int!\n  \"relay-compatible connection edge\"\n  edges: [ConversationalSessionEdge!]\n  pageInfo: PageInfo!\n  \"List of conversational sessions for the user\"\n  sessions: [ConversationalSession!]\n  \"Optional total count of sessions\"\n  totalCount: Int\n}\ntype ConversationalMutation {\n  \"\"\"\n  Delete active credential\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `tia:Configuration:create`\n  \"\"\"\n  deleteActiveCredential: ID\n  \"\"\"\n  Delete configuration\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `tia:Configuration:create`\n  \"\"\"\n  deleteConfiguration: Long\n  \"\"\"\n  Deletes a conversational session and all associated prompts, streams and events\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `tia:Chat:delete`\n  \"\"\"\n  deleteConversationSession(sessionId: Long!): ConversationalSession!\n  \"\"\"\n  Stops/Interrupts an ongoing prompt in a conversational session\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `tia:Chat:update`\n  \"\"\"\n  interruptPrompt(input: ConversationalPromptInterruptInput!): String!\n  \"\"\"\n  Provide feedback for prompt's response\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `tia:ChatFeedback:create`\n  \"\"\"\n  submitFeedback(input: ConversationalPromptFeedbackInput!): String!\n  \"\"\"\n  Update a conversational session. Today, only conversational session's name can be updated\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `tia:Chat:update`\n  \"\"\"\n  updateConversationSession(input: ConversationalSessionUpdateInput!): ConversationalSession!\n  \"\"\"\n  Set active credential\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `tia:Configuration:create`\n  \"\"\"\n  upsertActiveCredential(credentialType: String!, managementEndpointCredentialId: ID!, managementEndpointId: ID!): ID!\n  \"\"\"\n  Upsert configuration\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `tia:Configuration:create`\n  \"\"\"\n  upsertConfiguration(isEnabled: Boolean!, metadata: JSON): Long!\n}\ntype ConversationalPrompt implements Node {\n  \"Context for the prompt optionally entered by client\"\n  context: String\n  \"Creation Timestamp of prompt: UTC datetime eg 2022-01-31T12:00:00.000Z\"\n  creationTime: DateTime!\n  \"Global unique id for the prompt\"\n  id: ID!\n  \"Query prompt entered by client\"\n  prompt: String!\n  \"Unique id for the prompt within a session\"\n  promptId: Int!\n  \"Status of the prompt: ACTIVE, INTERRUPTED\"\n  status: ConversationalPromptStatus\n  \"List of public streams for the prompt\"\n  streams: ConversationalEventStreamConnection\n}\ntype ConversationalPromptConnection implements Connection {\n  \"Count of prompts in this page.\"\n  count: Int!\n  \"relay-compatible connection edge\"\n  edges: [ConversationalPromptEdge!]\n  pageInfo: PageInfo!\n  \"List of conversational prompts within a session for the user\"\n  prompts: [ConversationalPrompt!]\n  \"Optional total count of prompts\"\n  totalCount: Int\n}\ntype ConversationalPromptEdge implements ConnectionEdge {\n  cursor: String\n  node: ConversationalPrompt!\n}\n\"Query the Tanzu Hub ecosystem in natural language\"\ntype ConversationalQuery {\n  \"\"\"\n  Returns the active management endpoint credential id for the current org\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `tia:Configuration:create`\n  \"\"\"\n  queryActiveCredential: String\n  \"\"\"\n  Query Tanzu Hub in natural language. Returns a unique sessionID and a unique promptId in the session\n  If the sessionId is not provided, a new session will be created\n  Else, the session will continue with a new promptId\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `tia:Chat:create`,\n  - `tia:Chat:update`\n  \"\"\"\n  queryByNaturalLanguage(\n    \"Client can pass additional context to support the conversation for instance the view user is looking at eg Governance\"\n    context: JSON,\n    \"Name for the conversational session. This is optional input. If not provided, will be fetched from first prompt in the conversation\"\n    conversationName: String,\n    \"query prompt entered by the client\"\n    prompt: String!,\n    \"optional existing sessionId of the ongoing conversational session of the user with the client\"\n    sessionId: Int\n  ): ConversationalResponse!\n  \"\"\"\n  Returns the configuration for the current org\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `tia:Configuration:create`\n  \"\"\"\n  queryConfiguration: ConversationalConfiguration\n  \"\"\"\n  Queries for events in a specific stream for a given sessionId + promptId combination\n  The results will be sorted in descending order by createdAt timestamp i.e. the most recent first\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `tia:Chat:read`\n  \"\"\"\n  queryConversationStream(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"\"\"\n    The promptId indicates the prompt in the ongoing contextual conversation of the user with\n    service in a single session. If omitted, the most recent promptId will be used\n    \"\"\"\n    promptId: Int,\n    \"Unique id used to track a single conversation session of the user with the service\"\n    sessionId: Int!,\n    \"Unique Name of the stream whose data is being requested\"\n    streamName: String!\n  ): ConversationalSingleEventStreamConnection\n  \"\"\"\n  Query to fetch Chat History/Updates for a user optionally filtered on Sessions, Prompts, Streams and/or Events\n  The results will be sorted in descending order by createdAt timestamp i.e. the most recent first\n  NOTE: first, before and after cursor values are for sessions. These values can also be passed at nested levels of prompts, streams and events\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `tia:Chat:read`\n  \"\"\"\n  queryConversationsHistory(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,filter: ConversationalHistoryInput!, \n    \"Return first N events in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10\n  ): ConversationalHistorySessionConnection!\n  \"\"\"\n  Queries all the available payload types\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `tia:Chat:read`\n  \"\"\"\n  queryPayloadTypes: [String!]\n  \"\"\"\n  Queries for a list of stream names and payload types available for a sessionId + promptId combination sorted in descending order by stream creation time\n  The results will be sorted in descending order by createdAt timestamp i.e. the most recent first\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `tia:Chat:read`\n  \"\"\"\n  queryStreams(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Return first N streams in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"\"\"\n    The promptId indicates the prompt in the ongoing contextual conversation of the user with\n    service in a single session.\n    \"\"\"\n    promptId: Int!,\n    \"Unique id used to track a single conversation session of the user with the service\"\n    sessionId: Int!\n  ): ConversationalEventStreamConnection\n}\n\"This is the response when a new user session is initiated or an existing session is continued with the client\"\ntype ConversationalResponse {\n  \"Summarized name for the conversational session, picked from first prompt in the session by default if not provided\"\n  conversationName: String\n  \"Unique id of the prompt in the ongoing conversation session\"\n  promptId: Int!\n  \"Unique id to track a single conversation flow of the user\"\n  sessionId: Int!\n}\ntype ConversationalSession implements Node {\n  \"Summarized name for the conversation\"\n  conversationName: String!\n  \"Creation Timestamp for session: UTC datetime eg 2022-01-31T12:00:00.000Z\"\n  creationTime: DateTime!\n  \"Global unique id for the session node\"\n  id: ID!\n  \"Update Timestamp for session: UTC datetime eg 2022-01-31T12:00:00.000Z\"\n  lastUpdateTime: DateTime!\n  \"List of conversational prompts within the session\"\n  prompts: ConversationalPromptConnection\n  \"Unique identifier for the session\"\n  sessionId: Int!\n}\ntype ConversationalSessionEdge implements ConnectionEdge {\n  cursor: String\n  node: ConversationalSession!\n}\n\"Relay compatible page of ConversationalStreamEvent\"\ntype ConversationalSingleEventStreamConnection implements Connection {\n  \"Count of events in this page.\"\n  count: Int!\n  \"relay-compatible connection edge\"\n  edges: [ConversationalEventStreamConnectionEdge!]\n  \"Events list\"\n  events: [ConversationalStreamEvent!]\n  pageInfo: PageInfo!\n  \"The type of payload eg: statusUpdate, graphQLQuery, graphQLQueryResponse, graphqlResultSummary, terraformSpec\"\n  payloadType: String!\n  \"\"\"\n  The promptId indicates the prompt in the ongoing contextual conversation of the user with\n  service in the session.\n  \"\"\"\n  prompt: ConversationalPrompt!\n  \"Unique id used to track a single conversation session of the user with the service\"\n  session: ConversationalSession!\n  \"Unique Name of the stream whose data is being sent\"\n  streamName: String!\n  \"Optional total count of events\"\n  totalCount: Int\n}\n\"The payload depends on stream's payloadType and can represent for instance graphQL query, graphQL query response, graphql response summary etc\"\ntype ConversationalStreamEvent implements Node {\n  \"Creation Timestamp for event: UTC datetime eg 2022-01-31T12:00:00.000Z\"\n  creationTime: DateTime!\n  \"Global unique ID for an stream event based on unique identifiers for sessionId, streamName, promptId and sequenceNum\"\n  id: ID!\n  \"Boolean flag to mark the last event in any stream for a particular session and prompt\"\n  isEndOfStream: Boolean!\n  \"The actual event data\"\n  payload: String!\n  \"\"\"\n  Represents the number of this event in the sequence of events in a stream for a particular session and a\n  particular prompt in that session\n  \"\"\"\n  sequenceNum: Int!\n}\ntype ConversationalStreamEventConnection implements Connection {\n  \"Count of events in this page.\"\n  count: Int!\n  \"relay-compatible connection edge\"\n  edges: [ConversationalStreamEventConnectionEdge!]\n  events: [ConversationalStreamEvent!]\n  pageInfo: PageInfo!\n  \"Optional total count of events\"\n  totalCount: Int\n}\ntype ConversationalStreamEventConnectionEdge implements ConnectionEdge {\n  cursor: String\n  node: ConversationalStreamEvent!\n}\ntype Dashboard implements Node & NodeVersion {\n  \"category represents a unique dashboard type can take any form as consumer/UI pleases\"\n  category: String!\n  \"CSP user who created dashboard\"\n  createdBy: User!\n  \"Timestamp at which dashboard is created. Expressed in UTC ISO-8601 format\"\n  creationTime: DateTime!\n  \"unique identifier for the dashboard\"\n  dashboardId: String!\n  \"indicates if dashboard is visible at an org level or for a user\"\n  dashboardVisibility: DashboardVisibility!\n  \"Opaque global node ID\"\n  id: ID!\n  \"Timestamp at which dashboard is updated. Expressed in UTC ISO-8601 format\"\n  lastUpdateTime: DateTime\n  \"Opaque version string for this graph node instance\"\n  nodeVersion: ID!\n  \"This represents a dashboard structure than can be rendered using a UI technology \"\n  payload: JSON!\n  \"scope entities associated with the dashboard (only for SCOPED visibility)\"\n  scopingEntities: [Entity!]\n  \"scope types associated wuth the dashboard (only for the SCOPED visibility)\"\n  scopingTypes: [DashboardScopeType!]\n  \"tags associated with the dashboard\"\n  tags: [DashboardTag!]\n  \"CSP user who updated dashboard\"\n  updatedBy: User\n}\ntype DashboardBulkDeleteResponse {\n  failure: [DashboardDeleteFailure!]\n  success: [Dashboard!]\n}\n\"Dashboard Connection Type\"\ntype DashboardConnection implements Connection {\n  \"count of dashboards on this page\"\n  count: Int!\n  \"dashboards instances\"\n  dashboards: [Dashboard!]\n  \"dashboard edge\"\n  edges: [DashboardEdge!]\n  \"Represents pagination information in Relay about the edges.\"\n  pageInfo: PageInfo!\n  \"Total count of dashboards, may not always be an exact number and hence consumers should not rely only on this\"\n  totalCount: Int\n}\ntype DashboardDefault implements Node {\n  \"category represents a unique dashboard type can take any form as consumer/UI pleases\"\n  category: String!\n  \"CSP user who created dashboard\"\n  createdBy: User!\n  \"Timestamp at which dashboard is created. Expressed in UTC ISO-8601 format\"\n  creationTime: DateTime!\n  \"unique identifier for the dashboard\"\n  dashboardId: String!\n  \"indicates if dashboard is visible at an org level or for a user\"\n  defaultType: DashboardDefaultType!\n  \"Opaque global node ID\"\n  id: ID!\n  \"Timestamp at which dashboard is updated. Expressed in UTC ISO-8601 format\"\n  lastUpdateTime: DateTime\n  \"CSP user who updated dashboard\"\n  updatedBy: User\n}\n\"DashboardDefault Connection Type\"\ntype DashboardDefaultConnection implements Connection {\n  \"count of dashboard default on this page\"\n  count: Int!\n  \"dashboards instances\"\n  dashboardDefault: [DashboardDefault!]\n  \"default dashboard edge\"\n  edges: [DashboardDefaultEdge!]\n  \"Represents pagination information in Relay about the edges.\"\n  pageInfo: PageInfo!\n  \"Total count of dashboard defaults, may not always be an exact number and hence consumers should not rely only on this\"\n  totalCount: Int\n}\ntype DashboardDefaultEdge implements ConnectionEdge {\n  \"Cursor is an opaque string, you can use it to request subsequent or preceding items in the list\"\n  cursor: String!\n  \"dashboard default node\"\n  node: DashboardDefault!\n}\n\"Result of dashboard delete operation\"\ntype DashboardDeleteFailure {\n  \"dashboard id\"\n  dashboardId: ID!\n  \"error message indicating delete failure\"\n  errorMessage: String\n  \"optional nodeVersion if passed in input\"\n  nodeVersion: ID\n}\ntype DashboardEdge implements ConnectionEdge {\n  \"Cursor is an opaque string, you can use it to request subsequent or preceding items in the list\"\n  cursor: String!\n  \"dashboard node\"\n  node: Dashboard!\n}\ntype DashboardMutation {\n  \"\"\"\n  Delete multiple custom dashboards. This will also delete the default dashboard settings associated with these dashboards if present.\n  Input to this API are dashboardIds and nodeVersions if optimistic locking is needed.\n  ORG level dashboards can be deleted by organization admins.\n  USER level dashboards can be deleted by users owning the dashboard.\n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  ### API Permissions:\n  - `user:SharedDashboard:delete`,\n  - `user:UserDashboard:delete`\n  \"\"\"\n  bulkDeleteDashboards(dashboards: [DashboardBulkDeleteInput!]): DashboardBulkDeleteResponse\n  \"\"\"\n  Delete a custom dashboard. This will delete the dashboard defaults associated with dashboard ( if any)\n  ORG level dashboards can be deleted by organization admins.\n  USER level dashboards can be deleted by users owning the dashboard.\n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  ### API Permissions:\n  - `user:SharedDashboard:delete`,\n  - `user:UserDashboard:delete`\n  \"\"\"\n  deleteDashboard(dashboardId: String!, nodeVersion: ID): Dashboard!\n  \"\"\"\n  Set a dashboard as default for a user/organization and category.\n  Only ORG dashboards can be set as ORG_DEFAULT by an admin.\n  Any dashboard that is visible to a user can be set as USER_DEFAULT for themselves.\n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  ### API Permissions:\n  - `user:SharedDashboard:create`,\n  - `user:SharedDashboard:update`,\n  - `user:UserDashboard:update`,\n  - `user:UserDashboard:create`\n  \"\"\"\n  setDefaultDashboard(category: String!, dashboardId: String!, defaultType: DashboardDefaultType!): DashboardDefault!\n  \"\"\"\n  UnSet a dashboard as default for a user/organization and category.\n  Only org admin would be able to un-set the ORG_DEFAULT dashboard.\n  PROJECT dashboard can be unset by Project admin or Org admin.\n  USER dashboards can be unset by user owning the dashboard.\n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  ### API Permissions:\n  - `user:SharedDashboard:create`,\n  - `user:SharedDashboard:update`,\n  - `user:UserDashboard:update`,\n  - `user:UserDashboard:create`\n  \"\"\"\n  unSetDefaultDashboard(category: String!, defaultType: DashboardDefaultType!): DashboardDefault!\n  \"\"\"\n  Create or update a dashboard.\n  When updating a dashboard dashboardId, nodeVersion, payload and category are required parameters, the other attributes ( dashboardVisibility) are all optional and will be updated if passed.\n  When creating a dashboard dashboardId and nodeVersion are not required, all other attributes (payload, category) are all required.\n  When updating the ORG dashboard,\n  if the user is an admin it should update the dashboard instance.\n  if the user is not an admin a copy of the dashboard should be created with the modifications.\n  Upsert call with no tags, will clear the existing tags.\n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  ### API Permissions:\n  - `user:SharedDashboard:create`,\n  - `user:SharedDashboard:update`,\n  - `user:UserDashboard:update`,\n  - `user:UserDashboard:create`\n  \"\"\"\n  upsertDashboard(input: DashboardInput!): Dashboard!\n}\ntype DashboardQuery {\n  \"\"\"\n  Query all Custom dashboards\n  This API follows GraphQL relay pagination specification\n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  ### API Permissions:\n  - `user:SharedDashboard:read`,\n  - `user:UserDashboard:read`\n  \"\"\"\n  queryDashboards(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Input filters to filter output of this API\"\n    filter: DashboardFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"\"\"\n    Results are sorted as per fields and order specified. Supported fields are name, category only\n    Invalid field provided would throw an error : Provide a valid sort field for fetching dashboards.\n    Default sort order : updatedOn\n    \"\"\"\n    sort: QuerySort\n  ): DashboardConnection\n  \"\"\"\n  Query all default dashboards\n  This API follows GraphQL relay pagination specification\n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  ### API Permissions:\n  - `user:SharedDashboard:read`,\n  - `user:UserDashboard:read`\n  \"\"\"\n  queryDefaultDashboards(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Input filters to filter output of this API\"\n    filter: DashboardFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Results are sorted as per fields and order specified.\"\n    sort: QuerySort\n  ): DashboardDefaultConnection\n}\ntype DashboardTag {\n  \"tag key\"\n  key: String!\n  \"tag value\"\n  value: String\n}\ntype DerivedDataMutation {\n  \"\"\"\n  \n  ### API Permissions:\n  - `deriveddata:Export:read`\n  \"\"\"\n  exportDerivedData(\n    \"Document config to provide configurations of the downloaded document\"\n    documentConfiguration: DerivedDataDocConfigInput!,\n    \"\"\"\n    Optional embedded GraphQL query string to execute with variables passed in to this query - use this or the\n    embedded entityQuery field.\n    \n    If pagination data is not provided the query must fetch all the data to be post-processed in one go, or the\n    client must externalize the paging by returning the required pageInfo in the response and then using it to\n    formulate a new separate query on a next page.\n    \"\"\"\n    graphQLQuery: String,\n    \"\"\"\n    JSON of variables map to resolve the variables present in graphQLQuery field.\n    Note: This should be used only when graphQL queryString is provided\n    \"\"\"\n    graphQLQueryVariables: JSON,\n    \"\"\"\n    We can use pagination by providing paginationData as input. User needs to declare a query variable\n    for the after input parameter in the query, provide the variable name in pathToEndCursor, json path to hasNext\n    and endCursor output fields in pageInfo, maxRowCount for the number of rows to be fetched,\n    \"\"\"\n    paginationData: DerivedDataPaginationInput,\n    \"Derive data from the result of the query\"\n    processingRules: DerivedDataProcessingRulesInput\n  ): DerivedDataMutationResponse!\n}\ntype DerivedDataMutationResponse {\n  \"\"\"\n  Document entity which represents the output of running the processing rules over the response from the embedded\n  entity query.\n  This is an async process and the file will be available for download when the state changes to PROCESSING_COMPLETE\n  \"\"\"\n  document: Document!\n  \"\"\"\n  This field provides a strongly-typed embedded entityQuery to execute. Use this or the graphqlQuery input parameter\n  but not both. This field will always be null in the response, if provided, it is used as an input parameter.\n  \"\"\"\n  entityQuery: EntityQuery\n}\n\"Pagination\"\ntype DerivedDataPagination {\n  \"Name of the query variable that configures the value of the `after` parameter for paging\"\n  afterVariableName: String!\n  \"Maximum number of paged elements to include in the output\"\n  maxRowCount: Int!\n  \"\"\"\n  JSON path to field that contains the list of elements to accumulate for the output.\n  \n  For example, in an entity query it might be `entityQuery.queryEntities.entities`\n  \"\"\"\n  pathToListOfRowElements: String!\n  \"\"\"\n  JSON path to pageInfo field in the result. Ex: entityQuery.queryEntities.pageInfo\n  It is mandatory to include hasNextPage` and `endCursor` fields in the query response. Query will fail to fetch\n  response in absence of these fields.\n  \"\"\"\n  pathToPageInfo: String!\n}\n\"Rules needed for derived data query execution\"\ntype DerivedDataProcessingRules {\n  \"Processing rules may be expressed in [jmespath syntax](https://jmespath.org/)\"\n  jmesPathRules: [String!]\n  \"Processing rules may be expressed in [jsonata syntax](https://docs.jsonata.org/overview.html)\"\n  jsonataRules: [String!]\n}\ntype DerivedDataQuery {\n  \"\"\"\n  \n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  \"\"\"\n  queryDerivedData(\n    \"Document config to provide configurations of the downloaded document\"\n    cachingHints: DerivedDataCachingHintsInput,\n    \"\"\"\n    Optional embedded GraphQL query string to execute with variables passed in to this query - use this or the\n    embedded entityQuery field.\n    \n    If pagination data is not provided the query must fetch all the data to be post-processed in one go, or the\n    client must externalize the paging by returning the required pageInfo in the response and then using it to\n    formulate a new separate query on a next page.\n    \n    Note: Pagination support is WIP, please use one-shot query until it is available\n    \"\"\"\n    graphQLQuery: String,\n    \"\"\"\n    JSON of variables map to resolve the variables present in graphQLQuery field.\n    Note: This should be used only when graphQL queryString is provided\n    \"\"\"\n    graphQLQueryVariables: JSON,\n    \"\"\"\n    We can use pagination by providing paginationData as input. User needs to declare a query variable\n    for the after input parameter in the query, provide the variable name in pathToEndCursor, json path to hasNext\n    and endCursor output fields in pageInfo, maxRowCount for the number of rows to be fetched,\n    \"\"\"\n    paginationData: DerivedDataPaginationInput,\n    \"Derive data from the result of the query\"\n    processingRules: DerivedDataProcessingRulesInput\n  ): DerivedDataResponse!\n}\ntype DerivedDataResponse {\n  \"Output of running the processing rules over the response from the embedded entity query\"\n  derivedData: JSON\n  \"\"\"\n  This field provides a strongly-typed embedded entityQuery to execute. Use this or the graphqlQuery input parameter but not both.\n  This field will always be null in the response, if provided, it is used as an input parameter.\n  \"\"\"\n  entityQuery: EntityQuery\n}\n\"Node representing a document\"\ntype Document implements Node {\n  \"Document Category\"\n  category: DocumentCategory!\n  \"User who created the document\"\n  createdBy: User\n  \"Time this document was created. Note: Expressed in UTC ISO-8601 format\"\n  creationTime: DateTime!\n  \"Optional description related to document\"\n  description: String\n  \"Hyperlink to download document. Hyperlink will return raw document in response with optional Content-Type header\"\n  downloadLink: HyperLink\n  \"Optional entityId to associate the document with an entity\"\n  entityId: EntityId\n  \"Optional Document TTL to delete the document after the specified date\"\n  expiryTime: DateTime\n  \"Opaque global node ID\"\n  id: ID!\n  \"User updated the document\"\n  lastModifiedBy: User\n  \"Last modified time of the document\"\n  lastModifiedTime: DateTime\n  \"Document name\"\n  name: String!\n  \"Document size in bytes\"\n  sizeBytes: Long\n  \"Document state\"\n  state: DocumentProcessingState!\n  \"Tags of the document\"\n  tags: [Tag!]\n  \"Type of the document represented by the Enum DocumentType\"\n  type: DocumentType\n}\ntype DocumentConnection implements Connection {\n  \"Count of documents in this page.\"\n  count: Int!\n  \"List of documents in this page\"\n  documents: [Document!]\n  \"Relay-compatible connection edges for this page\"\n  edges: [DocumentEdge!]\n  \"Relay-compatible paging information\"\n  pageInfo: PageInfo!\n  \"NOTE: This field is expensive to compute and should be used sparingly if at all necessary. Total count of matching documents\"\n  totalCount: Int\n}\n\"Relay-compatible connection edge containing Document node\"\ntype DocumentEdge implements ConnectionEdge {\n  cursor: String!\n  node: Document!\n}\ntype DocumentMutation {\n  \"\"\"\n  Delete documents by ID. Returns list of IDs of successfully deleted documents.\n  ### API Permissions:\n  - `document:*:create`\n  \"\"\"\n  deleteDocuments(documentIds: [ID!]!): [ID!]!\n  \"\"\"\n  Update document TTL, to delete the document on the specified date. Null expiry date will remove any TTL applied earlier\n  ### API Permissions:\n  - `document:*:update`\n  \"\"\"\n  updateDocumentTTL(\n    \"Expiry time after which the document will be deleted\"\n    expiryTime: DateTime,\n    \"document id\"\n    id: ID!\n  ): Document\n}\ntype DocumentQuery {\n  \"\"\"\n  Generates a hyperlink to which document can be uploaded.\n  If user pass optional ID filed, it will be an UPSERT operation otherwise INSERT\n  ### API Permissions:\n  - `document:*:create`\n  \"\"\"\n  generateUploadHyperlink(category: DocumentCategory!, id: ID, name: String!, tags: [TagInput!], type: DocumentType): HyperLink\n  \"\"\"\n  Query documents for a given list of document IDs or by documentType\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `document:*:read`\n  \"\"\"\n  queryDocuments(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Mandatory Document category filter\"\n    category: DocumentCategory,\n    \"Optional filter to query documents associated with a list of entities\"\n    entityIds: [EntityId!],\n    \"Optional additional field filters.\"\n    filter: QueryFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Optional ID filed to query document\"\n    id: [ID!],\n    \"Name of the document\"\n    name: [String!],\n    \"Results sort order\"\n    sort: [QuerySort!],\n    \"Document metadata key or key-value pair filter\"\n    tag: TagInput\n  ): DocumentConnection!\n}\n\"\"\"\nPrimary Entity type in the graph, implementing the individual EntityNode interface\nand with additional fields permitting traversals to other entities in the entity topology and\nto access other graph nodes with information related to the entity.\n\"\"\"\ntype Entity implements EntityNodeInterface & Node & NodeVersion {\n  \"The cloud account ID. This is a synonym for the `managementEndpointId` field of this entity, exposed for quick filtering for public cloud accounts.\"\n  cloudAccountId: String\n  \"This optional property represents an unique ID of the source collector\"\n  collectionSource: String\n  \"Time this Entity was created. Note: Expressed in UTC ISO-8601 timestamp\"\n  creationTime: DateTime\n  \"\"\"\n  query documents for this entity.\n  ### API Permissions:\n  - `document:*:read`\n  \"\"\"\n  documents(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Document category filter\"\n    category: DocumentCategory,\n    \"Optional additional field filters.\"\n    filter: QueryFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Name of the document\"\n    name: [String!],\n    \"Results sort order\"\n    sort: [QuerySort!],\n    \"Document metadata key or key-value pair filter\"\n    tag: TagInput\n  ): DocumentConnection\n  \"Paged parent entities, optionally filtering by fields, most filters support leading '!' (not) and trailing '*' (starts with)\"\n  entitiesIn(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Optionally filter by related entities being present / absent\"\n    entitiesTraversalFilter: EntityTraversalFilterInput,\n    \"Optionally filter by entityIds\"\n    entityId: [EntityId!],\n    \"Optionally filter by this field, support leading '!' (not) and trailing '*' (starts with)\"\n    entityType: [String!],\n    \"Optionally filter by entityTypes corresponding to the values from the enum (this can be used for its autocomplete functionality)\"\n    entityTypeConst: [EntityTypeConst!],\n    \"\"\"\n    Optional additional field filters.\n    \n    The field format is `[[namespaces.<namespace>.](properties.|tags.)]<fieldname>`\n    \"\"\"\n    filter: QueryFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Optionally filter by this field, support leading '!' (not) and trailing '*' (starts with)\"\n    provider: [String!],\n    \"\"\"\n    Filter traversal by one of the given relationship types, requires an exact match.\n    Traversal across 'in' relationships should be optimized by specifying a relationshipType otherwise they will be slow.\n    \"\"\"\n    relationshipType: [String!],\n    \"Optionally filter by this field, support leading '!' (not) and trailing '*' (starts with)\"\n    service: [String!],\n    \"Optional sort order for results in EntityConnection\"\n    sort: [QuerySort!],\n    \"Optionally specify whether the traversals should be constrained to same partition (cloud account id), can be used for optimizing some queries\"\n    traversalScope: EntityTraversalScope = ANY_PARTITION\n  ): EntityConnection\n  \"Paged child entities, optionally filtering by fields, most filters support leading '!' (not) and trailing '*' (starts with)\"\n  entitiesOut(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Optionally filter by related entities being present / absent\"\n    entitiesTraversalFilter: EntityTraversalFilterInput,\n    \"Optionally filter by entityIds\"\n    entityId: [EntityId!],\n    \"Optionally filter by this field, support leading '!' (not) and trailing '*' (starts with)\"\n    entityType: [String!],\n    \"Optionally filter by entityTypes corresponding to the values from the enum (this can be used for its autocomplete functionality)\"\n    entityTypeConst: [EntityTypeConst!],\n    \"\"\"\n    Optional additional field filters.\n    \n    The field format is `[[namespaces.<namespace>.](properties.|tags.)]<fieldname>`\n    \"\"\"\n    filter: QueryFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Optionally filter by this field, support leading '!' (not) and trailing '*' (starts with)\"\n    provider: [String!],\n    \"Optionally filter traversal by one of the given relationship types, requires an exact match\"\n    relationshipType: [String!],\n    \"Optionally filter by this field, support leading '!' (not) and trailing '*' (starts with)\"\n    service: [String!],\n    \"Optional sort order for results in EntityConnection\"\n    sort: [QuerySort!],\n    \"Optionally specify whether the traversals should be constrained to same partition (cloud account id), can be used for optimizing some queries\"\n    traversalScope: EntityTraversalScope = ANY_PARTITION\n  ): EntityConnection\n  \"Single or multi-step entity graph traversal returning paged entities at the end of the traversal\"\n  entitiesTraversal(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Entities Traversal specifies the path to traverse through the Entity graph, with optional filtering at each step\"\n    entitiesTraversal: [EntityTraversalInput!]!,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"optionally specify recursion information for this traversal allowing the traversal to repeat\"\n    recursion: EntityTraversalRecursionInfo,\n    \"Optional sort order for results in EntityConnection\"\n    sort: [QuerySort!]\n  ): EntityConnection\n  \"\"\"\n  Calculate number of recorded changes to this entity in the given time window.\n  Individual changes for a specific entity can be fetched using `EntityQuery.queryEntityChangeLog()`.\n  \"\"\"\n  entityChangeCount(timeRange: EntityTimeRangeFilter!): Int\n  \"Unique identifier for an entity in a canonical form. Uniqueness applies at the scope of the entire organization\"\n  entityId: EntityId!\n  \"Optional. EntityName of the entity\"\n  entityName: String\n  \"access the schema for this entity's entityType, if available\"\n  entitySchema: EntitySchema\n  \"\"\"\n  EntityScopes provide information on the membership and visibility of the Entity.\n  \n  For example, if an Entity is in the scope of a VMW.Aria.BusinessApplication then it is considered to be \"visible\"\n  as a part of that Business Application.\n  \n  If the Entity is in the scope of a VMW.CSP.Project, then the Entity will be visible be visible\n  to users who's roles are scoped to that specific CSP project.\n  \n  An Entity may have multiple scopes, or none.\n  \"\"\"\n  entityScopes: EntityScopes\n  \"EntityType of the entity. e.g. `ec2`, `security-group` etc. Required but not enforced because of federation constraints.\"\n  entityType: String\n  \"entityType as an enum constant\"\n  entityTypeConst: EntityTypeConst\n  \"\"\"\n  Get hyperlinks for this entity. Optionally filter by namespace\n  ### API Permissions:\n  \"\"\"\n  hyperlinks(namespace: [String!]): [HyperLink!]\n  \"Opaque global ID\"\n  id: ID!\n  \"Last time this entity was updated. Note: Expressed in UTC ISO-8601 timestamp\"\n  lastUpdateTime: DateTime\n  managementEndpoint: ManagementEndpoint\n  \"namespaces for this entity, filtered by namespace\"\n  namespaces(namespace: [String!]): [EntityNamespace!]\n  \"Versioning ID\"\n  nodeVersion: ID!\n  \"Properties for this entity, optionally filtered by name\"\n  properties(name: [String!]): [EntityProperty!]\n  \"provider component of the entityType\"\n  provider: String\n  \"For cloud resources, this property contains the entity region\"\n  region: String\n  \"\"\"\n  summarize relationships to or from this entity e.g. count relationships to or from a given type\n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  \"\"\"\n  relationshipAggregations(\n    \"Specify aggregation buckets\"\n    aggregations: [EntityAggregationInput!]!,\n    \"Mandatory traversal direction - only IN or OUT supported, not BOTH\"\n    direction: EntityTraversalDirection!,\n    \"Specify query filter e.g. to filter on relationshipType or sourceEntityType/destEntityType\"\n    relationshipQueryFilter: EntityRelationshipQueryFilter\n  ): EntityAggregations!\n  \"Paged relationships to parents, optionally filtering by fields, most filters support leading '!' (not) and trailing '*' (starts with)\"\n  relationshipsIn(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Optionally filter by related entities being present / absent\"\n    entitiesTraversalFilter: EntityTraversalFilterInput,\n    \"Additional filters on 'other' entity fields\"\n    entityFilter: QueryFilter,\n    \"Filter on the 'other' entity type\"\n    entityType: [String!],\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"\"\"\n    Filter traversal by one of the given relationship types, requires an exact match.\n    Traversal across 'in' relationships should be optimized by specifying a relationshipType otherwise they will be slow.\n    \"\"\"\n    relationshipType: [String!],\n    \"Optional sort order for results\"\n    sort: [QuerySort!],\n    \"Optionally specify whether the traversals should be constrained to same partition (cloud account id), can be used for optimizing some queries\"\n    traversalScope: EntityTraversalScope = ANY_PARTITION\n  ): EntityRelationshipConnection\n  \"Paged relationships to children, optionally filtering by fields\"\n  relationshipsOut(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Optionally filter by related entities being present / absent\"\n    entitiesTraversalFilter: EntityTraversalFilterInput,\n    \"Additional filters on 'other' entity fields\"\n    entityFilter: QueryFilter,\n    \"Filter on the 'other' entity type\"\n    entityType: [String!],\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Filter traversal by one of the given relationship types, requires an exact match\"\n    relationshipType: [String!],\n    \"Optional sort order for results\"\n    sort: [QuerySort!],\n    \"Optionally specify whether the traversals should be constrained to same partition (cloud account id), can be used for optimizing some queries\"\n    traversalScope: EntityTraversalScope = ANY_PARTITION\n  ): EntityRelationshipConnection\n  \"Single-step relationship traversal returning paged relationships based upon the given filters\"\n  relationshipsTraversal(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Mandatory traversal direction\"\n    direction: EntityTraversalDirection!,\n    \"Optionally filter by related entities being present / absent\"\n    entitiesTraversalFilter: EntityTraversalFilterInput,\n    \"Additional filters on 'other' entity fields\"\n    entityFilter: QueryFilter,\n    \"Filter on the 'other' entity type\"\n    entityType: [String!],\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Optionally filter traversal by one of the given relationship types, requires an exact match\"\n    relationshipType: [String!],\n    \"Optional sort order for results\"\n    sort: [QuerySort!],\n    \"Optionally specify whether the traversals should be constrained to same partition (cloud account id), can be used for optimizing some queries\"\n    traversalScope: EntityTraversalScope = ANY_PARTITION\n  ): EntityRelationshipConnection\n  \"service component of the entityType\"\n  service: String\n  \"Key/Value tags for this entity, optionally filtered by key\"\n  tags(key: [String!]): [Tag!]\n  \"type-specific traits\"\n  traits: EntityTraits!\n  \"\"\"\n  Accesses the equivalent strongly-typed Entity interface.\n  Use an inline fragment to access fields from the specific type e.g.\n  ```\n  entities {\n    entityName\n    typedEntity {\n      ... on Entity_Tanzu_TAS_Foundation_Type {\n        properties {\n            environmentType\n        }\n      }\n    }\n  }\n  ```\n  \"\"\"\n  typedEntity: EntityTypedInterface\n  \"\"\"\n  Get user specific fields connected to a given entity, given the optional list of userIds as input.\n  UserId other than the current user can only be provided by admin users.\n  ### API Permissions:\n  \"\"\"\n  userFields: [UserEntityFields!]\n  \"query capacityInfo for this entity.\"\n  capacity(after: String, first: Int = 10): CapacityInfoConnection\n  \"\"\"\n  query events for this entity\n  ### API Permissions:\n  \"\"\"\n  events(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,input: EventInput  ): EventConnection\n  \"query insights\"\n  insightConnection(after: String, filter: QueryFilter, first: Int = 10, input: InsightFilter, sort: [QuerySort!]): InsightConnection\n  \"\"\"\n  query logs for this entity\n  ### API Permissions:\n  \"\"\"\n  logs(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,input: LogInput  ): LogConnection\n  \"query observations\"\n  observationConnection(after: String, filter: QueryFilter, first: Int = 10, input: ObservationFilter, sort: [QuerySort!]): ObservationConnection\n  \"\"\"\n  query timeseries stats for this entity.\n  ### API Permissions:\n  - `observability:ObservabilityStat:read`\n  \"\"\"\n  stats(input: StatsInput): [Stat!]\n}\ntype EntityAggregationItem implements CommonAggregationItem {\n  \"Count of instances of the given value\"\n  count: Long!\n  \"If the value contains an entityId navigate to the referenced Entity\"\n  referencedEntity: Entity\n  subAggregations: [EntityAggregationItems!]\n  \"field value\"\n  value: String!\n}\ntype EntityAggregationItems implements CommonAggregationItems {\n  \"The name of the aggregation, concatenates the field name and aggregation type\"\n  aggregationName: String!\n  \"Number of distinct buckets\"\n  bucketCount: Long!\n  buckets: [EntityAggregationItem!]\n  \"\"\"\n  Field key for which values are being aggregated.\n  \n  For entities, the field format is `[[namespaces.<namespace>.](properties.|tags.)]<fieldname>`\n  \"\"\"\n  field: String!\n  \"Value contains the result of min, max and sum metric aggregations\"\n  value: Float\n  \"Value contains the result of percentiles and stats metric aggregations\"\n  values: [EntityMetricAggregationValue!]\n}\ntype EntityAggregations implements CommonAggregations {\n  aggregations: [EntityAggregationItems!]\n  totalCount: Long!\n}\n\"Paged entity changelog information\"\ntype EntityChangeLogConnection implements Connection {\n  changeLogEntry: [EntityChangeLogEntry!]\n  count: Int!\n  edges: [EntityChangeLogEdge!]\n  pageInfo: PageInfo!\n  totalCount: Int\n}\ntype EntityChangeLogEdge implements ConnectionEdge {\n  cursor: String!\n  node: EntityChangeLogEntry!\n}\ntype EntityChangeLogEntry implements Node {\n  entityIsDeleted: Boolean!\n  fieldChanges: [EntityChangeLogFieldChange!]\n  id: ID!\n  lastUpdateTime: DateTime!\n  namespaceChanges: [EntityChangeLogNamespaceChange!]\n  propertyChanges: [EntityChangeLogFieldChange!]\n  tagChanges: [EntityChangeLogFieldChange!]\n}\ntype EntityChangeLogFieldChange {\n  changeType: EntityChangeLogChangeType!\n  fieldName: String!\n  \"Change values are converted to a string. Properties of type set are JSONified strings.\"\n  newValue: String\n  \"Change values are converted to a string. Properties of type set are JSONified strings.\"\n  oldValue: String\n}\ntype EntityChangeLogNamespaceChange {\n  fieldChanges: [EntityChangeLogFieldChange!]\n  namespaceName: String!\n  propertyChanges: [EntityChangeLogFieldChange!]\n  tagChanges: [EntityChangeLogFieldChange!]\n}\ntype EntityConnection implements Connection {\n  \"Count of entities in this page.\"\n  count: Int!\n  edges: [EntityEdge!]\n  \"List of entities in this page\"\n  entities: [Entity!]\n  pageInfo: PageInfo!\n  \"\"\"\n  Total count of matching entities if available.\n  NOTE: This is currently only populated under specific conditions:\n  - for entityQuery, there must not be a traversalFilter\n  - for entitiesIn/Out/Traversals:\n    - traversal direction must not be BOTH\n    - only relationship fields may be included in filter parameters, this includes entityType and entityId as well as relationshipType\n  \"\"\"\n  totalCount: Int\n}\ntype EntityEdge implements ConnectionEdge {\n  cursor: String!\n  node: Entity!\n  \"\"\"\n  When the EntityConnection is the result of a recursive entitiesTraversal, this field can optionally\n  contain the traversal path used to navigate from the originating Entity to the destination Entity in the traversal\n  \"\"\"\n  traversalPath: EntityEdgeTraversalPath\n}\ntype EntityEdgeTraversalPath {\n  count: Int!\n  entities: [Entity!]\n}\ntype EntityMetricAggregationValue {\n  key: String!\n  value: Float\n}\ntype EntityNamespace {\n  \"Time the resource was created from the perspective of this namespace. Note: Expressed in UTC ISO-8601 timestamp\"\n  creationTime: DateTime\n  \"Optional resource display name from the perspective of this namespace\"\n  displayName: String\n  \"Optional resource id from the perspective of this namespace\"\n  id: EntityId\n  \"Last time resource was updated from the perspective of this namespace. Note: Expressed in UTC ISO-8601 timestamp\"\n  lastUpdateTime: DateTime\n  \"Namespace identifier\"\n  name: String!\n  \"Properties in this namespace, optionally filtered by name\"\n  properties(name: [String!]): [EntityProperty!]\n  \"Optional resource provider from the perspective of this namespace\"\n  provider: String\n  \"Optional resource region from the perspective of this namespace\"\n  region: String\n  \"Optional resource service from the perspective of this namespace\"\n  service: String\n  \"Optional source of a namespace\"\n  source: String\n  \"\"\"\n  Key/Value tags for this entity, optionally filtered by key\n  \n  Underlying systems that support multi-valued tags have multiple tag values mapped to a comma-separated string.\n  Commas in values are escaped with a leading backslash, and any backslash character in a value is itself escaped.\n  \"\"\"\n  tags(key: [String!]): [Tag!]\n  \"Optional resource type from the perspective of this namespace\"\n  type: String\n  \"\"\"\n  query timeseries stats from this namespace for this entity.\n  ### API Permissions:\n  - `observability:ObservabilityAlert:read`\n  \"\"\"\n  stats(input: StatsInput): [Stat!]\n}\n\"\"\"\nBare Entity type, implementing the individual EntityNode interface, but without the\nability to traverse to other Entities or other graph nodes containing information about the Entity.\n\nThis type may be used in situations such as notifications where it is not possible to navigate the graph\nfrom the Entity information.\n\"\"\"\ntype EntityNode implements EntityNodeInterface & Node & NodeVersion {\n  \"The cloud account ID. This is a synonym for the `managementEndpointId` field of the `managementEndpoint` of this entity, exposed for quick filtering for public cloud accounts.\"\n  cloudAccountId: String\n  \"This optional property represents an unique ID of the source collector\"\n  collectionSource: String\n  \"Time this Entity was created. Note: Expressed in UTC ISO-8601 timestamp\"\n  creationTime: DateTime\n  \"Unique identifier for an entity in a canonical form. Uniqueness applies at the scope of the entire organization\"\n  entityId: EntityId!\n  \"Optional. EntityName of the entity\"\n  entityName: String\n  \"EntityType of the entity. e.g. `ec2`, `security-group` etc. Required but not enforced because of federation constraints.\"\n  entityType: String\n  \"entityType as an enum constant\"\n  entityTypeConst: EntityTypeConst\n  \"Opaque global ID\"\n  id: ID!\n  \"Last time this entity was updated. Note: Expressed in UTC ISO-8601 timestamp\"\n  lastUpdateTime: DateTime\n  \"namespaces for this entity, filtered by namespace\"\n  namespaces(namespace: [String!]): [EntityNamespace!]\n  \"Versioning ID\"\n  nodeVersion: ID!\n  \"Properties for this entity, optionally filtered by name\"\n  properties(name: [String!]): [EntityProperty!]\n  \"provider component of the entityType\"\n  provider: String\n  \"For cloud resources, this property contains the entity region\"\n  region: String\n  \"service component of the entityType\"\n  service: String\n  \"Key/Value entityTags for this entity, optionally filtered by key\"\n  tags(key: [String!]): [Tag!]\n}\ntype EntityProperty {\n  boolSetV: [Boolean]\n  boolV: Boolean\n  doubleSetV: [Float]\n  doubleV: Float\n  intSetV: [Int]\n  intV: Int\n  jsonV: JSON\n  longSetV: [Long]\n  longV: Long\n  name: String!\n  strSetV: [String]\n  stringV: String\n  type: EntityPropertyType!\n  \"value is a helper field which contains an Object of the appropriate type\"\n  value: Object\n}\ntype EntityQuery {\n  \"Query the Entity model schema\"\n  entitySchema: EntitySchemaQuery!\n  \"\"\"\n  Query entity topology\n  ### API Permissions:\n  - `entity:*:read`\n  \"\"\"\n  entityTopologyQuery: EntityTopologyQuery\n  \"\"\"\n  Perform Tanzu Hub queries\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `platform:HubQuery:read`\n  \"\"\"\n  hubQuery: HubQuery!\n  \"\"\"\n  Query a filtered set of entities for aggregated counts of values of specified fields.\n  \n  This can be used, for example, to fetch counts of AWS services and their types\n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  ### API Permissions:\n  - `entity:*:read`\n  \"\"\"\n  queryAggregations(\n    \"Specify aggregation buckets\"\n    aggregations: [EntityAggregationInput!]!,\n    \"Specify query filter\"\n    entityQueryFilter: EntityQueryFilter,\n    \"Specify a search filter\"\n    searchInfo: EntitySearchInfo\n  ): EntityAggregations!\n  \"\"\"\n  Query paged list of Entities, optionally filtering by fields and traversals. Supports bidirectional paging.\n  \n  Query performance may be affected when querying across cloud account partitions.\n  \n  Each customer has multiple graph partitions. There is one partition for the management plane entities,\n  one for the VMware managed resources, and one partition per public cloud account. When navigating\n  relationships between partitions, then one must specify a suitable TraversalScope in the traversal.\n  Cross-partition traversals in a graph query have a performance impact on the query but are required\n  when data is in different partitions.\n  \n  By default the partition ID(s) are calculated from:\n  - the provided partitionId parameter if set\n  - determined from the entityIds parameter if set, via the provider instance ID field\n  - determined from the entityTypes if set, in particular if filtering on management tier entities\n  ### API Permissions:\n  - `entity:*:read`\n  \"\"\"\n  queryEntities(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"this is a synonym for a managementEndpointId field of an Entity's management endpoint typically used for public cloud accounts\"\n    cloudAccountId: String @deprecated(reason: \"Please use managementEndpointId filter which also supports filtering by one of multiple values\"),\n    \"Optionally start at the entity/ies that match the other filters provided as input parameter, but immediately traverse to some other entities and return those\"\n    entitiesTraversal: [EntityTraversalInput!],\n    \"Optionally filter by conditions on related entities \"\n    entitiesTraversalFilter: EntityTraversalFilterInput,\n    \"If entitiesTraversal is specified, optionally specify recursion information allowing the traversal to repeat\"\n    entitiesTraversalRecursion: EntityTraversalRecursionInfo,\n    \"Optionally filter by entityIds\"\n    entityId: [EntityId!],\n    \"Optionally filter by this field\"\n    entityName: [String!],\n    \"Optionally filter by this field\"\n    entityType: [String!],\n    \"Optionally filter by entityTypes corresponding to the values from the enum (this can be used for its autocomplete functionality)\"\n    entityTypeConst: [EntityTypeConst!],\n    \"\"\"\n    Optional additional field filters. This can only be used to filter on fields local to this entity\n    and cannot be used to query across traversals to relationships/other entities or to insights, stats etc.\n    \n    The field format is `[[namespaces.<namespace>.](properties.|tags.)]<fieldname>`\n    \"\"\"\n    filter: QueryFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Optionally filter by managementEndpointId\"\n    managementEndpointId: [String!],\n    \"Optionally specify a graph partition name for the graph query's origin if request is for a predefined partition\"\n    partitionId: EntityGraphPartitionNames @deprecated(reason: \"Please use managementEndpointId filter - partitioning is deprecated\"),\n    \"\"\"\n    Query the state of entities at a given point in time.\n    \n    The `pointInTime` parameter is *not* automatically propagated across traversals to other entities or navigations to other types\n    unless otherwise stated. To do a full `pointInTime` query involving other nodes than entities may require specifying the `pointInTime` parameter\n    in multiple places (e.g. when navigating from entities to insights or stats). A query variable may be helpful for this use-case.\n    \n    **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n    \"\"\"\n    pointInTime: DateTime,\n    \"Optionally filter by this field\"\n    provider: [String!],\n    \"Optionally filter by this field\"\n    region: [String!],\n    \"Optional search info - allows global search and/or search by specific fields\"\n    searchInfo: EntitySearchInfo,\n    \"Optionally filter by this field\"\n    service: [String!],\n    \"Sort order for results in EntityConnection\"\n    sort: [QuerySort!],\n    \"Optionally filter by tags. OR is used among values for the same key, AND across different keys\"\n    tags: [TagFilterInput!]\n  ): EntityConnection\n  \"\"\"\n  Query an entity's changelog\n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  ### API Permissions:\n  - `entity:*:read`\n  \"\"\"\n  queryEntityChangeLog(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,entityId: EntityId!, \n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,mostRecentFirst: Boolean = true, \n    \"Filter responses to changes within a given time range\"\n    timeRange: EntityTimeRangeFilter\n  ): EntityChangeLogConnection!\n  \"\"\"\n  Query a filtered set of relationships for aggregated counts of values of specified fields.\n  \n  This can be used, for example, to fetch counts of destination entityTypes for a given source entityId\n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  ### API Permissions:\n  - `entity:*:read`\n  \"\"\"\n  queryRelationshipAggregations(\n    \"Specify aggregation buckets\"\n    aggregations: [EntityAggregationInput!]!,\n    \"Specify query filter\"\n    relationshipQueryFilter: EntityRelationshipQueryFilter\n  ): EntityAggregations!\n  \"\"\"\n  Search API supporting free-text search, filtering sorting and paging.\n  ### API Permissions:\n  - `entity:*:read`\n  \"\"\"\n  searchEntities(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Search parameters\"\n    input: EntitySearchInput!\n  ): EntityConnection @deprecated(reason: \"queryEntities provides search functionality and much more\")\n  \"perform queries on strongly-typed Entities\"\n  typed: EntityTypedQuery\n}\n\"A typed relationship between two Entity instances\"\ntype EntityRelationship implements EntityRelationshipNodeInterface & Node & NodeVersion {\n  \"This property represents an unique ID of the source collector\"\n  collectionSource: String\n  \"Time this Relationship was created. Note: Expressed in UTC ISO-8601 format\"\n  creationTime: DateTime!\n  \"\"\"\n  Dest entity in this relationship. Can be null if the entity with the given entityId is not accessible\n  due to permissions issues or due to a DB update\n  \"\"\"\n  destEntity: Entity\n  \"dest entityId\"\n  destEntityId: EntityId\n  \"dest entity provider if available\"\n  destEntityProvider: String\n  \"dest entity partition key if different to the cloudAccountId in the destEntityId\"\n  destEntityRemotePartitionKey: String\n  \"dest entityType if available\"\n  destEntityType: String\n  \"source entityType projected as an enum value, if available\"\n  destEntityTypeConst: EntityTypeConst\n  \"Opaque global ID\"\n  id: ID!\n  \"Last time this Relationship was updated. Note: Expressed in UTC ISO-8601 format\"\n  lastUpdateTime: DateTime!\n  \"Versioning ID\"\n  nodeVersion: ID!\n  \"\"\"\n  'Other' entity in this relationship\n  \n  This is defined as the entity the 'other' side of the traversal.\n  \n  - for IN traversal direction, it will be the same as the 'sourceEntity'\n  - for OUT traversal direction, it will be the same as the 'destEntity'\n  - for BOTH traversal direction, it will be the 'other' entity, not the one from which the traversal came.\n  \n  The field is not supported for aggregations or filtering.\n  \"\"\"\n  otherEntity: Entity\n  \"other entityId\"\n  otherEntityId: EntityId\n  \"other entityType if available\"\n  otherEntityType: String\n  \"other entityType projected as an enum value, if available\"\n  otherEntityTypeConst: EntityTypeConst\n  properties: [EntityProperty!]\n  \"entity relationship id\"\n  relationshipId: String!\n  \"Type of the relationship. e.g. RelatesTo etc\"\n  relationshipType: String!\n  \"\"\"\n  Source entity in this relationship. Can be null if the entity with the given entityId is not accessible\n  due to permissions issues or due to a DB update\n  \"\"\"\n  sourceEntity: Entity\n  \"source entityId\"\n  sourceEntityId: EntityId\n  \"source entity provider if available\"\n  sourceEntityProvider: String\n  \"source entity partition key if different to the cloudAccountId in the sourceEntityId\"\n  sourceEntityRemotePartitionKey: String\n  \"source entityType if available\"\n  sourceEntityType: String\n  \"source entityType projected as an enum value, if available\"\n  sourceEntityTypeConst: EntityTypeConst\n  \"Scope of relationship's traversal\"\n  traversalScope: EntityTraversalScope\n}\ntype EntityRelationshipConnection implements Connection {\n  \"Count of relationships in this page.\"\n  count: Int!\n  edges: [EntityRelationshipEdge!]\n  entityRelationships: [EntityRelationship!]\n  pageInfo: PageInfo!\n  \"\"\"\n  Total count of matching relationships, if available.\n  NOTE: This is currently only populated under specific conditions:\n  - traversal direction must not be BOTH\n  - entityFilter and traversalFilter must both be null\n  \"\"\"\n  totalCount: Int\n}\ntype EntityRelationshipEdge implements ConnectionEdge {\n  cursor: String!\n  node: EntityRelationship!\n}\n\"\"\"\nA type representing just the EntityRelationship without traversers to the related Entities.\nMay be used for things like delta notifications and subscription responses.\n\"\"\"\ntype EntityRelationshipNode implements EntityRelationshipNodeInterface & Node & NodeVersion {\n  \"This property represents an unique ID of the source collector\"\n  collectionSource: String\n  \"Time this Relationship was created. Note: Expressed in UTC ISO-8601 format\"\n  creationTime: DateTime!\n  \"dest entityId\"\n  destEntityId: EntityId\n  \"dest entity provider if available\"\n  destEntityProvider: String\n  \"dest entity partition key if different to the cloudAccountId in the destEntityId\"\n  destEntityRemotePartitionKey: String\n  \"dest entityType if available\"\n  destEntityType: String\n  \"dest entityType projected as an enum value, if available\"\n  destEntityTypeConst: EntityTypeConst!\n  \"Opaque global ID\"\n  id: ID!\n  \"Last time this Relationship was updated. Note: Expressed in UTC ISO-8601 format\"\n  lastUpdateTime: DateTime!\n  \"Versioning ID\"\n  nodeVersion: ID!\n  properties: [EntityProperty!]\n  \"entity relationship id\"\n  relationshipId: String!\n  \"Type of the relationship. e.g. RelatesTo etc\"\n  relationshipType: String!\n  \"source entityId\"\n  sourceEntityId: EntityId\n  \"source entity provider if available\"\n  sourceEntityProvider: String\n  \"source entity partition key if different to the cloudAccountId in the sourceEntityId\"\n  sourceEntityRemotePartitionKey: String\n  \"source entityType if available\"\n  sourceEntityType: String\n  \"source entityType projected as an enum value, if available\"\n  sourceEntityTypeConst: EntityTypeConst!\n  \"Scope of relationship's traversal\"\n  traversalScope: EntityTraversalScope\n}\n\"Describes an entity schema\"\ntype EntitySchema implements Node {\n  \"Category of the entity. e.g. `Containers`, `Databases`, `Networking` etc.\"\n  category: String!\n  \"ChangeEvents for this schema\"\n  changeEvents: [EntitySchemaChangeEvent!]\n  \"EntityType of the entity. e.g. `AWS.EC2.Instance`, `AWS.ACM.Certificate`, `VMW.VC.VM` etc.\"\n  entityType: String!\n  \"Opaque globally unique ID as per relay spec\"\n  id: ID!\n  \"Namespaces for this schema\"\n  namespaces: [EntitySchemaNamespace!]\n  \"Properties for this schema\"\n  properties: [EntitySchemaProperty!]\n  \"Cloud provider\"\n  provider: String!\n  \"Relationships for this schema\"\n  relationships: [EntitySchemaRelationship!]\n  \"Cloud service resource type\"\n  resourceType: String!\n  \"Cloud provider service\"\n  service: String!\n}\ntype EntitySchemaChangeEvent {\n  name: String!\n  source: String!\n  type: String!\n}\ntype EntitySchemaConnection implements Connection {\n  \"Count of entity schema in this page.\"\n  count: Int!\n  edges: [EntitySchemaEdge!]\n  \"List of entity schema in this page\"\n  entitiesSchema: [EntitySchema!]\n  pageInfo: PageInfo!\n  \" total count of matching entity schema\"\n  totalCount: Int\n}\ntype EntitySchemaEdge implements ConnectionEdge {\n  cursor: String!\n  node: EntitySchema!\n}\ntype EntitySchemaNamespace {\n  changeEvents: [EntitySchemaChangeEvent!]\n  name: String!\n  properties: [EntitySchemaProperty!]\n  provider: String!\n  relationships: [EntitySchemaRelationship!]\n  service: String!\n  type: String!\n}\ntype EntitySchemaProperty {\n  dataType: EntityPropertyType!\n  description: LocalizedString\n  isVisibleByDefaultOnUI: Boolean\n  name: String!\n}\n\"Entity schema queries\"\ntype EntitySchemaQuery {\n  querySchema(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Optionally filter by this field\"\n    entityType: [String!],\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Optionally filter by this field\"\n    provider: [String!],\n    \"Optionally filter by this field\"\n    resourceType: [String!],\n    \"Optionally filter by this field\"\n    service: [String!]\n  ): EntitySchemaConnection\n  \"\"\"\n  Provide summary information for schema at 'next level down' in data model.\n  \n  Invoke with no arguments to fetch available providers.\n  Invoke with a provider to fetch available services in the provider.\n  Invoke with a provider and a service to fetch available resourceTypes in the service.\n  \"\"\"\n  querySchemaSummary(provider: String, service: String): EntitySchemaSummaries!\n}\ntype EntitySchemaRelationship {\n  destEntitySchema: EntitySchema!\n  relationshipType: String!\n  sourceEntitySchema: EntitySchema!\n}\ntype EntitySchemaSummaries {\n  values: [EntitySchemaSummary!]\n}\ntype EntitySchemaSummary {\n  fieldName: String!\n  values: [EntitySchemaSummaryItem!]\n}\ntype EntitySchemaSummaryItem {\n  count: Int!\n  value: String!\n}\n\"EntityScopes provide information on the membership and visibility of the Entity.\"\ntype EntityScopes {\n  \"The scope id strings which may or not all be EntityIds\"\n  scopeIds: [String!]\n  \"Fetch the scoping entities\"\n  scopingEntities(\n    \"Filter scopes by given entityType\"\n    entityType: [String!],\n    \"Filter scopes by the entityType corresponding to the enum values\"\n    entityTypeConst: [EntityTypeConst!]\n  ): [Entity!]\n}\ntype EntityTopologyGraph {\n  \"The list of edges that belongs to this graph. This does not support pagination yet.\"\n  edges: [EntityTopologyGraphEdge!]\n  \"The list of nodes that belongs to this graph. This does not support pagination yet.\"\n  nodes: [EntityTopologyGraphNode!]\n}\ntype EntityTopologyGraphEdge {\n  \"The ID of the destination node in the topology\"\n  destinationNodeId: String!\n  \"An optional type specifying the kind of edge between these nodes\"\n  edgeType: String\n  \"The ID of the source node in the topology\"\n  sourceNodeId: String!\n}\ntype EntityTopologyGraphNode {\n  \"The list of entities belonging to this node.\"\n  entities: [Entity!]\n  \"A ID for the current node. These IDs will be unique for a given topology, but is not guaranteed to be unique across different topologies.\"\n  id: String!\n  \"The layer to which this node should belong. This field will not be populated if the graphQLQueries field is used in the input\"\n  layer: String\n  \"\"\"\n  The type of this node. For single entity nodes, it will most probably be the same as the entity type itself. It can be different from the\n  entity type if a single entity type represents different user facing objects. For example, entity of type Tanzu.TAS.BoshVM can either be\n  a Diego Cell or a GoRouter depending upon which VM you are looking at.\n  \"\"\"\n  nodeType: String!\n  \"Total count of matching entities if available.\"\n  totalCount: Int\n  \"This field is to be used when the returned data types for this node are not entities (eg aggregations etc.). This will be unused in most cases.\"\n  values: [String!]\n}\ntype EntityTopologyPerspective {\n  \"\"\"\n  The identifier of the perspective. Examples of this include platform, infrastructure, fullstack etc. For a given\n  entity type, this field should be unique.\n  \"\"\"\n  identifier: String!\n  \"\"\"\n  A list of layers that are supported for a given perspective. For example, A fullstack perspective\n  might support layers like Application, Infrastructure, Runtime etc.\n  \"\"\"\n  layers: [String!]!\n}\ntype EntityTopologyPerspectives {\n  \"\"\"\n  The type of the entity that this provider can support. If a single provider wants to support\n  multiple entity types, they can do so by providing a list of these perspective objects in the\n  provider info field in the EntityTopologyProvider.\n  \"\"\"\n  entityType: String!\n  \"A list of perspectives that this provider supports for the entity type specified above.\"\n  perspectives: [EntityTopologyPerspective!]!\n}\n\"This is the default implementation of the EntityTopologyProviderInterface\"\ntype EntityTopologyProvider implements EntityTopologyProviderInterface {\n  \"Information about this provider\"\n  providerInfo: [EntityTopologyPerspectives!]\n  \"Entity topology query interface that must be implemented by a provider\"\n  queryEntityTopology(\n    \"\"\"\n    An optional field which specifies the topology that has been computed so far.\n    This field can be used in order to make subsequent calls to the API faster,\n    so that the providers don't have to re-compute all the information from scratch.\n    \"\"\"\n    currentTopology: EntityTopologyGraphInput,\n    \"Query parameters\"\n    entityTopologyInput: EntityTopologyInput!\n  ): EntityTopologyGraph\n}\n\" Types starting with Entity are defined in commons-entity\"\ntype EntityTopologyProviders {\n  \"\"\"\n  Business Application topology provider\n  ### API Permissions:\n  - `entity:*:read`\n  \"\"\"\n  businessApp: EntityTopologyProvider!\n  \"\"\"\n  Business Application topology provider\n  ### API Permissions:\n  - `entity:*:read`\n  \"\"\"\n  foundation: EntityTopologyProvider!\n}\ntype EntityTopologyQuery {\n  entityTopologyProviders: EntityTopologyProviders!\n  \"\"\"\n  \n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  ### API Permissions:\n  - `entity:*:read`\n  \"\"\"\n  queryEntityTopology(currentTopology: EntityTopologyGraphInput, entityTopologyInput: EntityTopologyInput!): EntityTopologyGraph\n  \"Query available topology perspectives by entityType. If no entityType is provided, only types with specific perspectives will be returned\"\n  queryEntityTopologyPerspectives(\n    \"Filter by entityType\"\n    entityType: String\n  ): [EntityTopologyPerspectives!]\n}\n\"\"\"\nContains entityType-specific fields.\n\nNote that all fields added to EntityTraits are expected to have the @trait directive\nindicating to which entityTypes the trait applies. This is to allow\nus later to automatically attach these traits to specific Entity types in a strongly-typed\nentity model.\n\"\"\"\ntype EntityTraits {\n  \" Represents the license installed (or being installed) to the the foundation \"\n  license: LicenseOnFoundation\n  managementEndpointManagedAccount: ManagementEndpoint\n  \"\"\"\n  Traits regarding applications and business applications that will be contributed to the entity by the\n  app manager service\n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  \"\"\"\n  businessApp: BusinessAppTraits\n  \"\"\"\n  \n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  \"\"\"\n  assessmentPortfolio: AssessmentPortfolioTraits\n  \"\"\"\n  Component artifact types that will be contributed by TVS for Tanzu products\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  \"\"\"\n  component: ComponentTraits\n  \"\"\"\n  Hub artifact types that will contribute packages and vulnerabilities for an Entity\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  \"\"\"\n  hubArtifact: HubArtifactTraits\n  \"\"\"\n  Spring Artifact types that will be contributed by application metadata service to an Entity\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  \"\"\"\n  springArtifact: SpringArtifactTraits\n}\n\"Tree node used in a hub query response \"\ntype EntityTreeNode {\n  childIds: [String!]\n  \"id is either an EntityId (for an ENTITY node) or a relationship id (for a RELATIONSHIP node)\"\n  id: String!\n  type: EntityTreeNodeType!\n}\n\"Strongly-typed GraphQL queries for entities\"\ntype EntityTypedQuery {\n  tanzu: Entity_Tanzu_Type\n}\ntype Entity_Tanzu_Platform_FoundationGroupConnection implements Connection {\n  count: Int!\n  edges: [Entity_Tanzu_Platform_FoundationGroupConnectionEdge!]\n  entities: [Entity_Tanzu_Platform_FoundationGroup_Type!]\n  pageInfo: PageInfo!\n  remainingCount: Int\n  totalCount: Int\n}\ntype Entity_Tanzu_Platform_FoundationGroupConnectionEdge implements ConnectionEdge {\n  cursor: String\n  node: Entity_Tanzu_Platform_FoundationGroup_Type!\n}\ntype Entity_Tanzu_Platform_FoundationGroup_IsAssociatedWith_RelIn {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.Platform.OrganizationGroup:read`\n  \"\"\"\n  tanzu_platform_organizationgroup(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_Platform_OrganizationGroupConnection\n}\ntype Entity_Tanzu_Platform_FoundationGroup_IsContainedIn_RelIn {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Foundation:read`\n  \"\"\"\n  tanzu_tas_foundation(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_FoundationConnection\n}\ntype Entity_Tanzu_Platform_FoundationGroup_Properties {\n  \"The description of the FoundationGroup\"\n  description: String\n}\ntype Entity_Tanzu_Platform_FoundationGroup_Query {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.Platform.FoundationGroup:read`\n  \"\"\"\n  query(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_Platform_FoundationGroupConnection\n}\ntype Entity_Tanzu_Platform_FoundationGroup_RelIn {\n  isAssociatedWith: Entity_Tanzu_Platform_FoundationGroup_IsAssociatedWith_RelIn\n  isContainedIn: Entity_Tanzu_Platform_FoundationGroup_IsContainedIn_RelIn\n}\ntype Entity_Tanzu_Platform_FoundationGroup_Type implements EntityTypedInterface & Node & NodeVersion {\n  \"a link to the generic Entity node\"\n  entity: Entity!\n  \"Unique identifier for an entity in a canonical form. Uniqueness is global.\"\n  entityId: EntityId!\n  \"human-readable name of the entity. May be mutable and non-unique.\"\n  entityName: String\n  \"EntityType of the entity. e.g. `ec2`, `security-group` etc. Required but not enforced\"\n  entityType: String\n  \"Opaque global ID\"\n  id: ID!\n  \"Versioning ID\"\n  nodeVersion: ID!\n  properties: Entity_Tanzu_Platform_FoundationGroup_Properties\n  relationshipsIn: Entity_Tanzu_Platform_FoundationGroup_RelIn\n  \"Key/Value tags for this entity, optionally filtered by key\"\n  tags(\n    \"Filter tags by key\"\n    key: [String!]\n  ): [Tag!]\n}\ntype Entity_Tanzu_Platform_OrganizationGroupConnection implements Connection {\n  count: Int!\n  edges: [Entity_Tanzu_Platform_OrganizationGroupConnectionEdge!]\n  entities: [Entity_Tanzu_Platform_OrganizationGroup_Type!]\n  pageInfo: PageInfo!\n  remainingCount: Int\n  totalCount: Int\n}\ntype Entity_Tanzu_Platform_OrganizationGroupConnectionEdge implements ConnectionEdge {\n  cursor: String\n  node: Entity_Tanzu_Platform_OrganizationGroup_Type!\n}\ntype Entity_Tanzu_Platform_OrganizationGroup_IsAssociatedWith_RelOut {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.Platform.FoundationGroup:read`\n  \"\"\"\n  tanzu_platform_foundationgroup(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_Platform_FoundationGroupConnection\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Foundation:read`\n  \"\"\"\n  tanzu_tas_foundation(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_FoundationConnection\n}\ntype Entity_Tanzu_Platform_OrganizationGroup_IsContainedIn_RelIn {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.Platform.SpaceGroup:read`\n  \"\"\"\n  tanzu_platform_spacegroup(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_Platform_SpaceGroupConnection\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Organization:read`\n  \"\"\"\n  tanzu_tas_organization(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_OrganizationConnection\n}\ntype Entity_Tanzu_Platform_OrganizationGroup_Properties {\n  \"The description of the OrganizationGroup\"\n  description: String\n  \"The Status of the OrganizationGroup\"\n  status: String\n}\ntype Entity_Tanzu_Platform_OrganizationGroup_Query {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.Platform.OrganizationGroup:read`\n  \"\"\"\n  query(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_Platform_OrganizationGroupConnection\n}\ntype Entity_Tanzu_Platform_OrganizationGroup_RelIn {\n  isContainedIn: Entity_Tanzu_Platform_OrganizationGroup_IsContainedIn_RelIn\n}\ntype Entity_Tanzu_Platform_OrganizationGroup_RelOut {\n  isAssociatedWith: Entity_Tanzu_Platform_OrganizationGroup_IsAssociatedWith_RelOut\n}\ntype Entity_Tanzu_Platform_OrganizationGroup_Type implements EntityTypedInterface & Node & NodeVersion {\n  \"a link to the generic Entity node\"\n  entity: Entity!\n  \"Unique identifier for an entity in a canonical form. Uniqueness is global.\"\n  entityId: EntityId!\n  \"human-readable name of the entity. May be mutable and non-unique.\"\n  entityName: String\n  \"EntityType of the entity. e.g. `ec2`, `security-group` etc. Required but not enforced\"\n  entityType: String\n  \"Opaque global ID\"\n  id: ID!\n  \"Versioning ID\"\n  nodeVersion: ID!\n  properties: Entity_Tanzu_Platform_OrganizationGroup_Properties\n  relationshipsIn: Entity_Tanzu_Platform_OrganizationGroup_RelIn\n  relationshipsOut: Entity_Tanzu_Platform_OrganizationGroup_RelOut\n  \"Key/Value tags for this entity, optionally filtered by key\"\n  tags(\n    \"Filter tags by key\"\n    key: [String!]\n  ): [Tag!]\n}\ntype Entity_Tanzu_Platform_SpaceGroupConnection implements Connection {\n  count: Int!\n  edges: [Entity_Tanzu_Platform_SpaceGroupConnectionEdge!]\n  entities: [Entity_Tanzu_Platform_SpaceGroup_Type!]\n  pageInfo: PageInfo!\n  remainingCount: Int\n  totalCount: Int\n}\ntype Entity_Tanzu_Platform_SpaceGroupConnectionEdge implements ConnectionEdge {\n  cursor: String\n  node: Entity_Tanzu_Platform_SpaceGroup_Type!\n}\ntype Entity_Tanzu_Platform_SpaceGroup_IsAssociatedWith_RelOut {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Foundation:read`\n  \"\"\"\n  tanzu_tas_foundation(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_FoundationConnection\n}\ntype Entity_Tanzu_Platform_SpaceGroup_IsContainedIn_RelIn {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Space:read`\n  \"\"\"\n  tanzu_tas_space(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_SpaceConnection\n}\ntype Entity_Tanzu_Platform_SpaceGroup_IsContainedIn_RelOut {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.Platform.OrganizationGroup:read`\n  \"\"\"\n  tanzu_platform_organizationgroup(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_Platform_OrganizationGroupConnection\n}\ntype Entity_Tanzu_Platform_SpaceGroup_Properties {\n  \"The description of the SpaceGroup\"\n  description: String\n  \"The Status of the SpaceGroup\"\n  status: String\n}\ntype Entity_Tanzu_Platform_SpaceGroup_Query {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.Platform.SpaceGroup:read`\n  \"\"\"\n  query(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_Platform_SpaceGroupConnection\n}\ntype Entity_Tanzu_Platform_SpaceGroup_RelIn {\n  isContainedIn: Entity_Tanzu_Platform_SpaceGroup_IsContainedIn_RelIn\n}\ntype Entity_Tanzu_Platform_SpaceGroup_RelOut {\n  isAssociatedWith: Entity_Tanzu_Platform_SpaceGroup_IsAssociatedWith_RelOut\n  isContainedIn: Entity_Tanzu_Platform_SpaceGroup_IsContainedIn_RelOut\n}\ntype Entity_Tanzu_Platform_SpaceGroup_Type implements EntityTypedInterface & Node & NodeVersion {\n  \"a link to the generic Entity node\"\n  entity: Entity!\n  \"Unique identifier for an entity in a canonical form. Uniqueness is global.\"\n  entityId: EntityId!\n  \"human-readable name of the entity. May be mutable and non-unique.\"\n  entityName: String\n  \"EntityType of the entity. e.g. `ec2`, `security-group` etc. Required but not enforced\"\n  entityType: String\n  \"Opaque global ID\"\n  id: ID!\n  \"Versioning ID\"\n  nodeVersion: ID!\n  properties: Entity_Tanzu_Platform_SpaceGroup_Properties\n  relationshipsIn: Entity_Tanzu_Platform_SpaceGroup_RelIn\n  relationshipsOut: Entity_Tanzu_Platform_SpaceGroup_RelOut\n  \"Key/Value tags for this entity, optionally filtered by key\"\n  tags(\n    \"Filter tags by key\"\n    key: [String!]\n  ): [Tag!]\n}\ntype Entity_Tanzu_Platform_Type {\n  foundationgroup: Entity_Tanzu_Platform_FoundationGroup_Query\n  organizationgroup: Entity_Tanzu_Platform_OrganizationGroup_Query\n  spacegroup: Entity_Tanzu_Platform_SpaceGroup_Query\n}\ntype Entity_Tanzu_Spring_AppReplicaConnection implements Connection {\n  count: Int!\n  edges: [Entity_Tanzu_Spring_AppReplicaConnectionEdge!]\n  entities: [Entity_Tanzu_Spring_AppReplica_Type!]\n  pageInfo: PageInfo!\n  remainingCount: Int\n  totalCount: Int\n}\ntype Entity_Tanzu_Spring_AppReplicaConnectionEdge implements ConnectionEdge {\n  cursor: String\n  node: Entity_Tanzu_Spring_AppReplica_Type!\n}\ntype Entity_Tanzu_Spring_AppReplica_Properties {\n  env_systemProperties_os_arch: [String]\n  env_systemProperties_os_name: [String]\n  env_systemProperties_os_version: [String]\n  info_app_version: [String]\n  info_git_branch: [String]\n  info_git_build_host: [String]\n  info_git_build_time: [String]\n  info_git_build_user_email: [String]\n  info_git_build_user_name: [String]\n  info_git_build_version: [String]\n  info_git_commit_committer_time: [String]\n  info_git_commit_id: [String]\n  info_git_commit_message: [String]\n  info_git_commit_time: [String]\n  info_git_commit_user_email: [String]\n  info_git_commit_user_name: [String]\n  info_git_dirty: [Boolean]\n  info_git_remote_origin_url: [String]\n  info_git_total_commit_count: [String]\n  info_java_vendor_name: [String]\n  info_java_version: [String]\n  info_spring_boot_version: [String]\n  platform: String\n  \"the GUID of the TAS application\"\n  platformGUID: String\n  \"the Uid of the UCP Container App\"\n  ucpContainerAppUid: String\n  \"the Id of the UCP project\"\n  ucpProjectId: String\n}\ntype Entity_Tanzu_Spring_AppReplica_Query {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.Spring.AppReplica:read`\n  \"\"\"\n  query(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_Spring_AppReplicaConnection\n}\ntype Entity_Tanzu_Spring_AppReplica_Type implements EntityTypedInterface & Node & NodeVersion {\n  \"a link to the generic Entity node\"\n  entity: Entity!\n  \"Unique identifier for an entity in a canonical form. Uniqueness is global.\"\n  entityId: EntityId!\n  \"human-readable name of the entity. May be mutable and non-unique.\"\n  entityName: String\n  \"EntityType of the entity. e.g. `ec2`, `security-group` etc. Required but not enforced\"\n  entityType: String\n  \"Opaque global ID\"\n  id: ID!\n  \"Versioning ID\"\n  nodeVersion: ID!\n  properties: Entity_Tanzu_Spring_AppReplica_Properties\n  \"Key/Value tags for this entity, optionally filtered by key\"\n  tags(\n    \"Filter tags by key\"\n    key: [String!]\n  ): [Tag!]\n}\ntype Entity_Tanzu_Spring_ApplicationConnection implements Connection {\n  count: Int!\n  edges: [Entity_Tanzu_Spring_ApplicationConnectionEdge!]\n  entities: [Entity_Tanzu_Spring_Application_Type!]\n  pageInfo: PageInfo!\n  remainingCount: Int\n  totalCount: Int\n}\ntype Entity_Tanzu_Spring_ApplicationConnectionEdge implements ConnectionEdge {\n  cursor: String\n  node: Entity_Tanzu_Spring_Application_Type!\n}\ntype Entity_Tanzu_Spring_Application_Contains_RelIn {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Application:read`\n  \"\"\"\n  tanzu_tas_application(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_ApplicationConnection\n}\ntype Entity_Tanzu_Spring_Application_IsContainedIn_RelIn {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.Spring.Instance:read`\n  \"\"\"\n  tanzu_spring_instance(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_Spring_InstanceConnection\n}\ntype Entity_Tanzu_Spring_Application_Properties {\n  env_systemProperties_os_arch: [String]\n  env_systemProperties_os_name: [String]\n  env_systemProperties_os_version: [String]\n  info_app_version: [String]\n  info_git_branch: [String]\n  info_git_build_host: [String]\n  info_git_build_time: [String]\n  info_git_build_user_email: [String]\n  info_git_build_user_name: [String]\n  info_git_build_version: [String]\n  info_git_commit_committer_time: [String]\n  info_git_commit_id: [String]\n  info_git_commit_message: [String]\n  info_git_commit_time: [String]\n  info_git_commit_user_email: [String]\n  info_git_commit_user_name: [String]\n  info_git_dirty: [Boolean]\n  info_git_remote_origin_url: [String]\n  info_git_total_commit_count: [String]\n  info_java_vendor_name: [String]\n  info_java_version: [String]\n  info_spring_boot_version: [String]\n  platform: String\n  \"the GUID of the TAS application\"\n  platformGUID: String\n  \"describes Spring Optimization parameters used for this spring application (Fully Enabled, AOT Enabled, CDS Enabled, Not Enabled, or Unsupported)\"\n  springOptimization: String\n}\ntype Entity_Tanzu_Spring_Application_Query {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.Spring.Application:read`\n  \"\"\"\n  query(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_Spring_ApplicationConnection\n}\ntype Entity_Tanzu_Spring_Application_RelIn {\n  contains: Entity_Tanzu_Spring_Application_Contains_RelIn\n  isContainedIn: Entity_Tanzu_Spring_Application_IsContainedIn_RelIn\n}\ntype Entity_Tanzu_Spring_Application_Type implements EntityTypedInterface & Node & NodeVersion {\n  \"a link to the generic Entity node\"\n  entity: Entity!\n  \"Unique identifier for an entity in a canonical form. Uniqueness is global.\"\n  entityId: EntityId!\n  \"human-readable name of the entity. May be mutable and non-unique.\"\n  entityName: String\n  \"EntityType of the entity. e.g. `ec2`, `security-group` etc. Required but not enforced\"\n  entityType: String\n  \"Opaque global ID\"\n  id: ID!\n  \"Versioning ID\"\n  nodeVersion: ID!\n  properties: Entity_Tanzu_Spring_Application_Properties\n  relationshipsIn: Entity_Tanzu_Spring_Application_RelIn\n  \"Key/Value tags for this entity, optionally filtered by key\"\n  tags(\n    \"Filter tags by key\"\n    key: [String!]\n  ): [Tag!]\n}\ntype Entity_Tanzu_Spring_CloudGatewayConnection implements Connection {\n  count: Int!\n  edges: [Entity_Tanzu_Spring_CloudGatewayConnectionEdge!]\n  entities: [Entity_Tanzu_Spring_CloudGateway_Type!]\n  pageInfo: PageInfo!\n  remainingCount: Int\n  totalCount: Int\n}\ntype Entity_Tanzu_Spring_CloudGatewayConnectionEdge implements ConnectionEdge {\n  cursor: String\n  node: Entity_Tanzu_Spring_CloudGateway_Type!\n}\ntype Entity_Tanzu_Spring_CloudGateway_IsAssociatedWith_RelOut {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Application:read`\n  \"\"\"\n  tanzu_tas_application: Entity_Tanzu_TAS_Application_Type\n}\ntype Entity_Tanzu_Spring_CloudGateway_Properties {\n  \"the base URL of the Spring Cloud Gateway\"\n  baseURL: String\n  \"whether or not the Spring Cloud Gateway is the commercial version\"\n  commercial: Boolean\n  \"the description of the Spring Cloud Gateway\"\n  description: String\n  \"the documentation URL of the Spring Cloud Gateway\"\n  documentationURL: String\n  \"the number Spring Cloud Gateway app instances\"\n  haCount: Int\n  \"the configured memory for Spring Cloud Gateway app instances\"\n  memory: String\n  platform: String\n  \"the GUID of the TAS ServiceInstance\"\n  platformGUID: String\n  \"the version of the Spring Cloud Gateway\"\n  version: String\n}\ntype Entity_Tanzu_Spring_CloudGateway_Query {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.Spring.CloudGateway:read`\n  \"\"\"\n  query(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_Spring_CloudGatewayConnection\n}\ntype Entity_Tanzu_Spring_CloudGateway_RelOut {\n  isAssociatedWith: Entity_Tanzu_Spring_CloudGateway_IsAssociatedWith_RelOut\n}\ntype Entity_Tanzu_Spring_CloudGateway_Type implements EntityTypedInterface & Node & NodeVersion {\n  \"a link to the generic Entity node\"\n  entity: Entity!\n  \"Unique identifier for an entity in a canonical form. Uniqueness is global.\"\n  entityId: EntityId!\n  \"human-readable name of the entity. May be mutable and non-unique.\"\n  entityName: String\n  \"EntityType of the entity. e.g. `ec2`, `security-group` etc. Required but not enforced\"\n  entityType: String\n  \"Opaque global ID\"\n  id: ID!\n  \"Versioning ID\"\n  nodeVersion: ID!\n  properties: Entity_Tanzu_Spring_CloudGateway_Properties\n  relationshipsOut: Entity_Tanzu_Spring_CloudGateway_RelOut\n  \"Key/Value tags for this entity, optionally filtered by key\"\n  tags(\n    \"Filter tags by key\"\n    key: [String!]\n  ): [Tag!]\n}\ntype Entity_Tanzu_Spring_InstanceConnection implements Connection {\n  count: Int!\n  edges: [Entity_Tanzu_Spring_InstanceConnectionEdge!]\n  entities: [Entity_Tanzu_Spring_Instance_Type!]\n  pageInfo: PageInfo!\n  remainingCount: Int\n  totalCount: Int\n}\ntype Entity_Tanzu_Spring_InstanceConnectionEdge implements ConnectionEdge {\n  cursor: String\n  node: Entity_Tanzu_Spring_Instance_Type!\n}\ntype Entity_Tanzu_Spring_Instance_Contains_RelIn {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.ProcessInstance:read`\n  \"\"\"\n  tanzu_tas_processinstance(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_ProcessInstanceConnection\n}\ntype Entity_Tanzu_Spring_Instance_IsContainedIn_RelOut {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.Spring.Application:read`\n  \"\"\"\n  tanzu_spring_application: Entity_Tanzu_Spring_Application_Type\n}\ntype Entity_Tanzu_Spring_Instance_Properties {\n  \"Logging level for springframework\"\n  env_applicationProperties_logging_level_org_springframework: String\n  \"Logging level for springframework web\"\n  env_applicationProperties_logging_level_org_springframework_web: String\n  \"Management Endpoint shutdown Enabled\"\n  env_applicationProperties_management_endpoint_shutdown_enabled: String\n  \"Management Endpoint Web Exposure Included\"\n  env_applicationProperties_management_endpoints_web_exposure_include: String\n  \"Management Security Enabled\"\n  env_applicationProperties_management_security_enabled: String\n  \"Server Compression Enabled\"\n  env_applicationProperties_server_compression_enabled: String\n  \"Server Compression Mime Types\"\n  env_applicationProperties_server_compression_mime_types: String\n  \"Server Compression Min ResponseSize\"\n  env_applicationProperties_server_compression_min_response_size: String\n  \"Spring Application Name\"\n  env_applicationProperties_spring_application_name: String\n  \"Spring Cloud Config Enabled\"\n  env_applicationProperties_spring_cloud_config_enabled: String\n  \"Spring Jpa Show Sql\"\n  env_applicationProperties_spring_jpa_show_sql: String\n  \"Os Arch\"\n  env_systemProperties_os_arch: String\n  \"Os Name\"\n  env_systemProperties_os_name: String\n  \"Os Version\"\n  env_systemProperties_os_version: String\n  \"User Country\"\n  env_systemProperties_user_country: String\n  \"User Home\"\n  env_systemProperties_user_home: String\n  \"User Name\"\n  env_systemProperties_user_name: String\n  \"Whether the instance is healthy\"\n  health_status: String\n  \"Business App Name\"\n  info_app_business_app_name: String\n  \"Application Description\"\n  info_app_description: String\n  \"Application Java Version\"\n  info_app_java_version: String\n  \"Application name\"\n  info_app_name: String\n  \"Application Version\"\n  info_app_version: String\n  \"Git Branch\"\n  info_git_branch: String\n  \"Git Build Host\"\n  info_git_build_host: String\n  \"Git build time\"\n  info_git_build_time: Object\n  \"Git build user email\"\n  info_git_build_user_email: String\n  \"Git build user name\"\n  info_git_build_user_name: String\n  \"Git Build Version\"\n  info_git_build_version: String\n  \"Git commit committer time\"\n  info_git_commit_committer_time: Object\n  \"Git commit id\"\n  info_git_commit_id: String\n  \"Git commit message\"\n  info_git_commit_message: String\n  \"Git commit time\"\n  info_git_commit_time: Object\n  \"Git commit user email\"\n  info_git_commit_user_email: String\n  \"Git commit user name\"\n  info_git_commit_user_name: String\n  \"Git dirty\"\n  info_git_dirty: Boolean\n  \"Git remote origin\"\n  info_git_remote_origin_url: String\n  \"Git commit total count\"\n  info_git_total_commit_count: String\n  \"Java vendor version\"\n  info_java_java_vendor_version: String\n  \"JVM Name\"\n  info_java_jvm_name: String\n  \"JVM Vendor\"\n  info_java_jvm_vendor: String\n  \"JVM Version\"\n  info_java_jvm_version: String\n  \"Java Runtime Name\"\n  info_java_runtime_name: String\n  \"Java Runtime Version\"\n  info_java_runtime_version: String\n  \"Java vendor\"\n  info_java_vendor_name: String\n  \"java version\"\n  info_java_version: String\n  \"Spring Boot Version\"\n  info_spring_boot_version: String\n  \"TAS\"\n  platform: String\n  \"the GUID of the TAS ProcessInstance\"\n  platformGUID: String\n  \"whether the instance has an associated SBOM\"\n  sbomPresent: Boolean\n}\ntype Entity_Tanzu_Spring_Instance_Query {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.Spring.Instance:read`\n  \"\"\"\n  query(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_Spring_InstanceConnection\n}\ntype Entity_Tanzu_Spring_Instance_RelIn {\n  contains: Entity_Tanzu_Spring_Instance_Contains_RelIn\n}\ntype Entity_Tanzu_Spring_Instance_RelOut {\n  isContainedIn: Entity_Tanzu_Spring_Instance_IsContainedIn_RelOut\n}\ntype Entity_Tanzu_Spring_Instance_Type implements EntityTypedInterface & Node & NodeVersion {\n  \"a link to the generic Entity node\"\n  entity: Entity!\n  \"Unique identifier for an entity in a canonical form. Uniqueness is global.\"\n  entityId: EntityId!\n  \"human-readable name of the entity. May be mutable and non-unique.\"\n  entityName: String\n  \"EntityType of the entity. e.g. `ec2`, `security-group` etc. Required but not enforced\"\n  entityType: String\n  \"Opaque global ID\"\n  id: ID!\n  \"Versioning ID\"\n  nodeVersion: ID!\n  properties: Entity_Tanzu_Spring_Instance_Properties\n  relationshipsIn: Entity_Tanzu_Spring_Instance_RelIn\n  relationshipsOut: Entity_Tanzu_Spring_Instance_RelOut\n  \"Key/Value tags for this entity, optionally filtered by key\"\n  tags(\n    \"Filter tags by key\"\n    key: [String!]\n  ): [Tag!]\n}\ntype Entity_Tanzu_Spring_Type {\n  application: Entity_Tanzu_Spring_Application_Query\n  appreplica: Entity_Tanzu_Spring_AppReplica_Query\n  cloudgateway: Entity_Tanzu_Spring_CloudGateway_Query\n  instance: Entity_Tanzu_Spring_Instance_Query\n}\ntype Entity_Tanzu_TAS_ApplicationConnection implements Connection {\n  count: Int!\n  edges: [Entity_Tanzu_TAS_ApplicationConnectionEdge!]\n  entities: [Entity_Tanzu_TAS_Application_Type!]\n  pageInfo: PageInfo!\n  remainingCount: Int\n  totalCount: Int\n}\ntype Entity_Tanzu_TAS_ApplicationConnectionEdge implements ConnectionEdge {\n  cursor: String\n  node: Entity_Tanzu_TAS_Application_Type!\n}\ntype Entity_Tanzu_TAS_Application_Contains_RelOut {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.Spring.Application:read`\n  \"\"\"\n  tanzu_spring_application: Entity_Tanzu_Spring_Application_Type\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Droplet:read`\n  \"\"\"\n  tanzu_tas_droplet: Entity_Tanzu_TAS_Droplet_Type\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Revision:read`\n  \"\"\"\n  tanzu_tas_revision: Entity_Tanzu_TAS_Revision_Type\n}\ntype Entity_Tanzu_TAS_Application_IsAssociatedWith_RelIn {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.Spring.CloudGateway:read`\n  \"\"\"\n  tanzu_spring_cloudgateway(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_Spring_CloudGatewayConnection\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Application:read`\n  \"\"\"\n  tanzu_tas_application(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_ApplicationConnection\n}\ntype Entity_Tanzu_TAS_Application_IsAssociatedWith_RelOut {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Application:read`\n  \"\"\"\n  tanzu_tas_application(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_ApplicationConnection\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Buildpack:read`\n  \"\"\"\n  tanzu_tas_buildpack: Entity_Tanzu_TAS_Buildpack_Type\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.ServiceInstance:read`\n  \"\"\"\n  tanzu_tas_serviceinstance(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_ServiceInstanceConnection\n}\ntype Entity_Tanzu_TAS_Application_IsContainedIn_RelIn {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.ProcessInstance:read`\n  \"\"\"\n  tanzu_tas_processinstance(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_ProcessInstanceConnection\n}\ntype Entity_Tanzu_TAS_Application_IsContainedIn_RelOut {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Space:read`\n  \"\"\"\n  tanzu_tas_space: Entity_Tanzu_TAS_Space_Type\n}\ntype Entity_Tanzu_TAS_Application_Properties {\n  \"The application Buildpack name\"\n  buildpack: String\n  \"The application Buildpack type\"\n  buildpackType: String\n  \"Count of crashed web ProcessInstances\"\n  crashedInstanceCount: Int\n  \"RFC 3339 date and time at which Application was created\"\n  createdAt: Object\n  \"The environment variable names that are associated with the application\"\n  environmentVariables: [String]\n  \"The Foundation on which the application resides\"\n  foundation: String\n  \"The application GUID\"\n  guid: String\n  \"Current health status of the app; valid values are RUNNING (InstanceCount = RunningInstanceCount), DOWN, STOPPED\"\n  health_status: String\n  \"Count of desired web ProcessInstances\"\n  instanceCount: Int\n  \"The application routes\"\n  routes: [String]\n  \"Count of running web ProcessInstances\"\n  runningInstanceCount: Int\n  \"whether the application has an associated SBOM\"\n  sbomPresent: Boolean\n  \"The Space ID\"\n  spaceGUID: String\n  \"Whether or not the application is a spring app\"\n  springApp: Boolean\n  \"The application Stack, the root filesystem to use with the buildpack\"\n  stack: String\n  \"Current desired state of the app; valid values are STOPPED or STARTED\"\n  state: String\n  \"Total Memory Limit in MB of the web ProcessInstances\"\n  totalDiskLimitMB: Int\n  \"Total Memory Limit in MB of the web ProcessInstances\"\n  totalLogRateLimitInBytesPerSecond: Int\n  \"Total Memory Limit in MB of the web ProcessInstances\"\n  totalMemoryLimitMB: Int\n  \"RFC 3339 date and time at which Application was updated\"\n  updatedAt: Object\n}\ntype Entity_Tanzu_TAS_Application_Query {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Application:read`\n  \"\"\"\n  query(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_ApplicationConnection\n}\ntype Entity_Tanzu_TAS_Application_RelIn {\n  isAssociatedWith: Entity_Tanzu_TAS_Application_IsAssociatedWith_RelIn\n  isContainedIn: Entity_Tanzu_TAS_Application_IsContainedIn_RelIn\n}\ntype Entity_Tanzu_TAS_Application_RelOut {\n  contains: Entity_Tanzu_TAS_Application_Contains_RelOut\n  isAssociatedWith: Entity_Tanzu_TAS_Application_IsAssociatedWith_RelOut\n  isContainedIn: Entity_Tanzu_TAS_Application_IsContainedIn_RelOut\n}\ntype Entity_Tanzu_TAS_Application_Type implements EntityTypedInterface & Node & NodeVersion {\n  \"a link to the generic Entity node\"\n  entity: Entity!\n  \"Unique identifier for an entity in a canonical form. Uniqueness is global.\"\n  entityId: EntityId!\n  \"human-readable name of the entity. May be mutable and non-unique.\"\n  entityName: String\n  \"EntityType of the entity. e.g. `ec2`, `security-group` etc. Required but not enforced\"\n  entityType: String\n  \"Opaque global ID\"\n  id: ID!\n  \"Versioning ID\"\n  nodeVersion: ID!\n  properties: Entity_Tanzu_TAS_Application_Properties\n  relationshipsIn: Entity_Tanzu_TAS_Application_RelIn\n  relationshipsOut: Entity_Tanzu_TAS_Application_RelOut\n  \"Key/Value tags for this entity, optionally filtered by key\"\n  tags(\n    \"Filter tags by key\"\n    key: [String!]\n  ): [Tag!]\n}\ntype Entity_Tanzu_TAS_BoshDirectorConnection implements Connection {\n  count: Int!\n  edges: [Entity_Tanzu_TAS_BoshDirectorConnectionEdge!]\n  entities: [Entity_Tanzu_TAS_BoshDirector_Type!]\n  pageInfo: PageInfo!\n  remainingCount: Int\n  totalCount: Int\n}\ntype Entity_Tanzu_TAS_BoshDirectorConnectionEdge implements ConnectionEdge {\n  cursor: String\n  node: Entity_Tanzu_TAS_BoshDirector_Type!\n}\ntype Entity_Tanzu_TAS_BoshDirector_IsContainedIn_RelIn {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Deployment:read`\n  \"\"\"\n  tanzu_tas_deployment(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_DeploymentConnection\n}\ntype Entity_Tanzu_TAS_BoshDirector_IsContainedIn_RelOut {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.OpsManager:read`\n  \"\"\"\n  tanzu_tas_opsmanager: Entity_Tanzu_TAS_OpsManager_Type\n}\ntype Entity_Tanzu_TAS_BoshDirector_Properties {\n  \"Name of the CPI the Director will use.\"\n  cpi: String\n  \"The IP address of the BOSH Director deployed on the Foundation\"\n  ip: String\n  \"The BOSH Director ID\"\n  uuid: String\n}\ntype Entity_Tanzu_TAS_BoshDirector_Query {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.BoshDirector:read`\n  \"\"\"\n  query(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_BoshDirectorConnection\n}\ntype Entity_Tanzu_TAS_BoshDirector_RelIn {\n  isContainedIn: Entity_Tanzu_TAS_BoshDirector_IsContainedIn_RelIn\n}\ntype Entity_Tanzu_TAS_BoshDirector_RelOut {\n  isContainedIn: Entity_Tanzu_TAS_BoshDirector_IsContainedIn_RelOut\n}\ntype Entity_Tanzu_TAS_BoshDirector_Type implements EntityTypedInterface & Node & NodeVersion {\n  \"a link to the generic Entity node\"\n  entity: Entity!\n  \"Unique identifier for an entity in a canonical form. Uniqueness is global.\"\n  entityId: EntityId!\n  \"human-readable name of the entity. May be mutable and non-unique.\"\n  entityName: String\n  \"EntityType of the entity. e.g. `ec2`, `security-group` etc. Required but not enforced\"\n  entityType: String\n  \"Opaque global ID\"\n  id: ID!\n  \"Versioning ID\"\n  nodeVersion: ID!\n  properties: Entity_Tanzu_TAS_BoshDirector_Properties\n  relationshipsIn: Entity_Tanzu_TAS_BoshDirector_RelIn\n  relationshipsOut: Entity_Tanzu_TAS_BoshDirector_RelOut\n  \"Key/Value tags for this entity, optionally filtered by key\"\n  tags(\n    \"Filter tags by key\"\n    key: [String!]\n  ): [Tag!]\n}\ntype Entity_Tanzu_TAS_BoshVMConnection implements Connection {\n  count: Int!\n  edges: [Entity_Tanzu_TAS_BoshVMConnectionEdge!]\n  entities: [Entity_Tanzu_TAS_BoshVM_Type!]\n  pageInfo: PageInfo!\n  remainingCount: Int\n  totalCount: Int\n}\ntype Entity_Tanzu_TAS_BoshVMConnectionEdge implements ConnectionEdge {\n  cursor: String\n  node: Entity_Tanzu_TAS_BoshVM_Type!\n}\ntype Entity_Tanzu_TAS_BoshVM_IsAssociatedWith_RelOut {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Stemcell:read`\n  \"\"\"\n  tanzu_tas_stemcell: Entity_Tanzu_TAS_Stemcell_Type\n}\ntype Entity_Tanzu_TAS_BoshVM_IsContainedIn_RelIn {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.ProcessInstance:read`\n  \"\"\"\n  tanzu_tas_processinstance(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_ProcessInstanceConnection\n}\ntype Entity_Tanzu_TAS_BoshVM_IsContainedIn_RelOut {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Deployment:read`\n  \"\"\"\n  tanzu_tas_deployment: Entity_Tanzu_TAS_Deployment_Type\n}\ntype Entity_Tanzu_TAS_BoshVM_Properties {\n  \"Whether or not the VM is active\"\n  active: Boolean\n  \"The name of the agent\"\n  agentID: String\n  \"The availability zone of the VM\"\n  az: String\n  \"Deployment of the BoshVM\"\n  deployment: String\n  \"The disk IDs from the cloud provider\"\n  diskIDs: [String]\n  \"Foundation of the BoshVM\"\n  foundation: String\n  \"The IP addresses of the VM\"\n  iPs: [String]\n  \"The ID of the VM\"\n  id: String\n  \"Whether or not the VM is ignored\"\n  ignore: Boolean\n  \"The VM index\"\n  index: Int\n  \"The name of the VM\"\n  jobName: String\n  \"The state of the VM, e.g., 'running'\"\n  state: String\n  \"False if any VM in the deployment is not in the running state\"\n  status: Boolean\n  \"The stemcell version for the deployment\"\n  stemcell: String\n  \"The time when the VM was created\"\n  vmCreatedAt: Object\n  \"The VM Type from the BOSH Cloud Config\"\n  vmType: String\n  \"The IAAS VM Name\"\n  vmid: String\n}\ntype Entity_Tanzu_TAS_BoshVM_Query {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.BoshVM:read`\n  \"\"\"\n  query(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_BoshVMConnection\n}\ntype Entity_Tanzu_TAS_BoshVM_RelIn {\n  isContainedIn: Entity_Tanzu_TAS_BoshVM_IsContainedIn_RelIn\n}\ntype Entity_Tanzu_TAS_BoshVM_RelOut {\n  isAssociatedWith: Entity_Tanzu_TAS_BoshVM_IsAssociatedWith_RelOut\n  isContainedIn: Entity_Tanzu_TAS_BoshVM_IsContainedIn_RelOut\n}\ntype Entity_Tanzu_TAS_BoshVM_Type implements EntityTypedInterface & Node & NodeVersion {\n  \"a link to the generic Entity node\"\n  entity: Entity!\n  \"Unique identifier for an entity in a canonical form. Uniqueness is global.\"\n  entityId: EntityId!\n  \"human-readable name of the entity. May be mutable and non-unique.\"\n  entityName: String\n  \"EntityType of the entity. e.g. `ec2`, `security-group` etc. Required but not enforced\"\n  entityType: String\n  \"Opaque global ID\"\n  id: ID!\n  \"Versioning ID\"\n  nodeVersion: ID!\n  properties: Entity_Tanzu_TAS_BoshVM_Properties\n  relationshipsIn: Entity_Tanzu_TAS_BoshVM_RelIn\n  relationshipsOut: Entity_Tanzu_TAS_BoshVM_RelOut\n  \"Key/Value tags for this entity, optionally filtered by key\"\n  tags(\n    \"Filter tags by key\"\n    key: [String!]\n  ): [Tag!]\n}\ntype Entity_Tanzu_TAS_BuildpackConnection implements Connection {\n  count: Int!\n  edges: [Entity_Tanzu_TAS_BuildpackConnectionEdge!]\n  entities: [Entity_Tanzu_TAS_Buildpack_Type!]\n  pageInfo: PageInfo!\n  remainingCount: Int\n  totalCount: Int\n}\ntype Entity_Tanzu_TAS_BuildpackConnectionEdge implements ConnectionEdge {\n  cursor: String\n  node: Entity_Tanzu_TAS_Buildpack_Type!\n}\ntype Entity_Tanzu_TAS_Buildpack_IsAssociatedWith_RelIn {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Application:read`\n  \"\"\"\n  tanzu_tas_application(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_ApplicationConnection\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Droplet:read`\n  \"\"\"\n  tanzu_tas_droplet(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_DropletConnection\n}\ntype Entity_Tanzu_TAS_Buildpack_IsAssociatedWith_RelOut {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Foundation:read`\n  \"\"\"\n  tanzu_tas_foundation: Entity_Tanzu_TAS_Foundation_Type\n}\ntype Entity_Tanzu_TAS_Buildpack_Properties {\n  \"RFC 3339 date and time at which Buildpack was created\"\n  createdAt: Object\n  \"Whether or not the buildpack will be used for staging\"\n  enabled: Boolean\n  \"The filename of the buildpack\"\n  filename: String\n  \"The Foundation name on which the buildpack resides\"\n  foundation: String\n  \"The Foundation ID on which the buildpack resides\"\n  foundationID: String\n  \"Whether or not the buildpack is locked to prevent updating the bits\"\n  locked: Boolean\n  \"The name of the buildpack\"\n  name: String\n  \"The order in which the buildpacks are checked during buildpack auto-detection\"\n  position: Int\n  \"The name of the stack that the buildpack will use\"\n  stack: String\n  \"The buildpack state\"\n  state: String\n  \"The buildpack type\"\n  type: String\n  \"RFC 3339 date and time at which Buildpack was updated\"\n  updatedAt: Object\n  \"The version of the buildpack\"\n  version: String\n}\ntype Entity_Tanzu_TAS_Buildpack_Query {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Buildpack:read`\n  \"\"\"\n  query(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_BuildpackConnection\n}\ntype Entity_Tanzu_TAS_Buildpack_RelIn {\n  isAssociatedWith: Entity_Tanzu_TAS_Buildpack_IsAssociatedWith_RelIn\n}\ntype Entity_Tanzu_TAS_Buildpack_RelOut {\n  isAssociatedWith: Entity_Tanzu_TAS_Buildpack_IsAssociatedWith_RelOut\n}\ntype Entity_Tanzu_TAS_Buildpack_Type implements EntityTypedInterface & Node & NodeVersion {\n  \"a link to the generic Entity node\"\n  entity: Entity!\n  \"Unique identifier for an entity in a canonical form. Uniqueness is global.\"\n  entityId: EntityId!\n  \"human-readable name of the entity. May be mutable and non-unique.\"\n  entityName: String\n  \"EntityType of the entity. e.g. `ec2`, `security-group` etc. Required but not enforced\"\n  entityType: String\n  \"Opaque global ID\"\n  id: ID!\n  \"Versioning ID\"\n  nodeVersion: ID!\n  properties: Entity_Tanzu_TAS_Buildpack_Properties\n  relationshipsIn: Entity_Tanzu_TAS_Buildpack_RelIn\n  relationshipsOut: Entity_Tanzu_TAS_Buildpack_RelOut\n  \"Key/Value tags for this entity, optionally filtered by key\"\n  tags(\n    \"Filter tags by key\"\n    key: [String!]\n  ): [Tag!]\n}\ntype Entity_Tanzu_TAS_DeploymentConnection implements Connection {\n  count: Int!\n  edges: [Entity_Tanzu_TAS_DeploymentConnectionEdge!]\n  entities: [Entity_Tanzu_TAS_Deployment_Type!]\n  pageInfo: PageInfo!\n  remainingCount: Int\n  totalCount: Int\n}\ntype Entity_Tanzu_TAS_DeploymentConnectionEdge implements ConnectionEdge {\n  cursor: String\n  node: Entity_Tanzu_TAS_Deployment_Type!\n}\ntype Entity_Tanzu_TAS_Deployment_IsAssociatedWith_RelIn {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.IsolationSegment:read`\n  \"\"\"\n  tanzu_tas_isolationsegment(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_IsolationSegmentConnection\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Tile:read`\n  \"\"\"\n  tanzu_tas_tile(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_TileConnection\n}\ntype Entity_Tanzu_TAS_Deployment_IsAssociatedWith_RelOut {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Stemcell:read`\n  \"\"\"\n  tanzu_tas_stemcell(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_StemcellConnection\n}\ntype Entity_Tanzu_TAS_Deployment_IsContainedIn_RelIn {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.BoshVM:read`\n  \"\"\"\n  tanzu_tas_boshvm(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_BoshVMConnection\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.ServiceInstance:read`\n  \"\"\"\n  tanzu_tas_serviceinstance(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_ServiceInstanceConnection\n}\ntype Entity_Tanzu_TAS_Deployment_IsContainedIn_RelOut {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.BoshDirector:read`\n  \"\"\"\n  tanzu_tas_boshdirector: Entity_Tanzu_TAS_BoshDirector_Type\n}\ntype Entity_Tanzu_TAS_Deployment_Properties {\n  \"The short name of the deployment\"\n  name: String\n  \"The list of networks associated with a deployment\"\n  networks: [String]\n  \"The list of releases associated with a deployment\"\n  releases: [String]\n  \"False if any VM in the deployment is not in the running state\"\n  status: Boolean\n  \"The stemcell version for the deployment\"\n  stemcell: String\n  \"Denotes that this deployment is a Tanzu Application Service or an Isolation Segment deployment\"\n  tasOrIsolationSegment: Boolean\n}\ntype Entity_Tanzu_TAS_Deployment_Query {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Deployment:read`\n  \"\"\"\n  query(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_DeploymentConnection\n}\ntype Entity_Tanzu_TAS_Deployment_RelIn {\n  isAssociatedWith: Entity_Tanzu_TAS_Deployment_IsAssociatedWith_RelIn\n  isContainedIn: Entity_Tanzu_TAS_Deployment_IsContainedIn_RelIn\n}\ntype Entity_Tanzu_TAS_Deployment_RelOut {\n  isAssociatedWith: Entity_Tanzu_TAS_Deployment_IsAssociatedWith_RelOut\n  isContainedIn: Entity_Tanzu_TAS_Deployment_IsContainedIn_RelOut\n}\ntype Entity_Tanzu_TAS_Deployment_Type implements EntityTypedInterface & Node & NodeVersion {\n  \"a link to the generic Entity node\"\n  entity: Entity!\n  \"Unique identifier for an entity in a canonical form. Uniqueness is global.\"\n  entityId: EntityId!\n  \"human-readable name of the entity. May be mutable and non-unique.\"\n  entityName: String\n  \"EntityType of the entity. e.g. `ec2`, `security-group` etc. Required but not enforced\"\n  entityType: String\n  \"Opaque global ID\"\n  id: ID!\n  \"Versioning ID\"\n  nodeVersion: ID!\n  properties: Entity_Tanzu_TAS_Deployment_Properties\n  relationshipsIn: Entity_Tanzu_TAS_Deployment_RelIn\n  relationshipsOut: Entity_Tanzu_TAS_Deployment_RelOut\n  \"Key/Value tags for this entity, optionally filtered by key\"\n  tags(\n    \"Filter tags by key\"\n    key: [String!]\n  ): [Tag!]\n}\ntype Entity_Tanzu_TAS_DomainConnection implements Connection {\n  count: Int!\n  edges: [Entity_Tanzu_TAS_DomainConnectionEdge!]\n  entities: [Entity_Tanzu_TAS_Domain_Type!]\n  pageInfo: PageInfo!\n  remainingCount: Int\n  totalCount: Int\n}\ntype Entity_Tanzu_TAS_DomainConnectionEdge implements ConnectionEdge {\n  cursor: String\n  node: Entity_Tanzu_TAS_Domain_Type!\n}\ntype Entity_Tanzu_TAS_Domain_IsAssociatedWith_RelOut {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Foundation:read`\n  \"\"\"\n  tanzu_tas_foundation: Entity_Tanzu_TAS_Foundation_Type\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Organization:read`\n  \"\"\"\n  tanzu_tas_organization(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_OrganizationConnection\n}\ntype Entity_Tanzu_TAS_Domain_IsContainedIn_RelOut {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Organization:read`\n  \"\"\"\n  tanzu_tas_organization: Entity_Tanzu_TAS_Organization_Type\n}\ntype Entity_Tanzu_TAS_Domain_Properties {\n  \"RFC 3339 date and time at which Domain was created\"\n  createdAt: Object\n  \"The domain GUID\"\n  guid: String\n  \"Whether this is an internal domain\"\n  internal: Boolean\n  \"The name of the domain\"\n  name: String\n  \"Shared Globally or Private\"\n  type: String\n  \"RFC 3339 date and time at which Domain was updated\"\n  updatedAt: Object\n}\ntype Entity_Tanzu_TAS_Domain_Query {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Domain:read`\n  \"\"\"\n  query(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_DomainConnection\n}\ntype Entity_Tanzu_TAS_Domain_RelOut {\n  isAssociatedWith: Entity_Tanzu_TAS_Domain_IsAssociatedWith_RelOut\n  isContainedIn: Entity_Tanzu_TAS_Domain_IsContainedIn_RelOut\n}\ntype Entity_Tanzu_TAS_Domain_Type implements EntityTypedInterface & Node & NodeVersion {\n  \"a link to the generic Entity node\"\n  entity: Entity!\n  \"Unique identifier for an entity in a canonical form. Uniqueness is global.\"\n  entityId: EntityId!\n  \"human-readable name of the entity. May be mutable and non-unique.\"\n  entityName: String\n  \"EntityType of the entity. e.g. `ec2`, `security-group` etc. Required but not enforced\"\n  entityType: String\n  \"Opaque global ID\"\n  id: ID!\n  \"Versioning ID\"\n  nodeVersion: ID!\n  properties: Entity_Tanzu_TAS_Domain_Properties\n  relationshipsOut: Entity_Tanzu_TAS_Domain_RelOut\n  \"Key/Value tags for this entity, optionally filtered by key\"\n  tags(\n    \"Filter tags by key\"\n    key: [String!]\n  ): [Tag!]\n}\ntype Entity_Tanzu_TAS_DropletConnection implements Connection {\n  count: Int!\n  edges: [Entity_Tanzu_TAS_DropletConnectionEdge!]\n  entities: [Entity_Tanzu_TAS_Droplet_Type!]\n  pageInfo: PageInfo!\n  remainingCount: Int\n  totalCount: Int\n}\ntype Entity_Tanzu_TAS_DropletConnectionEdge implements ConnectionEdge {\n  cursor: String\n  node: Entity_Tanzu_TAS_Droplet_Type!\n}\ntype Entity_Tanzu_TAS_Droplet_Contains_RelIn {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Application:read`\n  \"\"\"\n  tanzu_tas_application(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_ApplicationConnection\n}\ntype Entity_Tanzu_TAS_Droplet_IsAssociatedWith_RelIn {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Revision:read`\n  \"\"\"\n  tanzu_tas_revision(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_RevisionConnection\n}\ntype Entity_Tanzu_TAS_Droplet_IsAssociatedWith_RelOut {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Buildpack:read`\n  \"\"\"\n  tanzu_tas_buildpack(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_BuildpackConnection\n}\ntype Entity_Tanzu_TAS_Droplet_Properties {\n  \"The application guid of the association app\"\n  applicationGUID: String\n  \"RFC 3339 date and time at which Application was created\"\n  createdAt: Object\n  \"Whether or not the droplet is the app's current droplet\"\n  current: Boolean\n  \"Detected buildpacks json\"\n  detectedBuildpacks: Object\n  \"A string describing the last error during the droplet lifecycle\"\n  error: String\n  \"The droplet GUID\"\n  guid: String\n  \"Lifecycle type used when staging the droplet, i.e. buildpack and docker\"\n  lifecycleType: String\n  \"The droplet Stack, the root filesystem to use with the buildpack\"\n  stack: String\n  \"State of the droplet; valid states are AWAITING_UPLOAD, PROCESSING_UPLOAD, STAGED, COPYING, FAILED, or EXPIRED\"\n  state: String\n  \"RFC 3339 date and time at which Application was updated\"\n  updatedAt: Object\n}\ntype Entity_Tanzu_TAS_Droplet_Query {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Droplet:read`\n  \"\"\"\n  query(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_DropletConnection\n}\ntype Entity_Tanzu_TAS_Droplet_RelIn {\n  contains: Entity_Tanzu_TAS_Droplet_Contains_RelIn\n  isAssociatedWith: Entity_Tanzu_TAS_Droplet_IsAssociatedWith_RelIn\n}\ntype Entity_Tanzu_TAS_Droplet_RelOut {\n  isAssociatedWith: Entity_Tanzu_TAS_Droplet_IsAssociatedWith_RelOut\n}\ntype Entity_Tanzu_TAS_Droplet_Type implements EntityTypedInterface & Node & NodeVersion {\n  \"a link to the generic Entity node\"\n  entity: Entity!\n  \"Unique identifier for an entity in a canonical form. Uniqueness is global.\"\n  entityId: EntityId!\n  \"human-readable name of the entity. May be mutable and non-unique.\"\n  entityName: String\n  \"EntityType of the entity. e.g. `ec2`, `security-group` etc. Required but not enforced\"\n  entityType: String\n  \"Opaque global ID\"\n  id: ID!\n  \"Versioning ID\"\n  nodeVersion: ID!\n  properties: Entity_Tanzu_TAS_Droplet_Properties\n  relationshipsIn: Entity_Tanzu_TAS_Droplet_RelIn\n  relationshipsOut: Entity_Tanzu_TAS_Droplet_RelOut\n  \"Key/Value tags for this entity, optionally filtered by key\"\n  tags(\n    \"Filter tags by key\"\n    key: [String!]\n  ): [Tag!]\n}\ntype Entity_Tanzu_TAS_FoundationConnection implements Connection {\n  count: Int!\n  edges: [Entity_Tanzu_TAS_FoundationConnectionEdge!]\n  entities: [Entity_Tanzu_TAS_Foundation_Type!]\n  pageInfo: PageInfo!\n  remainingCount: Int\n  totalCount: Int\n}\ntype Entity_Tanzu_TAS_FoundationConnectionEdge implements ConnectionEdge {\n  cursor: String\n  node: Entity_Tanzu_TAS_Foundation_Type!\n}\ntype Entity_Tanzu_TAS_Foundation_IsAssociatedWith_RelIn {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.Platform.OrganizationGroup:read`\n  \"\"\"\n  tanzu_platform_organizationgroup(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_Platform_OrganizationGroupConnection\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.Platform.SpaceGroup:read`\n  \"\"\"\n  tanzu_platform_spacegroup(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_Platform_SpaceGroupConnection\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Buildpack:read`\n  \"\"\"\n  tanzu_tas_buildpack(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_BuildpackConnection\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Domain:read`\n  \"\"\"\n  tanzu_tas_domain(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_DomainConnection\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Stemcell:read`\n  \"\"\"\n  tanzu_tas_stemcell(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_StemcellConnection\n}\ntype Entity_Tanzu_TAS_Foundation_IsContainedIn_RelIn {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.OpsManager:read`\n  \"\"\"\n  tanzu_tas_opsmanager(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_OpsManagerConnection\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Organization:read`\n  \"\"\"\n  tanzu_tas_organization(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_OrganizationConnection\n}\ntype Entity_Tanzu_TAS_Foundation_IsContainedIn_RelOut {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.Platform.FoundationGroup:read`\n  \"\"\"\n  tanzu_platform_foundationgroup: Entity_Tanzu_Platform_FoundationGroup_Type\n}\ntype Entity_Tanzu_TAS_Foundation_IsDeployedBy_RelIn {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.ServiceOffering:read`\n  \"\"\"\n  tanzu_tas_serviceoffering(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_ServiceOfferingConnection\n}\ntype Entity_Tanzu_TAS_Foundation_Properties {\n  \"The number of users\"\n  activeUserCount: Int\n  \"The URL of the Cloud Foundry API\"\n  cloudFoundryAPI: String\n  \"The cloud provider of the foundation it is running in\"\n  cloudProvider: String\n  \"The type of Foundation. One of Production, Pre-Production, QA, Development or Sandbox\"\n  environmentType: String\n  \"The foundation ID. The value of ID is the BOSH Director deployment ID.\"\n  guid: String\n  \"The name of the foundation\"\n  name: String\n  \"The Wavefront source ID from TAS Integration\"\n  wavefrontSourceId: String\n}\ntype Entity_Tanzu_TAS_Foundation_Query {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Foundation:read`\n  \"\"\"\n  query(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_FoundationConnection\n}\ntype Entity_Tanzu_TAS_Foundation_RelIn {\n  isAssociatedWith: Entity_Tanzu_TAS_Foundation_IsAssociatedWith_RelIn\n  isContainedIn: Entity_Tanzu_TAS_Foundation_IsContainedIn_RelIn\n  isDeployedBy: Entity_Tanzu_TAS_Foundation_IsDeployedBy_RelIn\n}\ntype Entity_Tanzu_TAS_Foundation_RelOut {\n  isContainedIn: Entity_Tanzu_TAS_Foundation_IsContainedIn_RelOut\n}\ntype Entity_Tanzu_TAS_Foundation_Type implements EntityTypedInterface & Node & NodeVersion {\n  \"a link to the generic Entity node\"\n  entity: Entity!\n  \"Unique identifier for an entity in a canonical form. Uniqueness is global.\"\n  entityId: EntityId!\n  \"human-readable name of the entity. May be mutable and non-unique.\"\n  entityName: String\n  \"EntityType of the entity. e.g. `ec2`, `security-group` etc. Required but not enforced\"\n  entityType: String\n  \"Opaque global ID\"\n  id: ID!\n  \"Versioning ID\"\n  nodeVersion: ID!\n  properties: Entity_Tanzu_TAS_Foundation_Properties\n  relationshipsIn: Entity_Tanzu_TAS_Foundation_RelIn\n  relationshipsOut: Entity_Tanzu_TAS_Foundation_RelOut\n  \"Key/Value tags for this entity, optionally filtered by key\"\n  tags(\n    \"Filter tags by key\"\n    key: [String!]\n  ): [Tag!]\n}\ntype Entity_Tanzu_TAS_IsolationSegmentConnection implements Connection {\n  count: Int!\n  edges: [Entity_Tanzu_TAS_IsolationSegmentConnectionEdge!]\n  entities: [Entity_Tanzu_TAS_IsolationSegment_Type!]\n  pageInfo: PageInfo!\n  remainingCount: Int\n  totalCount: Int\n}\ntype Entity_Tanzu_TAS_IsolationSegmentConnectionEdge implements ConnectionEdge {\n  cursor: String\n  node: Entity_Tanzu_TAS_IsolationSegment_Type!\n}\ntype Entity_Tanzu_TAS_IsolationSegment_IsAssociatedWith_RelOut {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Deployment:read`\n  \"\"\"\n  tanzu_tas_deployment(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_DeploymentConnection\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Organization:read`\n  \"\"\"\n  tanzu_tas_organization(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_OrganizationConnection\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Space:read`\n  \"\"\"\n  tanzu_tas_space(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_SpaceConnection\n}\ntype Entity_Tanzu_TAS_IsolationSegment_Properties {\n  \"The ID of the isolation segment\"\n  id: String\n}\ntype Entity_Tanzu_TAS_IsolationSegment_Query {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.IsolationSegment:read`\n  \"\"\"\n  query(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_IsolationSegmentConnection\n}\ntype Entity_Tanzu_TAS_IsolationSegment_RelOut {\n  isAssociatedWith: Entity_Tanzu_TAS_IsolationSegment_IsAssociatedWith_RelOut\n}\ntype Entity_Tanzu_TAS_IsolationSegment_Type implements EntityTypedInterface & Node & NodeVersion {\n  \"a link to the generic Entity node\"\n  entity: Entity!\n  \"Unique identifier for an entity in a canonical form. Uniqueness is global.\"\n  entityId: EntityId!\n  \"human-readable name of the entity. May be mutable and non-unique.\"\n  entityName: String\n  \"EntityType of the entity. e.g. `ec2`, `security-group` etc. Required but not enforced\"\n  entityType: String\n  \"Opaque global ID\"\n  id: ID!\n  \"Versioning ID\"\n  nodeVersion: ID!\n  properties: Entity_Tanzu_TAS_IsolationSegment_Properties\n  relationshipsOut: Entity_Tanzu_TAS_IsolationSegment_RelOut\n  \"Key/Value tags for this entity, optionally filtered by key\"\n  tags(\n    \"Filter tags by key\"\n    key: [String!]\n  ): [Tag!]\n}\ntype Entity_Tanzu_TAS_OpsManagerConnection implements Connection {\n  count: Int!\n  edges: [Entity_Tanzu_TAS_OpsManagerConnectionEdge!]\n  entities: [Entity_Tanzu_TAS_OpsManager_Type!]\n  pageInfo: PageInfo!\n  remainingCount: Int\n  totalCount: Int\n}\ntype Entity_Tanzu_TAS_OpsManagerConnectionEdge implements ConnectionEdge {\n  cursor: String\n  node: Entity_Tanzu_TAS_OpsManager_Type!\n}\ntype Entity_Tanzu_TAS_OpsManager_Contains_RelOut {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.VcenterConfig:read`\n  \"\"\"\n  tanzu_tas_vcenterconfig: Entity_Tanzu_TAS_VcenterConfig_Type\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.VMType:read`\n  \"\"\"\n  tanzu_tas_vmtype: Entity_Tanzu_TAS_VMType_Type\n}\ntype Entity_Tanzu_TAS_OpsManager_IsContainedIn_RelIn {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.BoshDirector:read`\n  \"\"\"\n  tanzu_tas_boshdirector(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_BoshDirectorConnection\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Tile:read`\n  \"\"\"\n  tanzu_tas_tile(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_TileConnection\n}\ntype Entity_Tanzu_TAS_OpsManager_IsContainedIn_RelOut {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Foundation:read`\n  \"\"\"\n  tanzu_tas_foundation: Entity_Tanzu_TAS_Foundation_Type\n}\ntype Entity_Tanzu_TAS_OpsManager_Properties {\n  \"BOSH networks for the staged director\"\n  boshNetworks: [String]\n  \"Ops Manager domain name.\"\n  domainName: String\n  \"IAAS networks corresponding to the BOSH networks\"\n  iaasNetworks: [String]\n  \"Ops manager status.\"\n  status: String\n  \"Ops manager version.\"\n  version: String\n}\ntype Entity_Tanzu_TAS_OpsManager_Query {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.OpsManager:read`\n  \"\"\"\n  query(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_OpsManagerConnection\n}\ntype Entity_Tanzu_TAS_OpsManager_RelIn {\n  isContainedIn: Entity_Tanzu_TAS_OpsManager_IsContainedIn_RelIn\n}\ntype Entity_Tanzu_TAS_OpsManager_RelOut {\n  contains: Entity_Tanzu_TAS_OpsManager_Contains_RelOut\n  isContainedIn: Entity_Tanzu_TAS_OpsManager_IsContainedIn_RelOut\n}\ntype Entity_Tanzu_TAS_OpsManager_Type implements EntityTypedInterface & Node & NodeVersion {\n  \"a link to the generic Entity node\"\n  entity: Entity!\n  \"Unique identifier for an entity in a canonical form. Uniqueness is global.\"\n  entityId: EntityId!\n  \"human-readable name of the entity. May be mutable and non-unique.\"\n  entityName: String\n  \"EntityType of the entity. e.g. `ec2`, `security-group` etc. Required but not enforced\"\n  entityType: String\n  \"Opaque global ID\"\n  id: ID!\n  \"Versioning ID\"\n  nodeVersion: ID!\n  properties: Entity_Tanzu_TAS_OpsManager_Properties\n  relationshipsIn: Entity_Tanzu_TAS_OpsManager_RelIn\n  relationshipsOut: Entity_Tanzu_TAS_OpsManager_RelOut\n  \"Key/Value tags for this entity, optionally filtered by key\"\n  tags(\n    \"Filter tags by key\"\n    key: [String!]\n  ): [Tag!]\n}\ntype Entity_Tanzu_TAS_OrganizationConnection implements Connection {\n  count: Int!\n  edges: [Entity_Tanzu_TAS_OrganizationConnectionEdge!]\n  entities: [Entity_Tanzu_TAS_Organization_Type!]\n  pageInfo: PageInfo!\n  remainingCount: Int\n  totalCount: Int\n}\ntype Entity_Tanzu_TAS_OrganizationConnectionEdge implements ConnectionEdge {\n  cursor: String\n  node: Entity_Tanzu_TAS_Organization_Type!\n}\ntype Entity_Tanzu_TAS_OrganizationQuotaConnection implements Connection {\n  count: Int!\n  edges: [Entity_Tanzu_TAS_OrganizationQuotaConnectionEdge!]\n  entities: [Entity_Tanzu_TAS_OrganizationQuota_Type!]\n  pageInfo: PageInfo!\n  remainingCount: Int\n  totalCount: Int\n}\ntype Entity_Tanzu_TAS_OrganizationQuotaConnectionEdge implements ConnectionEdge {\n  cursor: String\n  node: Entity_Tanzu_TAS_OrganizationQuota_Type!\n}\ntype Entity_Tanzu_TAS_OrganizationQuota_IsAssociatedWith_RelOut {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Organization:read`\n  \"\"\"\n  tanzu_tas_organization(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_OrganizationConnection\n}\ntype Entity_Tanzu_TAS_OrganizationQuota_Properties {\n  \"Total log rate limit allowed for all the started processes and running tasks in an organization\"\n  appsQuotaLogRateLimitInBytesPerSecond: Int\n  \"The maximum limit for the number of tasks currently running\"\n  appsQuotaPerAppTasks: Int\n  \"Maximum memory for a single process or task\"\n  appsQuotaPerProcessMemoryInMB: Int\n  \"Total instances of all the started processes allowed in an organization\"\n  appsQuotaTotalInstances: Int\n  \"Total memory allowed for all the started processes and running tasks in an organization\"\n  appsQuotaTotalMemoryMB: Int\n  \"RFC 3339 date and time at which OrganizationQuota was created\"\n  createdAt: Object\n  \"Total number of domains that can be scoped to an organization\"\n  domainsQuotaTotalDomains: Int\n  \"Unique identifier for the organization quota\"\n  guid: String\n  \"Name of the quota\"\n  name: String\n  \"Total number of ports that are reservable by routes in an organization\"\n  routesQuotaTotalReservedPorts: Int\n  \"Total number of routes allowed in an organization\"\n  routesQuotaTotalRoutes: Int\n  \"Specifies whether instances of paid service plans can be created\"\n  servicesQuotaPaidServicesAllowed: Boolean\n  \"Total number of service instances allowed in an organization\"\n  servicesQuotaTotalInstances: Int\n  \"Total number of service keys allowed in an organization\"\n  servicesQuotaTotalServiceKeys: Int\n  \"RFC 3339 date and time at which OrganizationQuota was updated\"\n  updatedAt: Object\n}\ntype Entity_Tanzu_TAS_OrganizationQuota_Query {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.OrganizationQuota:read`\n  \"\"\"\n  query(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_OrganizationQuotaConnection\n}\ntype Entity_Tanzu_TAS_OrganizationQuota_RelOut {\n  isAssociatedWith: Entity_Tanzu_TAS_OrganizationQuota_IsAssociatedWith_RelOut\n}\ntype Entity_Tanzu_TAS_OrganizationQuota_Type implements EntityTypedInterface & Node & NodeVersion {\n  \"a link to the generic Entity node\"\n  entity: Entity!\n  \"Unique identifier for an entity in a canonical form. Uniqueness is global.\"\n  entityId: EntityId!\n  \"human-readable name of the entity. May be mutable and non-unique.\"\n  entityName: String\n  \"EntityType of the entity. e.g. `ec2`, `security-group` etc. Required but not enforced\"\n  entityType: String\n  \"Opaque global ID\"\n  id: ID!\n  \"Versioning ID\"\n  nodeVersion: ID!\n  properties: Entity_Tanzu_TAS_OrganizationQuota_Properties\n  relationshipsOut: Entity_Tanzu_TAS_OrganizationQuota_RelOut\n  \"Key/Value tags for this entity, optionally filtered by key\"\n  tags(\n    \"Filter tags by key\"\n    key: [String!]\n  ): [Tag!]\n}\ntype Entity_Tanzu_TAS_Organization_IsAssociatedWith_RelIn {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Domain:read`\n  \"\"\"\n  tanzu_tas_domain(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_DomainConnection\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.IsolationSegment:read`\n  \"\"\"\n  tanzu_tas_isolationsegment(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_IsolationSegmentConnection\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.OrganizationQuota:read`\n  \"\"\"\n  tanzu_tas_organizationquota(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_OrganizationQuotaConnection\n}\ntype Entity_Tanzu_TAS_Organization_IsContainedIn_RelIn {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Domain:read`\n  \"\"\"\n  tanzu_tas_domain(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_DomainConnection\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Space:read`\n  \"\"\"\n  tanzu_tas_space(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_SpaceConnection\n}\ntype Entity_Tanzu_TAS_Organization_IsContainedIn_RelOut {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.Platform.OrganizationGroup:read`\n  \"\"\"\n  tanzu_platform_organizationgroup: Entity_Tanzu_Platform_OrganizationGroup_Type\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Foundation:read`\n  \"\"\"\n  tanzu_tas_foundation: Entity_Tanzu_TAS_Foundation_Type\n}\ntype Entity_Tanzu_TAS_Organization_Properties {\n  \"Total log rate limit allowed for all the started processes and running tasks in an organization\"\n  appsQuotaLogRateLimitInBytesPerSecond: Int\n  \"Maximum memory for a single process or task\"\n  appsQuotaPerProcessMemoryInMB: Int\n  \"Total instances of all the started processes allowed in an organization\"\n  appsQuotaTotalInstances: Int\n  \"Total memory allowed for all the started processes and running tasks in an organization\"\n  appsQuotaTotalMemoryMB: Int\n  \"RFC 3339 date and time at which Organization was created\"\n  createdAt: Object\n  \"Total number of domains that are used in an organization\"\n  domainsUsed: Int\n  \"The Foundation on which the organization resides\"\n  foundation: String\n  \"The organization ID\"\n  guid: String\n  \"Total amount of memory used in an organization\"\n  memoryInMBUsed: Int\n  \"Total number of per app tasks that are used in an organization\"\n  perAppTasksUsed: Int\n  \"Total number of reserved ports that are used in an organization\"\n  reservedPortsUsed: Int\n  \"Total number of routes used in an organization\"\n  routesUsed: Int\n  \"Total number of service instances that are used in an organization\"\n  serviceInstancesUsed: Int\n  \"Total number of service keys that are used in an organization\"\n  serviceKeysUsed: Int\n  \"Total number of service instances allowed in an organization\"\n  servicesQuotaTotalInstances: Int\n  \"Total number of started instances that are started in an organization\"\n  startedInstancesUsed: Int\n  \"RFC 3339 date and time at which Organization was updated\"\n  updatedAt: Object\n}\ntype Entity_Tanzu_TAS_Organization_Query {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Organization:read`\n  \"\"\"\n  query(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_OrganizationConnection\n}\ntype Entity_Tanzu_TAS_Organization_RelIn {\n  isAssociatedWith: Entity_Tanzu_TAS_Organization_IsAssociatedWith_RelIn\n  isContainedIn: Entity_Tanzu_TAS_Organization_IsContainedIn_RelIn\n}\ntype Entity_Tanzu_TAS_Organization_RelOut {\n  isContainedIn: Entity_Tanzu_TAS_Organization_IsContainedIn_RelOut\n}\ntype Entity_Tanzu_TAS_Organization_Type implements EntityTypedInterface & Node & NodeVersion {\n  \"a link to the generic Entity node\"\n  entity: Entity!\n  \"Unique identifier for an entity in a canonical form. Uniqueness is global.\"\n  entityId: EntityId!\n  \"human-readable name of the entity. May be mutable and non-unique.\"\n  entityName: String\n  \"EntityType of the entity. e.g. `ec2`, `security-group` etc. Required but not enforced\"\n  entityType: String\n  \"Opaque global ID\"\n  id: ID!\n  \"Versioning ID\"\n  nodeVersion: ID!\n  properties: Entity_Tanzu_TAS_Organization_Properties\n  relationshipsIn: Entity_Tanzu_TAS_Organization_RelIn\n  relationshipsOut: Entity_Tanzu_TAS_Organization_RelOut\n  \"Key/Value tags for this entity, optionally filtered by key\"\n  tags(\n    \"Filter tags by key\"\n    key: [String!]\n  ): [Tag!]\n}\ntype Entity_Tanzu_TAS_ProcessInstanceConnection implements Connection {\n  count: Int!\n  edges: [Entity_Tanzu_TAS_ProcessInstanceConnectionEdge!]\n  entities: [Entity_Tanzu_TAS_ProcessInstance_Type!]\n  pageInfo: PageInfo!\n  remainingCount: Int\n  totalCount: Int\n}\ntype Entity_Tanzu_TAS_ProcessInstanceConnectionEdge implements ConnectionEdge {\n  cursor: String\n  node: Entity_Tanzu_TAS_ProcessInstance_Type!\n}\ntype Entity_Tanzu_TAS_ProcessInstance_Contains_RelOut {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.Spring.Instance:read`\n  \"\"\"\n  tanzu_spring_instance: Entity_Tanzu_Spring_Instance_Type\n}\ntype Entity_Tanzu_TAS_ProcessInstance_IsContainedIn_RelOut {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Application:read`\n  \"\"\"\n  tanzu_tas_application: Entity_Tanzu_TAS_Application_Type\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.BoshVM:read`\n  \"\"\"\n  tanzu_tas_boshvm: Entity_Tanzu_TAS_BoshVM_Type\n}\ntype Entity_Tanzu_TAS_ProcessInstance_Properties {\n  \"The application ID\"\n  applicationGUID: String\n  \"The process instance's Cell ID\"\n  cellID: String\n  \"The process instance's Crash Count\"\n  crashCount: Int\n  \"The disk in MBs allocated per instance\"\n  diskLimit: Int\n  \"The process instance's Domain\"\n  domain: String\n  \"The Foundation on which the service resides\"\n  foundation: String\n  \"The process instance GUID\"\n  guid: String\n  \"The process instance's Index\"\n  index: Int\n  \"The log rate limit in bytes per second\"\n  logRateLimitInBytesPerSecond: Int\n  \"The memory in MBs allocated per instance\"\n  memoryLimit: Int\n  \"The Organization ID\"\n  organizationGUID: String\n  \"Whether the process instance is routable\"\n  routable: Boolean\n  \"The Space ID\"\n  spaceGUID: String\n  \"The state of the instance; valid values are RUNNING, CRASHED, STARTING, DOWN\"\n  state: String\n  \"The process's Type\"\n  type: String\n}\ntype Entity_Tanzu_TAS_ProcessInstance_Query {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.ProcessInstance:read`\n  \"\"\"\n  query(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_ProcessInstanceConnection\n}\ntype Entity_Tanzu_TAS_ProcessInstance_RelOut {\n  contains: Entity_Tanzu_TAS_ProcessInstance_Contains_RelOut\n  isContainedIn: Entity_Tanzu_TAS_ProcessInstance_IsContainedIn_RelOut\n}\ntype Entity_Tanzu_TAS_ProcessInstance_Type implements EntityTypedInterface & Node & NodeVersion {\n  \"a link to the generic Entity node\"\n  entity: Entity!\n  \"Unique identifier for an entity in a canonical form. Uniqueness is global.\"\n  entityId: EntityId!\n  \"human-readable name of the entity. May be mutable and non-unique.\"\n  entityName: String\n  \"EntityType of the entity. e.g. `ec2`, `security-group` etc. Required but not enforced\"\n  entityType: String\n  \"Opaque global ID\"\n  id: ID!\n  \"Versioning ID\"\n  nodeVersion: ID!\n  properties: Entity_Tanzu_TAS_ProcessInstance_Properties\n  relationshipsOut: Entity_Tanzu_TAS_ProcessInstance_RelOut\n  \"Key/Value tags for this entity, optionally filtered by key\"\n  tags(\n    \"Filter tags by key\"\n    key: [String!]\n  ): [Tag!]\n}\ntype Entity_Tanzu_TAS_ResourceConnection implements Connection {\n  count: Int!\n  edges: [Entity_Tanzu_TAS_ResourceConnectionEdge!]\n  entities: [Entity_Tanzu_TAS_Resource_Type!]\n  pageInfo: PageInfo!\n  remainingCount: Int\n  totalCount: Int\n}\ntype Entity_Tanzu_TAS_ResourceConnectionEdge implements ConnectionEdge {\n  cursor: String\n  node: Entity_Tanzu_TAS_Resource_Type!\n}\ntype Entity_Tanzu_TAS_Resource_Contains_RelIn {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Tile:read`\n  \"\"\"\n  tanzu_tas_tile(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_TileConnection\n}\ntype Entity_Tanzu_TAS_Resource_Properties {\n  \"Resource description\"\n  description: String\n  \"\"\"\n  The identifier. E.g.: \"director\".\n  \"\"\"\n  identifier: String\n  \"Recommended VM type to run the job\"\n  instanceTypeBestFit: String\n  \"An optional VM type. Overrides InstanceTypeBestFit.\"\n  instanceTypeId: String\n  \"Number of VMs running the job\"\n  instances: Int\n  \"Recommended number of VMs to run the job\"\n  instancesBestFit: Int\n  \"Recommended persistent disk size in Mb\"\n  persistentDiskBestFit: Int\n  \"Allocated persistent disk size in Mb\"\n  persistentDiskMb: Int\n  \"The GUID of the tile this resource belongs to\"\n  tileGUID: String\n}\ntype Entity_Tanzu_TAS_Resource_Query {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Resource:read`\n  \"\"\"\n  query(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_ResourceConnection\n}\ntype Entity_Tanzu_TAS_Resource_RelIn {\n  contains: Entity_Tanzu_TAS_Resource_Contains_RelIn\n}\ntype Entity_Tanzu_TAS_Resource_Type implements EntityTypedInterface & Node & NodeVersion {\n  \"a link to the generic Entity node\"\n  entity: Entity!\n  \"Unique identifier for an entity in a canonical form. Uniqueness is global.\"\n  entityId: EntityId!\n  \"human-readable name of the entity. May be mutable and non-unique.\"\n  entityName: String\n  \"EntityType of the entity. e.g. `ec2`, `security-group` etc. Required but not enforced\"\n  entityType: String\n  \"Opaque global ID\"\n  id: ID!\n  \"Versioning ID\"\n  nodeVersion: ID!\n  properties: Entity_Tanzu_TAS_Resource_Properties\n  relationshipsIn: Entity_Tanzu_TAS_Resource_RelIn\n  \"Key/Value tags for this entity, optionally filtered by key\"\n  tags(\n    \"Filter tags by key\"\n    key: [String!]\n  ): [Tag!]\n}\ntype Entity_Tanzu_TAS_RevisionConnection implements Connection {\n  count: Int!\n  edges: [Entity_Tanzu_TAS_RevisionConnectionEdge!]\n  entities: [Entity_Tanzu_TAS_Revision_Type!]\n  pageInfo: PageInfo!\n  remainingCount: Int\n  totalCount: Int\n}\ntype Entity_Tanzu_TAS_RevisionConnectionEdge implements ConnectionEdge {\n  cursor: String\n  node: Entity_Tanzu_TAS_Revision_Type!\n}\ntype Entity_Tanzu_TAS_Revision_Contains_RelIn {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Application:read`\n  \"\"\"\n  tanzu_tas_application(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_ApplicationConnection\n}\ntype Entity_Tanzu_TAS_Revision_IsAssociatedWith_RelOut {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Droplet:read`\n  \"\"\"\n  tanzu_tas_droplet: Entity_Tanzu_TAS_Droplet_Type\n}\ntype Entity_Tanzu_TAS_Revision_Properties {\n  \"The application guid of the associated app\"\n  applicationGUID: String\n  \"RFC 3339 date and time at which Application was created\"\n  createdAt: Object\n  \"Indicates if the revisions droplet is staged and the revision can be used to create a deployment\"\n  deployable: Boolean\n  \"Indicates if the revision is currently deployed\"\n  deployed: Boolean\n  \"A short description of the reason for revision\"\n  description: String\n  \"The droplet guid of the associated droplet\"\n  dropletGUID: String\n  \"The Revision GUID\"\n  guid: String\n  \"RFC 3339 date and time at which Application was updated\"\n  updatedAt: Object\n  \"Human-readable identifier for the revision; starts at 1, increments by 1 for each new revision of the app\"\n  version: Int\n}\ntype Entity_Tanzu_TAS_Revision_Query {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Revision:read`\n  \"\"\"\n  query(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_RevisionConnection\n}\ntype Entity_Tanzu_TAS_Revision_RelIn {\n  contains: Entity_Tanzu_TAS_Revision_Contains_RelIn\n}\ntype Entity_Tanzu_TAS_Revision_RelOut {\n  isAssociatedWith: Entity_Tanzu_TAS_Revision_IsAssociatedWith_RelOut\n}\ntype Entity_Tanzu_TAS_Revision_Type implements EntityTypedInterface & Node & NodeVersion {\n  \"a link to the generic Entity node\"\n  entity: Entity!\n  \"Unique identifier for an entity in a canonical form. Uniqueness is global.\"\n  entityId: EntityId!\n  \"human-readable name of the entity. May be mutable and non-unique.\"\n  entityName: String\n  \"EntityType of the entity. e.g. `ec2`, `security-group` etc. Required but not enforced\"\n  entityType: String\n  \"Opaque global ID\"\n  id: ID!\n  \"Versioning ID\"\n  nodeVersion: ID!\n  properties: Entity_Tanzu_TAS_Revision_Properties\n  relationshipsIn: Entity_Tanzu_TAS_Revision_RelIn\n  relationshipsOut: Entity_Tanzu_TAS_Revision_RelOut\n  \"Key/Value tags for this entity, optionally filtered by key\"\n  tags(\n    \"Filter tags by key\"\n    key: [String!]\n  ): [Tag!]\n}\ntype Entity_Tanzu_TAS_ServiceInstanceConnection implements Connection {\n  count: Int!\n  edges: [Entity_Tanzu_TAS_ServiceInstanceConnectionEdge!]\n  entities: [Entity_Tanzu_TAS_ServiceInstance_Type!]\n  pageInfo: PageInfo!\n  remainingCount: Int\n  totalCount: Int\n}\ntype Entity_Tanzu_TAS_ServiceInstanceConnectionEdge implements ConnectionEdge {\n  cursor: String\n  node: Entity_Tanzu_TAS_ServiceInstance_Type!\n}\ntype Entity_Tanzu_TAS_ServiceInstance_IsAssociatedWith_RelIn {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Application:read`\n  \"\"\"\n  tanzu_tas_application(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_ApplicationConnection\n}\ntype Entity_Tanzu_TAS_ServiceInstance_IsAssociatedWith_RelOut {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Space:read`\n  \"\"\"\n  tanzu_tas_space(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_SpaceConnection\n}\ntype Entity_Tanzu_TAS_ServiceInstance_IsContainedIn_RelOut {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Deployment:read`\n  \"\"\"\n  tanzu_tas_deployment: Entity_Tanzu_TAS_Deployment_Type\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.ServiceOffering:read`\n  \"\"\"\n  tanzu_tas_serviceoffering: Entity_Tanzu_TAS_ServiceOffering_Type\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.ServicePlan:read`\n  \"\"\"\n  tanzu_tas_serviceplan: Entity_Tanzu_TAS_ServicePlan_Type\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Space:read`\n  \"\"\"\n  tanzu_tas_space: Entity_Tanzu_TAS_Space_Type\n}\ntype Entity_Tanzu_TAS_ServiceInstance_Properties {\n  \"Count of bound applications\"\n  boundAppCount: Int\n  \"RFC 3339 date and time at which ServiceInstance was created\"\n  createdAt: Object\n  \"The service dashboard url (optional)\"\n  dashboardURL: String\n  \"The Foundation on which the service resides\"\n  foundation: String\n  \"The service instance GUID\"\n  guid: String\n  \"Last operation state (initial, in progress, succeeded, or failed)\"\n  lastOperationState: String\n  \"Last operation type (create, update, or delete)\"\n  lastOperationType: String\n  \"RFC 3339 date and time of the last operation\"\n  lastOperationUpdatedAt: Object\n  \"The plan, e.g.: extra-small.\"\n  plan: String\n  \"The routes bound to the service instance\"\n  serviceBoundRoutes: [String]\n  \"The names of the ServiceCredentialBindings of type 'key' bound to the service instance\"\n  serviceCredentialKeyNames: [String]\n  \"The service description\"\n  serviceDescription: String\n  \"The display name of Service Offering\"\n  serviceOfferingName: String\n  \"The type of service, e.g.: mysql, postgres\"\n  serviceType: String\n  \"The space guids which are related to the service\"\n  sharedSpacesGUIDs: [String]\n  \"The service instance Space GUID\"\n  spaceGUID: String\n  \"The service type (managed or user-provided)\"\n  type: String\n  \"RFC 3339 date and time at which ServiceInstance was updated\"\n  updatedAt: Object\n  \"Whether or not an upgrade is available.\"\n  upgradeAvailable: Boolean\n}\ntype Entity_Tanzu_TAS_ServiceInstance_Query {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.ServiceInstance:read`\n  \"\"\"\n  query(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_ServiceInstanceConnection\n}\ntype Entity_Tanzu_TAS_ServiceInstance_RelIn {\n  isAssociatedWith: Entity_Tanzu_TAS_ServiceInstance_IsAssociatedWith_RelIn\n}\ntype Entity_Tanzu_TAS_ServiceInstance_RelOut {\n  isAssociatedWith: Entity_Tanzu_TAS_ServiceInstance_IsAssociatedWith_RelOut\n  isContainedIn: Entity_Tanzu_TAS_ServiceInstance_IsContainedIn_RelOut\n}\ntype Entity_Tanzu_TAS_ServiceInstance_Type implements EntityTypedInterface & Node & NodeVersion {\n  \"a link to the generic Entity node\"\n  entity: Entity!\n  \"Unique identifier for an entity in a canonical form. Uniqueness is global.\"\n  entityId: EntityId!\n  \"human-readable name of the entity. May be mutable and non-unique.\"\n  entityName: String\n  \"EntityType of the entity. e.g. `ec2`, `security-group` etc. Required but not enforced\"\n  entityType: String\n  \"Opaque global ID\"\n  id: ID!\n  \"Versioning ID\"\n  nodeVersion: ID!\n  properties: Entity_Tanzu_TAS_ServiceInstance_Properties\n  relationshipsIn: Entity_Tanzu_TAS_ServiceInstance_RelIn\n  relationshipsOut: Entity_Tanzu_TAS_ServiceInstance_RelOut\n  \"Key/Value tags for this entity, optionally filtered by key\"\n  tags(\n    \"Filter tags by key\"\n    key: [String!]\n  ): [Tag!]\n}\ntype Entity_Tanzu_TAS_ServiceOfferingConnection implements Connection {\n  count: Int!\n  edges: [Entity_Tanzu_TAS_ServiceOfferingConnectionEdge!]\n  entities: [Entity_Tanzu_TAS_ServiceOffering_Type!]\n  pageInfo: PageInfo!\n  remainingCount: Int\n  totalCount: Int\n}\ntype Entity_Tanzu_TAS_ServiceOfferingConnectionEdge implements ConnectionEdge {\n  cursor: String\n  node: Entity_Tanzu_TAS_ServiceOffering_Type!\n}\ntype Entity_Tanzu_TAS_ServiceOffering_IsContainedIn_RelIn {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.ServiceInstance:read`\n  \"\"\"\n  tanzu_tas_serviceinstance(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_ServiceInstanceConnection\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.ServicePlan:read`\n  \"\"\"\n  tanzu_tas_serviceplan(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_ServicePlanConnection\n}\ntype Entity_Tanzu_TAS_ServiceOffering_IsDeployedBy_RelOut {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Foundation:read`\n  \"\"\"\n  tanzu_tas_foundation: Entity_Tanzu_TAS_Foundation_Type\n}\ntype Entity_Tanzu_TAS_ServiceOffering_Properties {\n  \"Description of the service offering\"\n  description: String\n  \"The name of the service to be displayed in graphical clients\"\n  displayName: String\n  \"URL to the documentation page for the service offering\"\n  documentationURL: String\n  \"The service offering GUID\"\n  guid: String\n  \"The URL to an image or a data URL containing an image\"\n  imageURL: Object\n  \"Long description for the service offering\"\n  longDescription: String\n  \"Name of the service offering\"\n  name: String\n  \"The name of the upstream entity providing the actual service\"\n  providerDisplayName: String\n  \"The type of support provided for the service offering\"\n  supportType: String\n  \"Link to support page for the service\"\n  supportURL: String\n  \"Tags associated with the service offering\"\n  tags: [String]\n}\ntype Entity_Tanzu_TAS_ServiceOffering_Query {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.ServiceOffering:read`\n  \"\"\"\n  query(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_ServiceOfferingConnection\n}\ntype Entity_Tanzu_TAS_ServiceOffering_RelIn {\n  isContainedIn: Entity_Tanzu_TAS_ServiceOffering_IsContainedIn_RelIn\n}\ntype Entity_Tanzu_TAS_ServiceOffering_RelOut {\n  isDeployedBy: Entity_Tanzu_TAS_ServiceOffering_IsDeployedBy_RelOut\n}\ntype Entity_Tanzu_TAS_ServiceOffering_Type implements EntityTypedInterface & Node & NodeVersion {\n  \"a link to the generic Entity node\"\n  entity: Entity!\n  \"Unique identifier for an entity in a canonical form. Uniqueness is global.\"\n  entityId: EntityId!\n  \"human-readable name of the entity. May be mutable and non-unique.\"\n  entityName: String\n  \"EntityType of the entity. e.g. `ec2`, `security-group` etc. Required but not enforced\"\n  entityType: String\n  \"Opaque global ID\"\n  id: ID!\n  \"Versioning ID\"\n  nodeVersion: ID!\n  properties: Entity_Tanzu_TAS_ServiceOffering_Properties\n  relationshipsIn: Entity_Tanzu_TAS_ServiceOffering_RelIn\n  relationshipsOut: Entity_Tanzu_TAS_ServiceOffering_RelOut\n  \"Key/Value tags for this entity, optionally filtered by key\"\n  tags(\n    \"Filter tags by key\"\n    key: [String!]\n  ): [Tag!]\n}\ntype Entity_Tanzu_TAS_ServicePlanConnection implements Connection {\n  count: Int!\n  edges: [Entity_Tanzu_TAS_ServicePlanConnectionEdge!]\n  entities: [Entity_Tanzu_TAS_ServicePlan_Type!]\n  pageInfo: PageInfo!\n  remainingCount: Int\n  totalCount: Int\n}\ntype Entity_Tanzu_TAS_ServicePlanConnectionEdge implements ConnectionEdge {\n  cursor: String\n  node: Entity_Tanzu_TAS_ServicePlan_Type!\n}\ntype Entity_Tanzu_TAS_ServicePlan_IsContainedIn_RelIn {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.ServiceInstance:read`\n  \"\"\"\n  tanzu_tas_serviceinstance(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_ServiceInstanceConnection\n}\ntype Entity_Tanzu_TAS_ServicePlan_IsContainedIn_RelOut {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.ServiceOffering:read`\n  \"\"\"\n  tanzu_tas_serviceoffering: Entity_Tanzu_TAS_ServiceOffering_Type\n}\ntype Entity_Tanzu_TAS_ServicePlan_Properties {\n  \"Whether or not the service plan is available\"\n  available: Boolean\n  \"Array of cost information for the service plan. Each element is a JSON string containing amount, currency, and unit.\"\n  costs: [String]\n  \"Description of the service plan\"\n  description: String\n  \"Whether or not the service plan is free of charge\"\n  free: Boolean\n  \"Unique identifier for the service plan\"\n  guid: String\n  \"Name of the service plan\"\n  name: String\n  \"Denotes the visibility of the plan; can be public, admin, organization, space.\"\n  visibilityType: String\n}\ntype Entity_Tanzu_TAS_ServicePlan_Query {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.ServicePlan:read`\n  \"\"\"\n  query(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_ServicePlanConnection\n}\ntype Entity_Tanzu_TAS_ServicePlan_RelIn {\n  isContainedIn: Entity_Tanzu_TAS_ServicePlan_IsContainedIn_RelIn\n}\ntype Entity_Tanzu_TAS_ServicePlan_RelOut {\n  isContainedIn: Entity_Tanzu_TAS_ServicePlan_IsContainedIn_RelOut\n}\ntype Entity_Tanzu_TAS_ServicePlan_Type implements EntityTypedInterface & Node & NodeVersion {\n  \"a link to the generic Entity node\"\n  entity: Entity!\n  \"Unique identifier for an entity in a canonical form. Uniqueness is global.\"\n  entityId: EntityId!\n  \"human-readable name of the entity. May be mutable and non-unique.\"\n  entityName: String\n  \"EntityType of the entity. e.g. `ec2`, `security-group` etc. Required but not enforced\"\n  entityType: String\n  \"Opaque global ID\"\n  id: ID!\n  \"Versioning ID\"\n  nodeVersion: ID!\n  properties: Entity_Tanzu_TAS_ServicePlan_Properties\n  relationshipsIn: Entity_Tanzu_TAS_ServicePlan_RelIn\n  relationshipsOut: Entity_Tanzu_TAS_ServicePlan_RelOut\n  \"Key/Value tags for this entity, optionally filtered by key\"\n  tags(\n    \"Filter tags by key\"\n    key: [String!]\n  ): [Tag!]\n}\ntype Entity_Tanzu_TAS_SpaceConnection implements Connection {\n  count: Int!\n  edges: [Entity_Tanzu_TAS_SpaceConnectionEdge!]\n  entities: [Entity_Tanzu_TAS_Space_Type!]\n  pageInfo: PageInfo!\n  remainingCount: Int\n  totalCount: Int\n}\ntype Entity_Tanzu_TAS_SpaceConnectionEdge implements ConnectionEdge {\n  cursor: String\n  node: Entity_Tanzu_TAS_Space_Type!\n}\ntype Entity_Tanzu_TAS_Space_IsAssociatedWith_RelIn {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.IsolationSegment:read`\n  \"\"\"\n  tanzu_tas_isolationsegment(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_IsolationSegmentConnection\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.ServiceInstance:read`\n  \"\"\"\n  tanzu_tas_serviceinstance(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_ServiceInstanceConnection\n}\ntype Entity_Tanzu_TAS_Space_IsContainedIn_RelIn {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Application:read`\n  \"\"\"\n  tanzu_tas_application(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_ApplicationConnection\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.ServiceInstance:read`\n  \"\"\"\n  tanzu_tas_serviceinstance(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_ServiceInstanceConnection\n}\ntype Entity_Tanzu_TAS_Space_IsContainedIn_RelOut {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.Platform.SpaceGroup:read`\n  \"\"\"\n  tanzu_platform_spacegroup: Entity_Tanzu_Platform_SpaceGroup_Type\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Organization:read`\n  \"\"\"\n  tanzu_tas_organization: Entity_Tanzu_TAS_Organization_Type\n}\ntype Entity_Tanzu_TAS_Space_Properties {\n  \"RFC 3339 date and time at which Space was created\"\n  createdAt: Object\n  \"The Foundation on which the service resides\"\n  foundation: String\n  \"The space ID\"\n  guid: String\n  \"Total log rate limit allowed for all the started processes and running tasks in an organization\"\n  logRateLimitQuotaInBytesPerSecond: Int\n  \"The organization ID\"\n  organizationGUID: String\n  \"Specifies whether instances of paid service plans can be created\"\n  paidServicesAllowed: Boolean\n  \"Maximum memory for a single process or task\"\n  perProcessMemoryQuotaMB: Int\n  \"Total number of applications deployed in a space\"\n  totalAppCount: Int\n  \"Total instances of all the started processes allowed in a space\"\n  totalInstancesQuota: Int\n  \"Sum of app web process LogRateLimitInBytesPerSecond limits in a space\"\n  totalLogRateLimitInBytesPerSecond: Int\n  \"Sum of app web process memory limits in a space\"\n  totalMemoryLimitMB: Int\n  \"Total memory allowed for all the started processes and running tasks in a space\"\n  totalMemoryQuotaMB: Int\n  \"Total number of ports that are reservable by routes in a space\"\n  totalReservedPortsQuota: Int\n  \"Total number of routes allowed in a space\"\n  totalRoutesQuota: Int\n  \"Total number of service instances created in a space\"\n  totalServiceInstanceCount: Int\n  \"Total number of service instances allowed in a space\"\n  totalServiceInstancesQuota: Int\n  \"Total number of service keys allowed in a space\"\n  totalServiceKeysQuota: Int\n  \"Maximum number of running tasks in a space\"\n  totalTasksQuota: Int\n  \"RFC 3339 date and time at which Space was updated\"\n  updatedAt: Object\n}\ntype Entity_Tanzu_TAS_Space_Query {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Space:read`\n  \"\"\"\n  query(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_SpaceConnection\n}\ntype Entity_Tanzu_TAS_Space_RelIn {\n  isAssociatedWith: Entity_Tanzu_TAS_Space_IsAssociatedWith_RelIn\n  isContainedIn: Entity_Tanzu_TAS_Space_IsContainedIn_RelIn\n}\ntype Entity_Tanzu_TAS_Space_RelOut {\n  isContainedIn: Entity_Tanzu_TAS_Space_IsContainedIn_RelOut\n}\ntype Entity_Tanzu_TAS_Space_Type implements EntityTypedInterface & Node & NodeVersion {\n  \"a link to the generic Entity node\"\n  entity: Entity!\n  \"Unique identifier for an entity in a canonical form. Uniqueness is global.\"\n  entityId: EntityId!\n  \"human-readable name of the entity. May be mutable and non-unique.\"\n  entityName: String\n  \"EntityType of the entity. e.g. `ec2`, `security-group` etc. Required but not enforced\"\n  entityType: String\n  \"Opaque global ID\"\n  id: ID!\n  \"Versioning ID\"\n  nodeVersion: ID!\n  properties: Entity_Tanzu_TAS_Space_Properties\n  relationshipsIn: Entity_Tanzu_TAS_Space_RelIn\n  relationshipsOut: Entity_Tanzu_TAS_Space_RelOut\n  \"Key/Value tags for this entity, optionally filtered by key\"\n  tags(\n    \"Filter tags by key\"\n    key: [String!]\n  ): [Tag!]\n}\ntype Entity_Tanzu_TAS_StemcellConnection implements Connection {\n  count: Int!\n  edges: [Entity_Tanzu_TAS_StemcellConnectionEdge!]\n  entities: [Entity_Tanzu_TAS_Stemcell_Type!]\n  pageInfo: PageInfo!\n  remainingCount: Int\n  totalCount: Int\n}\ntype Entity_Tanzu_TAS_StemcellConnectionEdge implements ConnectionEdge {\n  cursor: String\n  node: Entity_Tanzu_TAS_Stemcell_Type!\n}\ntype Entity_Tanzu_TAS_Stemcell_IsAssociatedWith_RelIn {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.BoshVM:read`\n  \"\"\"\n  tanzu_tas_boshvm(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_BoshVMConnection\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Deployment:read`\n  \"\"\"\n  tanzu_tas_deployment(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_DeploymentConnection\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Tile:read`\n  \"\"\"\n  tanzu_tas_tile(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_TileConnection\n}\ntype Entity_Tanzu_TAS_Stemcell_IsAssociatedWith_RelOut {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Foundation:read`\n  \"\"\"\n  tanzu_tas_foundation: Entity_Tanzu_TAS_Foundation_Type\n}\ntype Entity_Tanzu_TAS_Stemcell_Properties {\n  \"Whether or not the stemcell is currently deployed\"\n  currentlyDeployed: Boolean\n  \"Whether or not the stemcell is a FIPS version\"\n  fips: Boolean\n  \"The Foundation name on which the stemcell resides\"\n  foundation: String\n  \"The hypervisor of the stemcell\"\n  hypervisor: String\n  \"The infrastructure of the stemcell\"\n  infrastructure: String\n  \"Whether or not the stemcell is the light version\"\n  light: Boolean\n  \"The name of the stemcell in the manifest file\"\n  name: String\n  \"The os of the stemcell\"\n  os: String\n  \"The version of the stemcell\"\n  version: String\n}\ntype Entity_Tanzu_TAS_Stemcell_Query {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Stemcell:read`\n  \"\"\"\n  query(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_StemcellConnection\n}\ntype Entity_Tanzu_TAS_Stemcell_RelIn {\n  isAssociatedWith: Entity_Tanzu_TAS_Stemcell_IsAssociatedWith_RelIn\n}\ntype Entity_Tanzu_TAS_Stemcell_RelOut {\n  isAssociatedWith: Entity_Tanzu_TAS_Stemcell_IsAssociatedWith_RelOut\n}\ntype Entity_Tanzu_TAS_Stemcell_Type implements EntityTypedInterface & Node & NodeVersion {\n  \"a link to the generic Entity node\"\n  entity: Entity!\n  \"Unique identifier for an entity in a canonical form. Uniqueness is global.\"\n  entityId: EntityId!\n  \"human-readable name of the entity. May be mutable and non-unique.\"\n  entityName: String\n  \"EntityType of the entity. e.g. `ec2`, `security-group` etc. Required but not enforced\"\n  entityType: String\n  \"Opaque global ID\"\n  id: ID!\n  \"Versioning ID\"\n  nodeVersion: ID!\n  properties: Entity_Tanzu_TAS_Stemcell_Properties\n  relationshipsIn: Entity_Tanzu_TAS_Stemcell_RelIn\n  relationshipsOut: Entity_Tanzu_TAS_Stemcell_RelOut\n  \"Key/Value tags for this entity, optionally filtered by key\"\n  tags(\n    \"Filter tags by key\"\n    key: [String!]\n  ): [Tag!]\n}\ntype Entity_Tanzu_TAS_TileConnection implements Connection {\n  count: Int!\n  edges: [Entity_Tanzu_TAS_TileConnectionEdge!]\n  entities: [Entity_Tanzu_TAS_Tile_Type!]\n  pageInfo: PageInfo!\n  remainingCount: Int\n  totalCount: Int\n}\ntype Entity_Tanzu_TAS_TileConnectionEdge implements ConnectionEdge {\n  cursor: String\n  node: Entity_Tanzu_TAS_Tile_Type!\n}\ntype Entity_Tanzu_TAS_Tile_Contains_RelOut {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Resource:read`\n  \"\"\"\n  tanzu_tas_resource: Entity_Tanzu_TAS_Resource_Type\n}\ntype Entity_Tanzu_TAS_Tile_IsAssociatedWith_RelOut {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Deployment:read`\n  \"\"\"\n  tanzu_tas_deployment: Entity_Tanzu_TAS_Deployment_Type\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Stemcell:read`\n  \"\"\"\n  tanzu_tas_stemcell(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_StemcellConnection\n}\ntype Entity_Tanzu_TAS_Tile_IsContainedIn_RelOut {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.OpsManager:read`\n  \"\"\"\n  tanzu_tas_opsmanager: Entity_Tanzu_TAS_OpsManager_Type\n}\ntype Entity_Tanzu_TAS_Tile_Properties {\n  \"The unique identifier for the instance of this product given by Ops Manager\"\n  guid: String\n  \"The icon for the product, base64-encoded\"\n  icon: Object\n  \"The guid for the instance of this product. Always equals the guid, except when the product is the bosh director (p-bosh)\"\n  installationName: String\n  \"The name displayed by the product on the ops manager dashboard\"\n  label: String\n  \"Product license\"\n  licenseMetadata: Object\n  \"The network assigned to the product\"\n  networkName: String\n  \"The AZs where non-singleton jobs will be balanced\"\n  otherAzs: [String]\n  \"The version of the product installed\"\n  productVersion: String\n  \"Configured tile properties in Ops Manager\"\n  properties: Object\n  \"The required stemcells for the product\"\n  requiredStemcells: [String]\n  \"True if the product is a service broker\"\n  serviceBroker: Boolean\n  \"The AZ where singleton jobs will be placed\"\n  singletonAz: String\n  \"The stemcells for the product\"\n  stemcells: [String]\n  \"The name of the product, displayed as the type\"\n  type: String\n}\ntype Entity_Tanzu_TAS_Tile_Query {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.Tile:read`\n  \"\"\"\n  query(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_TileConnection\n}\ntype Entity_Tanzu_TAS_Tile_RelOut {\n  contains: Entity_Tanzu_TAS_Tile_Contains_RelOut\n  isAssociatedWith: Entity_Tanzu_TAS_Tile_IsAssociatedWith_RelOut\n  isContainedIn: Entity_Tanzu_TAS_Tile_IsContainedIn_RelOut\n}\ntype Entity_Tanzu_TAS_Tile_Type implements EntityTypedInterface & Node & NodeVersion {\n  \"a link to the generic Entity node\"\n  entity: Entity!\n  \"Unique identifier for an entity in a canonical form. Uniqueness is global.\"\n  entityId: EntityId!\n  \"human-readable name of the entity. May be mutable and non-unique.\"\n  entityName: String\n  \"EntityType of the entity. e.g. `ec2`, `security-group` etc. Required but not enforced\"\n  entityType: String\n  \"Opaque global ID\"\n  id: ID!\n  \"Versioning ID\"\n  nodeVersion: ID!\n  properties: Entity_Tanzu_TAS_Tile_Properties\n  relationshipsOut: Entity_Tanzu_TAS_Tile_RelOut\n  \"Key/Value tags for this entity, optionally filtered by key\"\n  tags(\n    \"Filter tags by key\"\n    key: [String!]\n  ): [Tag!]\n}\ntype Entity_Tanzu_TAS_Type {\n  application: Entity_Tanzu_TAS_Application_Query\n  boshdirector: Entity_Tanzu_TAS_BoshDirector_Query\n  boshvm: Entity_Tanzu_TAS_BoshVM_Query\n  buildpack: Entity_Tanzu_TAS_Buildpack_Query\n  deployment: Entity_Tanzu_TAS_Deployment_Query\n  domain: Entity_Tanzu_TAS_Domain_Query\n  droplet: Entity_Tanzu_TAS_Droplet_Query\n  foundation: Entity_Tanzu_TAS_Foundation_Query\n  isolationsegment: Entity_Tanzu_TAS_IsolationSegment_Query\n  opsmanager: Entity_Tanzu_TAS_OpsManager_Query\n  organization: Entity_Tanzu_TAS_Organization_Query\n  organizationquota: Entity_Tanzu_TAS_OrganizationQuota_Query\n  processinstance: Entity_Tanzu_TAS_ProcessInstance_Query\n  resource: Entity_Tanzu_TAS_Resource_Query\n  revision: Entity_Tanzu_TAS_Revision_Query\n  serviceinstance: Entity_Tanzu_TAS_ServiceInstance_Query\n  serviceoffering: Entity_Tanzu_TAS_ServiceOffering_Query\n  serviceplan: Entity_Tanzu_TAS_ServicePlan_Query\n  space: Entity_Tanzu_TAS_Space_Query\n  stemcell: Entity_Tanzu_TAS_Stemcell_Query\n  tile: Entity_Tanzu_TAS_Tile_Query\n  vcenterconfig: Entity_Tanzu_TAS_VcenterConfig_Query\n  vmtype: Entity_Tanzu_TAS_VMType_Query\n}\ntype Entity_Tanzu_TAS_VMTypeConnection implements Connection {\n  count: Int!\n  edges: [Entity_Tanzu_TAS_VMTypeConnectionEdge!]\n  entities: [Entity_Tanzu_TAS_VMType_Type!]\n  pageInfo: PageInfo!\n  remainingCount: Int\n  totalCount: Int\n}\ntype Entity_Tanzu_TAS_VMTypeConnectionEdge implements ConnectionEdge {\n  cursor: String\n  node: Entity_Tanzu_TAS_VMType_Type!\n}\ntype Entity_Tanzu_TAS_VMType_Contains_RelIn {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.OpsManager:read`\n  \"\"\"\n  tanzu_tas_opsmanager(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_OpsManagerConnection\n}\ntype Entity_Tanzu_TAS_VMType_Properties {\n  \"Whether this type is built-in or custom\"\n  builtin: Boolean\n  \"VM CPU count\"\n  cpu: Int\n  \"VM ephemeral disk size in Mb\"\n  ephemeralDisk: Int\n  \"IaaS-specific instance type\"\n  machineType: String\n  \"\"\"\n  The name of the VM type. E.g.: \"micro\".\n  \"\"\"\n  name: String\n  \"VM RAM in Mb\"\n  ram: Int\n}\ntype Entity_Tanzu_TAS_VMType_Query {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.VMType:read`\n  \"\"\"\n  query(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_VMTypeConnection\n}\ntype Entity_Tanzu_TAS_VMType_RelIn {\n  contains: Entity_Tanzu_TAS_VMType_Contains_RelIn\n}\ntype Entity_Tanzu_TAS_VMType_Type implements EntityTypedInterface & Node & NodeVersion {\n  \"a link to the generic Entity node\"\n  entity: Entity!\n  \"Unique identifier for an entity in a canonical form. Uniqueness is global.\"\n  entityId: EntityId!\n  \"human-readable name of the entity. May be mutable and non-unique.\"\n  entityName: String\n  \"EntityType of the entity. e.g. `ec2`, `security-group` etc. Required but not enforced\"\n  entityType: String\n  \"Opaque global ID\"\n  id: ID!\n  \"Versioning ID\"\n  nodeVersion: ID!\n  properties: Entity_Tanzu_TAS_VMType_Properties\n  relationshipsIn: Entity_Tanzu_TAS_VMType_RelIn\n  \"Key/Value tags for this entity, optionally filtered by key\"\n  tags(\n    \"Filter tags by key\"\n    key: [String!]\n  ): [Tag!]\n}\ntype Entity_Tanzu_TAS_VcenterConfigConnection implements Connection {\n  count: Int!\n  edges: [Entity_Tanzu_TAS_VcenterConfigConnectionEdge!]\n  entities: [Entity_Tanzu_TAS_VcenterConfig_Type!]\n  pageInfo: PageInfo!\n  remainingCount: Int\n  totalCount: Int\n}\ntype Entity_Tanzu_TAS_VcenterConfigConnectionEdge implements ConnectionEdge {\n  cursor: String\n  node: Entity_Tanzu_TAS_VcenterConfig_Type!\n}\ntype Entity_Tanzu_TAS_VcenterConfig_Contains_RelIn {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.OpsManager:read`\n  \"\"\"\n  tanzu_tas_opsmanager(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_OpsManagerConnection\n}\ntype Entity_Tanzu_TAS_VcenterConfig_Properties {\n  \"The name of the datacenter\"\n  datacenter: String\n  \"Ephemeral datastore cluster names\"\n  ephemeralDatastoreClusters: [String]\n  \"Ephemeral disk names\"\n  ephemeralDatastores: [String]\n  \"Unique identifier for the config\"\n  guid: String\n  \"The name of the config\"\n  name: String\n}\ntype Entity_Tanzu_TAS_VcenterConfig_Query {\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:Tanzu.TAS.VcenterConfig:read`\n  \"\"\"\n  query(\n    \"node-compatible endCursor from previous query, to select next page\"\n    after: String,\n    \"filter by entityId\"\n    entityId: [EntityId!],\n    \"filter by entityName\"\n    entityName: [String!],\n    \"Filter by an arbitrary QueryFilter\"\n    filter: QueryFilter,\n    \"node-compatible page size\"\n    first: Int = 10,\n    \"Sort results by one or more fields\"\n    sort: [QuerySort!]\n  ): Entity_Tanzu_TAS_VcenterConfigConnection\n}\ntype Entity_Tanzu_TAS_VcenterConfig_RelIn {\n  contains: Entity_Tanzu_TAS_VcenterConfig_Contains_RelIn\n}\ntype Entity_Tanzu_TAS_VcenterConfig_Type implements EntityTypedInterface & Node & NodeVersion {\n  \"a link to the generic Entity node\"\n  entity: Entity!\n  \"Unique identifier for an entity in a canonical form. Uniqueness is global.\"\n  entityId: EntityId!\n  \"human-readable name of the entity. May be mutable and non-unique.\"\n  entityName: String\n  \"EntityType of the entity. e.g. `ec2`, `security-group` etc. Required but not enforced\"\n  entityType: String\n  \"Opaque global ID\"\n  id: ID!\n  \"Versioning ID\"\n  nodeVersion: ID!\n  properties: Entity_Tanzu_TAS_VcenterConfig_Properties\n  relationshipsIn: Entity_Tanzu_TAS_VcenterConfig_RelIn\n  \"Key/Value tags for this entity, optionally filtered by key\"\n  tags(\n    \"Filter tags by key\"\n    key: [String!]\n  ): [Tag!]\n}\ntype Entity_Tanzu_Type {\n  platform: Entity_Tanzu_Platform_Type\n  spring: Entity_Tanzu_Spring_Type\n  tas: Entity_Tanzu_TAS_Type\n}\ntype EventAttribute {\n  \"Attribute name\"\n  key: String\n  \"Attribute value\"\n  value: String\n}\ntype EventConnection implements Connection {\n  \"Count of resources on this page\"\n  count: Int!\n  \"Relay-compatible edges on this page\"\n  edges: [EventEdge!]\n  \"Query results on this page\"\n  eventRecords: [EventRecord!]\n  \"Relay-compatible page info\"\n  pageInfo: PageInfo!\n  \"Information about the query task execution\"\n  taskInfo: LogTaskInfo\n  \"Optional total elements count across all pages when available\"\n  totalCount: Int\n}\ntype EventEdge implements ConnectionEdge {\n  \"Cursor info of the event\"\n  cursor: String\n  \"Event record\"\n  node: EventRecord!\n}\ntype EventGroupConnection implements Connection {\n  \"Count of resources on this page\"\n  count: Int!\n  \"Relay-compatible edges on this page\"\n  edges: [EventGroupEdge!]\n  \"Query results on this page\"\n  eventGroupRecords: [EventGroupRecord!]\n  \"Relay-compatible page info\"\n  pageInfo: PageInfo!\n  \"Information about the query task execution\"\n  taskInfo: LogTaskInfo\n  \"Optional total elements count across all pages when available\"\n  totalCount: Int\n}\ntype EventGroupEdge implements ConnectionEdge {\n  \"Cursor info of the event\"\n  cursor: String\n  \"Event group record\"\n  node: EventGroupRecord!\n}\ntype EventGroupRecord implements Node {\n  \"Category of the event group\"\n  category: String!\n  \"Id of the event group\"\n  id: ID!\n  \"Event message\"\n  message: String!\n  \"Total occurrences of the event\"\n  occurrences: Long!\n  \"Recent occurrence of the event\"\n  recentOccurrence: DateTime!\n  \"Severity of the event group\"\n  severity: String!\n  \"Type of the event\"\n  type: String!\n}\ntype EventRecord implements Node {\n  \"Attributes of the event\"\n  attributes: [EventAttribute!]\n  \"Timestamp of the event\"\n  eventTime: Long!\n  \"Id of the event\"\n  id: ID!\n  \"Event message\"\n  message: String!\n  \"Severity of the event\"\n  severity: String!\n  \"Source of the event\"\n  source: String!\n  \"Type of the event\"\n  type: String!\n  \"User who triggered the event\"\n  user: String!\n}\ntype EventStats {\n  \"Count of events\"\n  count: Long!\n  \"Timestamp\"\n  timestamp: DateTime!\n}\ntype EventStatsConnection implements Connection {\n  \"Count of resources on this page\"\n  count: Int!\n  \"Relay-compatible edges on this page\"\n  edges: [EventStatsEdge!]\n  \"Query results on this page\"\n  eventStatRecords: [EventStatsRecord!]\n  \"Relay-compatible page info\"\n  pageInfo: PageInfo!\n  \"Information about the query task execution\"\n  taskInfo: LogTaskInfo\n  \"Optional total elements count across all pages when available\"\n  totalCount: Int\n}\ntype EventStatsEdge implements ConnectionEdge {\n  \"Cursor info of the record\"\n  cursor: String!\n  \"Event stat record\"\n  node: EventStatsRecord!\n}\ntype EventStatsRecord implements Node {\n  \"Id of the event group\"\n  id: ID!\n  \"Stats of the event\"\n  stats: [EventStats]!\n  \"Type of the event\"\n  type: String!\n}\ntype EventsNotificationRule implements Node & NodeVersion & NotificationRule {\n  \"User who created the notification rule\"\n  createdBy: User\n  \"Creation time of the notification rule\"\n  creationTime: DateTime!\n  \"List of email addresses the notifications of this rule needs to be delivered to. Should be provided when notification target type is EMAIL\"\n  emailAddresses: [String!]\n  \"Enabled turns the notification rule on/off\"\n  enabled: Boolean!\n  \"The type of the event\"\n  eventType: EventsEventType!\n  \"Opaque global ID\"\n  id: ID!\n  \"\"\"\n  A [jsonata](https://docs.jsonata.org/overview.html) predicate to filter events based on their payload. The event is only sent to\n  the subscriber if this expression evaluates to `true`, otherwise it is skipped\n  \"\"\"\n  jsonataExpression: String\n  \"Last update time of the notification rule\"\n  lastUpdateTime: DateTime!\n  \"Name of the notification rule\"\n  name: String!\n  \"Versioning ID\"\n  nodeVersion: ID!\n  \"ID of the notification rule\"\n  notificationRuleId: String!\n  \"List of notification targets that this notification needs to be delivered\"\n  notificationTargets: [AriaNotificationTarget!]\n  \"Provider name of the notification rule\"\n  provider: String!\n}\ntype EventsNotificationRuleConnection implements Connection & NotificationRuleConnection {\n  \"Count of elements in the current page\"\n  count: Int!\n  \"Edges to nodes available through the connection\"\n  edges: [EventsNotificationRuleConnectionEdge!]\n  notificationRules: [EventsNotificationRule!]\n  \"Paging support\"\n  pageInfo: PageInfo!\n  \"Optional total elements count across all pages when available\"\n  totalCount: Int\n}\ntype EventsNotificationRuleConnectionEdge implements ConnectionEdge & NotificationRuleConnectionEdge {\n  \"Optional cursor to refer to this node\"\n  cursor: String\n  \"Node element available through this edge\"\n  node: EventsNotificationRule!\n}\ntype EventsNotificationRuleMutationProvider implements NotificationRulesMutationProvider {\n  \"\"\"\n  Delete a notification rule\n  ### API Permissions:\n  - `notification:Rule-Events:delete`\n  \"\"\"\n  deleteEventNotificationRule(notificationRuleId: String!): EventsNotificationRule\n  \"Information about this provider\"\n  name: String\n  \"\"\"\n  create/update a notification rule\n  ### API Permissions:\n  - `notification:Rule-Events:create`,\n  - `notification:Rule-Events:update`,\n  - `notification:Target-Platform:read`\n  \"\"\"\n  upsertEventNotificationRule(ruleInput: EventsNotificationRuleInput!): EventsNotificationRule\n}\ntype ExceptionConnection implements Connection {\n  count: Int!\n  edges: [ExceptionEdge!]\n  exceptionRecords: [ExceptionRecord!]\n  pageInfo: PageInfo!\n  taskInfo: LogTaskInfo\n  totalCount: Int\n}\ntype ExceptionEdge implements ConnectionEdge {\n  cursor: String!\n  node: ExceptionRecord!\n}\ntype ExceptionField {\n  key: String!\n  value: String!\n}\ntype ExceptionFrame {\n  className: String\n  \" frame: String\"\n  line: String\n  method: String\n}\ntype ExceptionGroupConnection implements Connection {\n  count: Int!\n  edges: [ExceptionGroupEdge!]\n  exceptionGroupRecords: [ExceptionGroupRecord!]\n  pageInfo: PageInfo!\n  taskInfo: LogTaskInfo\n  totalCount: Int\n}\ntype ExceptionGroupEdge implements ConnectionEdge {\n  cursor: String!\n  node: ExceptionGroupRecord!\n}\ntype ExceptionGroupRecord implements Node {\n  application: String\n  class: String\n  fingerprint: String\n  id: ID!\n  line: String\n  message: String\n  method: String\n  name: String\n  occurrences: String\n  recentOccurrence: DateTime\n  trace: [ExceptionTrace]\n}\ntype ExceptionRecord implements Node {\n  fields: [ExceptionField!]\n  id: ID!\n}\ntype ExceptionStats {\n  count: Int\n  timestamp: DateTime\n}\ntype ExceptionStatsRecord {\n  fingerprint: String\n  stats: [ExceptionStats]\n}\ntype ExceptionStatsResponse {\n  exceptionStats: [ExceptionStatsRecord]\n  taskInfo: LogTaskInfo\n}\ntype ExceptionTrace {\n  frames: [ExceptionFrame]\n  message: String\n}\ntype ExceptionTrendRecord {\n  application: String\n  base: ExceptionTrendRecordStats\n  class: String\n  current: ExceptionTrendRecordStats\n  fingerprint: String\n  line: String\n  message: String\n  method: String\n  name: String\n  trace: [ExceptionTrace]\n  trend: Float\n}\ntype ExceptionTrendRecordStats {\n  count: Int\n  rate: Float\n}\ntype ExceptionTrendResponse {\n  exceptionTrends: [ExceptionTrendRecord]\n  taskInfo: LogTaskInfo\n}\n\"Represents a base template for fleet management.\"\ntype FleetBaseTemplate {\n  \"The name of the component\"\n  name: String!\n  \"The raw YAML content of the template.\"\n  properties: String!\n  \"The component type.\"\n  type: String!\n  \"The version of the base template.\"\n  version: String!\n}\n\"Represents a fleet component.\"\ntype FleetComponent implements Node {\n  \"The category of the component.\"\n  category: String!\n  \"The description of the schema.\"\n  description: String!\n  id: ID!\n  \"The name of the schema.\"\n  name: String!\n  \"The JSON content of the schema.\"\n  schemaContent: FleetManagementJsonScalar!\n  \"The type of the schema.\"\n  type: String!\n  \"The version of the schema.\"\n  version: String!\n}\n\"An edge in a connection to a list of fleet schemas.\"\ntype FleetComponentEdge implements ConnectionEdge {\n  \"Optional cursor to refer to this node.\"\n  cursor: String!\n  \"Node element available through this edge.\"\n  node: FleetComponent!\n}\n\"Simple validation result for a specific component field.\"\ntype FleetComponentValueResult {\n  \"Error message (if validation failed or has warnings).\"\n  error: String\n  \"The name of the field that was validated.\"\n  fieldName: String!\n  \"The validation status: SUCCESS, WARNING, or ERROR.\"\n  status: String!\n}\n\"Result of component value validation.\"\ntype FleetComponentValueValidationResult {\n  \"The type of the component that was validated.\"\n  componentType: String!\n  \"List of validation errors (if any).\"\n  errors: [String!]\n  \"Message providing details about the validation result.\"\n  message: String!\n  \"The final status of the validation (COMPLETED, FAILED, WARNING).\"\n  status: String!\n  \"The validated component payload (if validation succeeded).\"\n  validatedPayload: JsonNodeScalar\n  \"Detailed validation results for individual component values.\"\n  valueResults: [FleetComponentValueResult!]\n}\ntype FleetConfigResource {\n  description: String\n  identifier: String\n  instance_type_best_fit: String\n  instance_type_id: String\n  instances: String\n  instances_best_fit: Int\n  persistent_disk_best_fit: Int\n  persistent_disk_mb: Int\n  persistent_disk_name: String\n}\n\"Represents status of installation request.\"\ntype FleetManagementInstallationResponse {\n  \"The ID of the installation.\"\n  installationId: String!\n  \"The current status of the installation.\"\n  status: FleetManagementInstallationStatus!\n}\ntype FleetManagementMutation {\n  \"\"\"\n  Provide capability to auto attach the foundation.\n  ### API Permissions:\n  - `fleet:Foundation:create`\n  \"\"\"\n  autoAttachFoundation(managementEndpointId: String!): FleetManagementInstallationResponse\n  \"Provides access to mutations for managing fleet templates.\"\n  fleetTemplateManagementMutation: FleetTemplateManagementMutation!\n}\ntype FleetManagementQuery {\n  fleetTemplateManagementQuery: FleetTemplateManagementQuery!\n  \"\"\"\n  Query Collector Config resources.\n  ### API Permissions:\n  - `managementEndpoint:ManagementEndpoint-*:read`\n  \"\"\"\n  queryOpsManConfigResource(tileName: String!): FleetOpsManConfigResourceResponse\n  \"\"\"\n   Query OpsMan Configurations\n  ### API Permissions:\n  - `managementEndpoint:ManagementEndpoint-*:read`\n  \"\"\"\n  queryOpsManConfigurations(managementEndpointId: String!): FleetOpsManConfigResponse\n}\ntype FleetOpsManConfigNetwork {\n  availabilityZones: [String]\n  network: String!\n}\ntype FleetOpsManConfigResourceResponse {\n  configResource: [FleetConfigResource!]\n}\ntype FleetOpsManConfigResponse {\n  networks: [FleetOpsManConfigNetwork!]\n}\n\"Represents a fleet template.\"\ntype FleetTemplate implements Node {\n  \"The JSON content of the components in the template.\"\n  components: FleetManagementJsonScalar!\n  \"The timestamp when the template was created.\"\n  createdAt: DateTime!\n  \"The user who created the template.\"\n  createdBy: User\n  \"The OAuth application that created the template.\"\n  createdByOAuthApp: OAuthApp\n  \"The description of the template.\"\n  description: String\n  id: ID!\n  \"The timestamp when the template was last updated.\"\n  lastUpdatedAt: DateTime!\n  \"The name of the template.\"\n  name: String!\n  \"Indicates if the template is read-only and cannot be modified.\"\n  readOnly: Boolean!\n  \"The unique identifier of the template.\"\n  templateId: String!\n  \"The UI schema content for rendering the template form.\"\n  uiSchema: FleetManagementJsonScalar\n}\n\"A connection to a list of fleet templates.\"\ntype FleetTemplateConnection implements Connection {\n  \"The number of elements in the current page.\"\n  count: Int!\n  \"A list of edges to nodes available through the connection.\"\n  edges: [FleetTemplateEdge!]\n  \"Information to aid in pagination.\"\n  pageInfo: PageInfo!\n  \"A list of templates present in this page.\"\n  templates: [FleetTemplate!]\n  \"The total number of elements across all pages, if available.\"\n  totalCount: Int\n}\n\"\"\"\nDynamic Data Query returns FleetTemplateDynamicData containing\nthe component type and data having values fors the dynamic fields\n\"\"\"\ntype FleetTemplateDynamicData {\n  componentType: String!\n  data: JsonNodeScalar\n}\n\"An edge in a connection to a list of fleet templates.\"\ntype FleetTemplateEdge implements ConnectionEdge {\n  \"A cursor for use in pagination.\"\n  cursor: String!\n  \"The node element available through this edge.\"\n  node: FleetTemplate!\n}\n\"Represents a single execution of a fleet template.\"\ntype FleetTemplateExecution implements Node {\n  components: FleetManagementJsonScalar!\n  createdAt: DateTime!\n  createdBy: User\n  createdByOAuthApp: OAuthApp\n  \"Any error message associated with the execution, if an error occurred.\"\n  error: String\n  \"The unique identifier of the execution.\"\n  executionId: String!\n  id: ID!\n  \"The status of the execution.\"\n  status: FleetTemplateExecutionStatusEnum!\n  \"The unique identifier of the underlying Temporal workflow.\"\n  workflowId: String\n}\n\"A connection to a list of fleet template executions.\"\ntype FleetTemplateExecutionConnection implements Connection {\n  \"The number of elements in the current page.\"\n  count: Int!\n  \"A list of edges to nodes available through the connection.\"\n  edges: [FleetTemplateExecutionEdge!]\n  \"A list of executions present in this page.\"\n  executions: [FleetTemplateExecution!]\n  \"Information to aid in pagination.\"\n  pageInfo: PageInfo!\n  \"The total number of elements across all pages, if available.\"\n  totalCount: Int\n}\n\"The result of a create fleet template execution mutation.\"\ntype FleetTemplateExecutionCreateResult {\n  \"The newly created fleet template execution. Null if the mutation failed.\"\n  fleetTemplateExecution: FleetTemplateExecution\n  \"The status of the mutation.\"\n  status: FleetTemplateMutationResultStatus!\n}\n\"An edge in a connection to a list of fleet template executions.\"\ntype FleetTemplateExecutionEdge implements ConnectionEdge {\n  \"A cursor for use in pagination.\"\n  cursor: String!\n  \"The node element available through this edge.\"\n  node: FleetTemplateExecution!\n}\n\"Mutations for creating, updating, and deleting fleet templates and creating fleet template executions.\"\ntype FleetTemplateManagementMutation {\n  \"\"\"\n  Creates a new execution for a given fleet template.\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `fleet:FleetTemplateExecution:create`\n  \"\"\"\n  createTemplateExecution(input: FleetTemplateExecutionCreateInput!): FleetTemplateExecutionCreateResult!\n  \"\"\"\n  Deletes one or more fleet templates by their IDs.\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `fleet:FleetTemplate:delete`\n  \"\"\"\n  delete(templateIds: [String!]!): [FleetTemplateMutationResult!]!\n  \"\"\"\n  Updates one or more existing fleet templates. Only the changed fields need to be submitted in the input (i.e. a PATCH operation).\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `fleet:FleetTemplate:update`\n  \"\"\"\n  update(inputs: [FleetTemplateUpdateInput!]!): [FleetTemplateMutationResult!]!\n  \"\"\"\n  Validates component values for a specific component type and configuration.\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `fleet:FleetTemplateExecution:read`\n  \"\"\"\n  validateComponentValue(input: FleetComponentValueValidationInput!): FleetComponentValueValidationResult!\n}\n\"Queries for Fleet Templates.\"\ntype FleetTemplateManagementQuery {\n  \"\"\"\n  Query values for the UI form dynamic fields\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `fleet:FleetTemplateExecution:read`\n  \"\"\"\n  queryDynamicData(componentType: String!, context: JsonNodeScalar, version: String): FleetTemplateDynamicData\n  \"\"\"\n  Queries for base fleet templates by type and version.\n  If version is not specified, response will contain the latest version of the base template.\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `fleet:FleetBaseTemplate:read`\n  \"\"\"\n  queryFleetBaseTemplate(type: String!, version: String): FleetBaseTemplate!\n  \"\"\"\n  Queries for fleet schemas with optional filtering.\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `fleet:FleetTemplateSchema:read`\n  \"\"\"\n  queryFleetComponent(type: [String!], version: String): FleetComponent!\n  \"\"\"\n  Queries for fleet template executions with optional filtering by fleet template ID and type.\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `fleet:FleetTemplateExecution:read`\n  \"\"\"\n  queryFleetTemplateExecutions(after: String, first: Int = 10, fleetTemplateId: [String!]!, status: [FleetTemplateExecutionStatusEnum!]): FleetTemplateExecutionConnection\n  \"\"\"\n  Queries for fleet templates with optional filtering by ID, name, readonly status, and search term.\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `fleet:FleetTemplate:read`\n  \"\"\"\n  queryFleetTemplates(after: String, first: Int = 10, fleetTemplateId: [String!], name: [String!], readOnly: Boolean, searchTerm: String): FleetTemplateConnection!\n}\n\"Represents the result of a mutation on a fleet template.\"\ntype FleetTemplateMutationResult {\n  \"The fleet template object that was mutated. May be null if the mutation failed.\"\n  fleetTemplate: FleetTemplate\n  \"The status of the mutation operation.\"\n  status: FleetTemplateMutationResultStatus!\n  \"The unique identifier of the template.\"\n  templateId: String\n}\n\"Represents the status of a fleet template mutation.\"\ntype FleetTemplateMutationResultStatus {\n  \"An error message if the mutation failed. Null otherwise.\"\n  errorMessage: String\n  \"The outcome of the mutation (SUCCESS or ERROR).\"\n  status: FleetManagementMutationResultStatusEnum!\n}\ntype GroupFoundationGroup {\n  \"Optional description of the Foundation group\"\n  description: String\n  \"Foundation Group Entity\"\n  foundationGroupEntity: Entity\n  \"Entity Id of the Foundation Group\"\n  foundationGroupId: EntityId\n  \"Name of the Foundation group. The name of the foundation group is unique.\"\n  name: String\n}\ntype GroupFoundationGroupMutation {\n  \"\"\"\n  Assigns foundation management endpoints to foundation groups in bulk.\n  This operation delinks the foundation organizations and spaces from the group resources in the current foundation group\n  and creates associations between foundations and foundation groups\n  by updating the scoping entities of the management endpoints.\n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  ### API Permissions:\n  \"\"\"\n  assignFoundationToGroup(input: [GroupAssignFoundationToGroupInput!]!): [GroupFoundationGroupMutationResult!]!\n  \"\"\"\n  Creates FoundationGroups in batches. The result for each create operation is returned in the response.\n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  ### API Permissions:\n  - `entity:Tanzu.Platform.FoundationGroup:create`\n  \"\"\"\n  create(input: [GroupFoundationGroupCreateInput!]!): [GroupFoundationGroupMutationResult!]!\n  \"\"\"\n  Deletes FoundationGroups by ids. The result for each delete operation is returned in the response.\n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  ### API Permissions:\n  - `entity:Tanzu.Platform.FoundationGroup:delete`\n  \"\"\"\n  delete(foundationGroupId: [EntityId!]!): [GroupFoundationGroupMutationResult!]!\n  \"\"\"\n  Updates FoundationGroups in batches. The result for each create operation is returned in the response.\n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  ### API Permissions:\n  - `entity:Tanzu.Platform.FoundationGroup:update`\n  \"\"\"\n  update(input: [GroupFoundationGroupUpdateInput!]!): [GroupFoundationGroupMutationResult!]!\n}\ntype GroupFoundationGroupMutationResult {\n  \"The Foundation Group that was created or on which the mutation was performed\"\n  foundationGroup: GroupFoundationGroup\n  \"Status of the create operation\"\n  status: GroupFoundationGroupMutationResultStatus!\n}\ntype GroupFoundationGroupMutationResultStatus {\n  errorMessage: String\n  status: GroupFoundationGroupMutationResultStatusEnum!\n}\n\"Mutation for performing create, update and delete operations on grouping constructs such as Foundation Group\"\ntype GroupMutation {\n  \"\"\"\n  Mutation for Foundation Groups management\n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  \"\"\"\n  foundationGroupMutation: GroupFoundationGroupMutation\n  \"\"\"\n  Mutation for Organization Groups management\n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  \"\"\"\n  organizationGroupMutation: GroupOrganizationGroupMutation\n  \"\"\"\n  Mutation for Space Groups management\n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  \"\"\"\n  spaceGroupMutation: GroupSpaceGroupMutation\n}\ntype GroupOrganizationGroup {\n  \"Optional description of the Organization group\"\n  description: String\n  \"Name of the Organization group. The name of the organization group is unique.\"\n  name: String\n  \"Organization Group Entity\"\n  organizationGroupEntity: Entity\n  \"Entity Id of the Organization Group\"\n  organizationGroupId: EntityId\n}\ntype GroupOrganizationGroupMutation {\n  \"\"\"\n  Creates OrganizationGroups in batches. The result for each create operation is returned in the response.\n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  ### API Permissions:\n  - `entity:Tanzu.Platform.OrganizationGroup:create`\n  \"\"\"\n  create(input: [GroupOrganizationGroupCreateInput!]!): [GroupOrganizationGroupMutationResult!]!\n  \"\"\"\n  Deletes OrganizationGroups by IDs. The result for each delete operation is returned in the response.\n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  ### API Permissions:\n  - `entity:Tanzu.Platform.OrganizationGroup:delete`\n  \"\"\"\n  delete(organizationGroupId: [EntityId!]!): [GroupOrganizationGroupMutationResult!]!\n}\ntype GroupOrganizationGroupMutationResult {\n  \"The Organization Group on which the mutation was performed\"\n  organizationGroup: GroupOrganizationGroup\n  \"Status of the mutation operation\"\n  status: GroupOrganizationGroupMutationResultStatus!\n}\ntype GroupOrganizationGroupMutationResultStatus {\n  errorMessage: String\n  status: GroupOrganizationGroupMutationResultStatusEnum!\n}\ntype GroupSpaceGroup {\n  \"Optional description of the Space group\"\n  description: String\n  \"Name of the Space group. The name of the space group is unique.\"\n  name: String\n  \"Entity Id of the organization group\"\n  organizationGroupId: EntityId\n  \"Space Group Entity\"\n  spaceGroupEntity: Entity\n  \"Entity Id of the Space Group\"\n  spaceGroupId: EntityId\n}\ntype GroupSpaceGroupMutation {\n  \"\"\"\n  Creates SpaceGroups in batches. The result for each create operation is returned in the response.\n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  ### API Permissions:\n  - `entity:Tanzu.Platform.SpaceGroup:create`\n  \"\"\"\n  create(input: [GroupSpaceGroupCreateInput!]!): [GroupSpaceGroupMutationResult!]!\n  \"\"\"\n  Deletes SpaceGroups by ids. The result for each delete operation is returned in the response.\n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  ### API Permissions:\n  - `entity:Tanzu.Platform.SpaceGroup:delete`\n  \"\"\"\n  delete(spaceGroupId: [EntityId!]!): [GroupSpaceGroupMutationResult!]!\n}\ntype GroupSpaceGroupMutationResult {\n  \"The Space Group that was created or on which the mutation was performed\"\n  spaceGroup: GroupSpaceGroup\n  \"Status of the create operation\"\n  status: GroupSpaceGroupMutationResultStatus!\n}\ntype GroupSpaceGroupMutationResultStatus {\n  errorMessage: String\n  status: GroupSpaceGroupMutationResultStatusEnum!\n}\ntype HubArtifactSBOMInfoConnection implements ArtifactSBOMConnection & Connection {\n  \"List artifact SBOM(s).\"\n  artifactSBOMs: [HubArtifactSbomInfo!]\n  \"count of Packages on this page\"\n  count: Int!\n  \"relay-compatible Package edges\"\n  edges: [HubArtifactSBOMInfoEdge!]\n  \"relay-compatible page info\"\n  pageInfo: PageInfo!\n  \"Total count of Packages, may not always be an exact number and hence consumers should not rely only on this\"\n  totalCount: Int\n}\ntype HubArtifactSBOMInfoEdge implements ArtifactSBOMEdge & ConnectionEdge {\n  \"Cursor is an opaque string, you can use it to request subsequent or preceding items in the list\"\n  cursor: String!\n  \"Package node\"\n  node: HubArtifactSbomInfo!\n}\ntype HubArtifactSbomInfo implements ArtifactSBOM & Node {\n  \"\"\"\n  Domain-specific artifact sbom identifier\n  unique identifier for a package, may be hash value or checksum generated from the package's content\n  \"\"\"\n  artifactSBOMId: String!\n  \"Connection packages used by this Package (transitive dependecies)\"\n  dependencies(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Input filters to filter Package Dependencies\"\n    filter: QueryFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"filter by package name and versions\"\n    sbomFilter: HubArtifactSBOMFilterInput\n  ): ArtifactSBOMConnection!\n  \"Global opaque identifier to meet Node contract\"\n  id: ID!\n  \"\"\"\n  license is determined by the SPDX document creator (which is often an SBOM tool or the document creator in the case of disjunctive licenses)\n  refer : https://fossa.com/blog/understanding-using-spdx-license-identifiers-license-expressions\n  \"\"\"\n  licenseConcluded: String\n  \"\"\"\n  license is stated by the component (e.g. package or file) author\n  refer : https://fossa.com/blog/understanding-using-spdx-license-identifiers-license-expressions\n  \"\"\"\n  licenseDeclared: String\n  \"Name of the package\"\n  name: String!\n  \"\"\"\n  Package URL - standardized format for representing package metadata.\n  Eg. pkg:rpm/fedora/curl@7.50.3-1.fc25?arch=i386&distro=fedora-25 , pkg:pypi/django@1.11.1\n  Refer : https://github.com/package-url/purl-spec , https://github.com/package-url/purl-spec/blob/master/PURL-SPECIFICATION.rst\n  \"\"\"\n  packageUrl: String!\n  \"Version of the package\"\n  version: String!\n  \"\"\"\n  Connection of potential vulnerabilities detected for a Package.\n  The vulnerabilities will be aggregated from dependent packages to this package\n  \"\"\"\n  vulnerabilities(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Input filters to filter Vulnerabilities\"\n    filter: QueryFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"filter by CVE_ID, severity and score\"\n    vulnerabilityFilter: HubArtifactVulnerabilityFilterInput\n  ): ArtifactVulnerabilityConnection\n}\ntype HubArtifactTraits {\n  \"List of SBOMs associated with this entity\"\n  queryArtifactSBOM(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,sbomFilter: HubArtifactSBOMFilterInput  ): HubArtifactSBOMInfoConnection!\n  \"\"\"\n  List of vulnerabilities associated with this entity\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `springassessment:Assessment:read`\n  \"\"\"\n  queryArtifactVulnerability(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Input filters to filter Vulnerabilities\"\n    vulnerabilityFilter: HubArtifactVulnerabilityFilterInput\n  ): HubArtifactVulnerabilityConnection!\n}\ntype HubArtifactVulnerability implements ArtifactVulnerability & Node {\n  \"\"\"\n  Details of Packages affected by this vulnerability. This will return packages for this vulnerability is detected.\n  If vulnerabilities are queried in context then this will return packages for the entity where the vulnerability is detected\n  If vulnerabilities are not queries in context of an entity, this will return all packages within where the vulnerability is detected\n  \"\"\"\n  affectedPackages: [ArtifactVulnerabilityDetectionInfo!]\n  \"Artifact name affected by this CVE\"\n  artifactName: String\n  \"Domain-specific artifact vulnerability instance identifier - CVE_ID\"\n  artifactVulnerabilityId: String!\n  \"CVE Numbering Authority\"\n  cna: String\n  \"CVE description\"\n  description: String!\n  \"Global opaque identifier to meet Node contract\"\n  id: ID!\n  \"A set of links that provide additional context and information about the vulnerability.\"\n  link: [String]\n  \"CVE name\"\n  name: String!\n  \"Patch version status\"\n  patchStatus: ArtifactVulnerabilityLatestPatchVersionStatus\n  \"\"\"\n  Date on which vulnerability is published, e.g. Expressed in UTC ISO-8601 format \"2022-11-22T02:15:00Z\"\n  \"\"\"\n  publishedDate: DateTime!\n  \"CVSS score\"\n  scores: [ArtifactVulnerabilityScore!]\n  \"Threat level of vulnerability. Will accept values CRITICAL, HIGH, MEDIUM, LOW, NONE.\"\n  severity: String\n  \"CVE summary\"\n  summary: String\n  \"Triage status of the vulnerability\"\n  triage: ArtifactVulnerabilityTriageStatus\n  \"\"\"\n  Optional Date on which the vulnerability was reassessed/updated, e.g. Expressed in UTC ISO-8601 format \"2022-11-22T02:15:00Z\"\n  \"\"\"\n  updatedDate: DateTime\n  \"\"\"\n  The url associated with the vulnerability.\n  If coming from a scanning engine, this commonly points to a website from the scanning engine vendor.\n  \"\"\"\n  url: String\n}\ntype HubArtifactVulnerabilityConnection implements ArtifactVulnerabilityConnection & Connection {\n  \"Vulnerabilities instances\"\n  artifactVulnerabilities: [HubArtifactVulnerability!]\n  \"Count of Vulnerabilities on this page\"\n  count: Int!\n  \"Relay-compatible Vulnerability edges\"\n  edges: [HubArtifactVulnerabilityEdge!]\n  \"Relay-compatible page info\"\n  pageInfo: PageInfo!\n  \"Total count of Vulnerabilities, may not always be an exact number and hence consumers should not rely only on this\"\n  totalCount: Int\n}\ntype HubArtifactVulnerabilityDetectionInfo implements ArtifactVulnerabilityDetectionInfo {\n  \"Version of package where the issue is fixed\"\n  fixVersion: [String!]\n  \"Package on which the vulnerability is detected\"\n  package: HubArtifactSbomInfo!\n  \"Fixed , affected, will_not_fix or any other status \"\n  status: String\n}\ntype HubArtifactVulnerabilityEdge implements ArtifactVulnerabilityEdge & ConnectionEdge {\n  \"Cursor is an opaque string, you can use it to request subsequent or preceding items in the list\"\n  cursor: String!\n  \"Vulnerability node\"\n  node: HubArtifactVulnerability!\n}\ntype HubPolicyMutationProviders {\n  tanzu: TanzuHubPolicyMutationProvider!\n  observabilityAlert: ObservabilityAlertMutationProvider!\n}\ntype HubPolicyProviderInfo {\n  \"name of provider\"\n  name: String!\n}\ntype HubPolicyQueryProviders {\n  tanzu: TanzuHubPolicyQueryProvider!\n  observabilityAlert: ObservabilityAlertQueryProvider\n}\n\"\"\"\nTanzu Hub Query Language is derived from Secure State Query Language (SSQL) and allows the user to search and query the graph model.\n\nUntil this has specific documentation please see: https://docs.vmware.com/en/CloudHealth-Secure-State/services/chss-usage/GUID-explore-ssql.html\n\"\"\"\ntype HubQuery {\n  \"\"\"\n  Provide autocompletion for an Tanzu Hub Graph query string\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `platform:HubQuery:read`\n  \"\"\"\n  autocomplete(\n    \"Max responses per category\"\n    limitPerCategory: Int = 20,\n    \"Optional management endpoint IDs to limit query scope.\"\n    managementEndpointIds: [String!],\n    \"Optional providers to limit query scope\"\n    providers: [String!],\n    \"Tanzu Hub Graph Query string to autocomplete\"\n    query: String!\n  ): HubQueryAutocompleteResponse!\n  \"\"\"\n  Run a Tanzu Hub query\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `platform:HubQuery:read`\n  \"\"\"\n  query(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Return first N records in a paged response, as per GraphQL Relay spec. Only applied to LIST queries (not graphs)\"\n    first: Int = 10,\n    \"Optional management endpoint IDs to limit query scope.\"\n    managementEndpointIds: [String!],\n    \"Optional providers to limit query scope\"\n    providers: [String!],\n    \"Query string\"\n    query: String!,\n    \"Sort field for LIST results, default is by entityId\"\n    sort: QuerySort,\n    \"Optional traversalScope for performance, defaults to ANY_PARTITION\"\n    traversalScope: EntityTraversalScope = ANY_PARTITION,\n    \"For graph queries (with relationship traversals), generate full GRAPH (default) or set to false to use graph traversals as filters and only return initial entities\"\n    tree: Boolean\n  ): HubQueryResponse!\n  \"\"\"\n  Validate and translate a given Tanzu Hub Graph query string to GraphQL\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  \"\"\"\n  translate(\n    \"Optional management endpoint IDs to limit query scope.\"\n    managementEndpointIds: [String!],\n    \"Optional providers to limit query scope\"\n    providers: [String!],\n    \"Input query\"\n    query: String!,\n    \"Optional traversalScope for performance, defaults to ANY_PARTITION\"\n    traversalScope: EntityTraversalScope = ANY_PARTITION,\n    \"For graph queries (with relationship traversals), generate full GRAPH (default) or set to false to use graph traversals as filters and only return initial entities\"\n    tree: Boolean\n  ): HubQueryTranslation!\n}\ntype HubQueryAutocompleteResponse {\n  \"Autocompletion categories with their completions\"\n  categories: [HubQueryAutocompletionCategory!]\n  \"Completions, if any, occur after this part of the query\"\n  completionAfter: String!\n  \"If the query is invalid, error information\"\n  errorInfo: [HubQueryErrorInfo!]\n  \"query validity\"\n  isValid: Boolean!\n  \"Original query for autocompletion\"\n  query: String!\n}\ntype HubQueryAutocompletionCategory {\n  category: HubQueryAutocompletionCategoryName!\n  \"Possible autocompletions\"\n  completions: [String!]!\n}\ntype HubQueryErrorInfo {\n  \"When available, column where error occurred\"\n  errorColumn: Int\n  \"When available, line where error occurred\"\n  errorLine: Int\n  \"A localized error message describing the error\"\n  errorMessage: LocalizedString!\n  \"When available, text fragment where error occurred\"\n  errorText: String\n}\ntype HubQueryResponse {\n  \"Results of an AggregationQuery\"\n  entityAggregations: EntityAggregations\n  \"paged list of Entities\"\n  entityConnection: EntityConnection\n  \"\"\"\n  If the hub query contained one or more relationships (->) then the results may be in a tree.\n  \n  This field provides an alternative JSON representation of the entityTree\n  \"\"\"\n  entityTreeJSON: JSON\n  \"\"\"\n  If the bub query contained one or more relationships (->) then the results may be in a tree.\n  This field represents the individual nodes in the tree. Each node has an Entity or Relationship ID, a type, and\n  a list of child nodes.\n  The entity and relationship instances in the tree are found in the entityConnection and relationshipConnection fields.\n  \"\"\"\n  entityTreeNodes: [EntityTreeNode!]\n  \"\"\"\n  If the hub query contained one or more relationships (->) then the results may be in a tree.\n  This field represents the entityIds of all the starting points into the tree.\n  The entity and relationship instances in the tree are found in the entityConnection and relationshipConnection fields.\n  \"\"\"\n  entityTreeRoots: [EntityId!]\n  \"If the query was invalid, error information\"\n  errorInfo: [HubQueryErrorInfo!]\n  \"generated GraphQL query\"\n  graphqlQuery: String!\n  \"generated GraphQL query broken into lines, this is helpful for readability in a GraphQL interface\"\n  graphqlQueryLines: [String!]\n  \"Original query\"\n  query: String!\n  \"query type determined from input query\"\n  queryType: HubQueryType\n  \"optional paged list of EntityRelationships\"\n  relationshipConnection: EntityRelationshipConnection\n  \"Information on entity types and fields that are triggered by the query\"\n  triggers: [HubQueryTrigger!]\n}\ntype HubQueryTranslation {\n  \"If query is invalid, provides error information\"\n  errorInfo: [HubQueryErrorInfo!]\n  \"If the query is valid, this is its translation into GraphQL\"\n  graphqlQuery: String\n  \"generated GraphQL broken into lines, the field is intended for readability in a GraphQL interface\"\n  graphqlQueryLines: [String!]\n  \"when false, only errorInfo and timestamp field are guaranteed to be initialized\"\n  isValid: Boolean!\n  \"Original query\"\n  query: String!\n  \"query type determined from input query\"\n  queryType: HubQueryType\n  \"Information on entity types and fields that are triggered by the query\"\n  triggers: [HubQueryTrigger!]\n}\ntype HubQueryTrigger {\n  entityType: String\n  fields: [String!]\n}\n\"Defines a HyperLink\"\ntype HyperLink {\n  \"In the case of a POST request, the body to include\"\n  body: [Byte!]\n  \"A localized string representing the description for the hyperlink\"\n  description: LocalizedString\n  \"A localized string representing display name for the hyperlink\"\n  displayName: LocalizedString!\n  \"Optional headers to add to http request, e.g. `Content-Type: application/json`.\"\n  headers: [String!]\n  \"An internal identifier for the hyperlink\"\n  hyperlinkId: String!\n  \"A system-defined namespace indicating the product for which the hyperlink is relevant e.g. 'ensemble', 'vrops', 'vrni'\"\n  namespace: String!\n  \"A namespace-specific hyperlink type indicating the specific hyperlink landing page e.g. summary, alerts, flows, metrics etc.\"\n  type: String!\n  \"The hyperlink URL including any query parameters\"\n  url: String!\n  \"The HTTP request method to use when navigating to the hyperlink\"\n  verb: HyperLinkHttpRequestMethod!\n}\n\"\"\"\nrepresents the top level query node for querying hyperlinks belonging to services with which\nEnsemble interacts.\nthe returned hyperlinks help navigation to the home pages\nor landing pages belonging to the respective services\n\"\"\"\ntype HyperlinkQuery implements HyperLinked {\n  \"\"\"\n  query global hyperlinks\n  ### API Permissions:\n  - `platform:HyperLink:read`\n  \"\"\"\n  hyperlinks(namespace: [String!]): [HyperLink!]\n}\ntype Insight implements Node {\n  \"User insight assigned to\"\n  assignedTo: User\n  \"Details of correlation\"\n  correlationInfo: InsightCorrelationInfo!\n  \"localized description of insight\"\n  description: LocalizedString\n  \"Time at which the insight is closed or not valid. Expressed in UTC ISO-8601 format\"\n  endTime: DateTime\n  \"opaque unique id of insight\"\n  id: ID!\n  \"impacts of insight w.r.t. one or more dimensions/measures and on other entities\"\n  impacts: [InsightImpact!]!\n  \"transient insights are expected to eventually have an endTime, non-transient are point-in-time\"\n  isTransient: Boolean!\n  \"Time at which the insight is updated based on incoming observation. Expressed in UTC ISO-8601 format\"\n  lastUpdateTime: DateTime!\n  \"\"\"\n  Details of observations related to insight\n  ### API Permissions:\n  - `observability:ObservabilityAlert:read`\n  \"\"\"\n  observationConnection(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Optional additional field filters.\"\n    filter: QueryFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Observations with probable cause first\"\n    isFaultFirst: Boolean = true,\n    \"Most recent first\"\n    mostRecentFirst: Boolean = true\n  ): ObservationConnection\n  \"Entities from which the observations for a given insight are originated\"\n  originatingEntities: [Entity!]\n  \"originating ensemble entity, it can be null for insights\"\n  originatingEntity: Entity @deprecated(reason: \"replaced with originatingEntities\")\n  \"Insight Priority\"\n  priority: InsightPriority\n  \"Remediation's  for this insight\"\n  remediations: [InsightRemediation!]\n  \"Insight severity\"\n  severity: InsightSeverity\n  \"Sources of the observations for a given insight\"\n  sources: [ObservationSource!]\n  \"Time at which the insight is created. Expressed in UTC ISO-8601 format\"\n  startTime: DateTime!\n  \"status of insight e.g. NEW\"\n  status: InsightStatus\n  \"Custom tags\"\n  tags: [Tag]\n  \"localized insight summary\"\n  title: LocalizedString!\n  \"Total observation count for a given insight\"\n  totalObservationCount: Long!\n  \"suggested trigger type of an insight, if known e.g. ANOMALOUS\"\n  triggerType: InsightTriggerType\n  \"type of insight as defined in insight template\"\n  type: String!\n}\ntype InsightAggregationItem implements CommonAggregationItem {\n  \"Count of instances of the given value\"\n  count: Long!\n  subAggregations: [InsightAggregationItems!]\n  \"field value\"\n  value: String!\n}\ntype InsightAggregationItems implements CommonAggregationItems {\n  \"Number of distinct buckets\"\n  bucketCount: Long!\n  buckets: [InsightAggregationItem!]\n  \"Field key for which values are being aggregated.\"\n  field: String!\n}\n\"Insight change log change\"\ntype InsightChangeLogChange {\n  changeType: InsightChangeLogChangeType!\n  \"Change values are converted to a string.\"\n  newValue: String\n  \"Change values are converted to a string.\"\n  oldValue: String\n}\n\"Edge for insight change log\"\ntype InsightChangeLogEdge implements ConnectionEdge {\n  cursor: String!\n  node: InsightChangeLogEntry!\n}\n\"Insight change log entry\"\ntype InsightChangeLogEntry implements Node {\n  \"Details of changelog\"\n  fieldChanges: [InsightChangeLogChange!]!\n  \"Opaque unique id\"\n  id: ID!\n  \"Changelog recording time\"\n  lastUpdateTime: DateTime!\n  \"Optional reason for change when driven by user. Ex: Resolution status when insight marked as resolved\"\n  message: String\n  \"Changelog update details, either user or SYSTEM\"\n  updateInfo: InsightChangeLogUpdater!\n}\n\"Insight update mode and updated by\"\ntype InsightChangeLogUpdater {\n  \"Update mode\"\n  updateMode: InsightChangeLogUpdateMode!\n  \"Updated by, if system then will be empty\"\n  updatedBy: User\n}\n\"InsightConfiguration type. InsightConfiguration is aggregated configurations per tenant\"\ntype InsightConfiguration implements InsightRule & Node {\n  \"Status of the InsightConfiguration\"\n  active: Boolean!\n  \"The user who created the InsightConfiguration\"\n  createdBy: User!\n  \"Time at which the InsightConfiguration was created in UTC ISO-8601 format\"\n  creationTime: DateTime!\n  \"Description of the InsightConfiguration\"\n  description: LocalizedString!\n  \"Opaque unique id of a InsightConfiguration\"\n  id: ID!\n  \"Time at which the InsightConfiguration was last updated in UTC ISO-8601 format\"\n  lastUpdateTime: DateTime\n  \"The user who last updated the InsightConfiguration\"\n  lastUpdatedBy: User\n  \"Name of the InsightConfiguration\"\n  name: LocalizedString!\n  \"All tag groups for the tenant\"\n  tagGroups: [ObservationTagGroup!]\n  \"The flag to identify if topology is enabled\"\n  useTopology: Boolean!\n}\ntype InsightConnection implements Connection {\n  \"Number of insights in this page\"\n  count: Int!\n  \"Count by categories\"\n  countByCategories: [InsightCountByCategory!] @deprecated(reason: \"This is deprecated in favour of Insight Aggregation API\")\n  edges: [InsightEdge!]\n  \"Insight stats\"\n  insightStats: InsightStats!\n  \"List of insights in this page\"\n  insights: [Insight!]\n  \"\"\"\n  Impacted Entities of all matching Insights.\n  TODO: To remove when this is moved to EntityConnection as part of EINT-3968\n  \"\"\"\n  insightsImpactedEntities: [Entity!]\n  pageInfo: PageInfo!\n  \"Insight dimensions\"\n  perDimensionInsightStats: [InsightStats!]\n  \"Total number of insights\"\n  totalCount: Int\n}\n\"Provides details about insight correlation\"\ntype InsightCorrelationInfo {\n  \"Specific correlation details\"\n  details: LocalizedString!\n  \"Insight correlation type\"\n  insightProviderType: InsightProviderType!\n}\n\"InsightCorrelationRule type. InsightCorrelationRule are rules used to correlate Observations and create Insights\"\ntype InsightCorrelationRule implements InsightRule & Node {\n  \"Status of the Rule\"\n  active: Boolean!\n  \"condition to apply on observations\"\n  constraint: InsightRuleConstraint\n  \"properties of observations to correlate\"\n  correlatedBy: [String!]!\n  \"FIXED or SLIDING window for correlation. Default value is FIXED\"\n  correlationWindowType: InsightCorrelationRuleWindowType\n  \"The user who created the Rule\"\n  createdBy: User!\n  \"Time at which the Rule was created in UTC ISO-8601 format\"\n  creationTime: DateTime!\n  \"Description of the Rule\"\n  description: LocalizedString!\n  \"Display Name of the Insight Correlation rule\"\n  displayName: LocalizedString!\n  \"opaque unique id of a rule\"\n  id: ID!\n  \"impact definiton\"\n  impacts: [InsightCorrelationRuleImpact!]\n  \"Inisht type the correlation rule would create, optional field used only by CUREATE InsightCorrelationRuleType\"\n  insightType: String\n  \"Time at which the Rule was last updated in UTC ISO-8601 format\"\n  lastUpdateTime: DateTime\n  \"The user who last updated the Rule\"\n  lastUpdatedBy: User\n  \"Name of the rule\"\n  name: LocalizedString!\n  \"Type of Correlation Rule, Default value is DEFAULT\"\n  ruleType: InsightCorrelationRuleType!\n  \"Active window of time in minutes for correlation\"\n  windowInMins: Int!\n}\n\"Impact of a Insight Created by a Correlation Rule\"\ntype InsightCorrelationRuleImpact {\n  \"Dimenstion of Impact\"\n  dimension: InsightImpactDimension!\n  \"connected entityTypes such as VirtualMachine, EC2 which are impacted\"\n  entityTypeImpacted: [String!]\n  \"Scale of impact\"\n  measure: InsightImpactMeasure!\n}\n\"Get count of insight by category\"\ntype InsightCountByCategory {\n  \"Category of count ex: assignee or status\"\n  category: String!\n  \"Count for each type in category\"\n  countByType: [InsightCountByType!]\n}\ntype InsightCountByType {\n  count: Int\n  type: String!\n}\ntype InsightEdge implements ConnectionEdge {\n  cursor: String!\n  node: Insight!\n}\n\"Entities impacted by an insight, and the type and size of impact. This must minimally include the originatingEntityId\"\ntype InsightImpact {\n  \"dimension of impact\"\n  dimension: InsightImpactDimension!\n  \"list of ensemble entities impacted by this insight in a similar manner to each other\"\n  entities: [Entity]!\n  \"scale of impact\"\n  measure: InsightImpactMeasure!\n  \"topology of impact i.e. hierarchy of impacted entities from the originating entity\"\n  topology: JSON\n}\ntype InsightMutation {\n  \"Mutations for Insight Rules\"\n  insightRuleMutation: InsightRuleMutation!\n}\ntype InsightNotificationCriteria {\n  \"Impacted Service / Application\"\n  impactedServices: [String]\n  \"This is the originatingEntity of the Insight\"\n  resource: String\n  \"based on the severity of the insight\"\n  severities: [InsightSeverity]\n  \"can be a list of source from AWS/Azure etc\"\n  sources: [ObservationSource]\n  \"based on the status of the Insight\"\n  statuses: [InsightStatus]\n}\ntype InsightNotificationRule implements Node & NodeVersion & NotificationRule {\n  \"User who created the notification rule\"\n  createdBy: User\n  \"Creation time of the notification rule\"\n  creationTime: DateTime!\n  \"List of email addresses the notifications of this rule needs to be delivered to. Should be provided when notification target type is EMAIL\"\n  emailAddresses: [String!]\n  \"Enabled turns the notification rule on/off\"\n  enabled: Boolean!\n  \"Opaque global ID. We will not persist this. For Query response this ID will be given base64 encoding of notificationRuleId\"\n  id: ID!\n  \"Last update time of the notification rule\"\n  lastUpdateTime: DateTime!\n  \"Name of the notification rule\"\n  name: String!\n  \"Versioning ID. We will populate this with lastUpdateTime, so will not be persisted.\"\n  nodeVersion: ID!\n  \"Criteria to notify\"\n  notificationCriteria: InsightNotificationCriteria\n  \"ID of the notification rule\"\n  notificationRuleId: String!\n  \"List of notification targets that this notification needs to be delivered to\"\n  notificationTargets: [AriaNotificationTarget!]\n  \"Provider name of the notification rule\"\n  provider: String!\n  \"\"\"\n  Slack channel the notifications of this rule needs to be delivered to. Should be provided when notification target type is SLACK,\n  If not provided will be notified to default configured channel\"\n  \"\"\"\n  slackChannel: String\n  \"User who updated this last\"\n  updatedBy: User\n}\ntype InsightNotificationRuleConnection implements Connection & NotificationRuleConnection {\n  \"Count of elements in the current page\"\n  count: Int!\n  \"Edges to nodes available through the connection\"\n  edges: [InsightNotificationRuleConnectionEdge!]\n  notificationRules: [InsightNotificationRule!]\n  \"Paging support\"\n  pageInfo: PageInfo!\n  \"Optional total elements count across all pages when available\"\n  totalCount: Int\n}\ntype InsightNotificationRuleConnectionEdge implements ConnectionEdge & NotificationRuleConnectionEdge {\n  \"Optional cursor to refer to this node\"\n  cursor: String\n  \"Node element available through this edge\"\n  node: InsightNotificationRule!\n}\ntype InsightNotificationRuleMutationProvider implements NotificationRulesMutationProvider {\n  \"\"\"\n  Delete a notification rule\n  ### API Permissions:\n  - `observability:ObservabilityAlert:create`,\n  - `observability:ObservabilityAlert:update`\n  \"\"\"\n  deleteInsightNotificationRule(notificationRuleId: String!): InsightNotificationRule\n  \"Information about this provider\"\n  name: String\n  \"\"\"\n  create/update a notification rule\n  ### API Permissions:\n  - `observability:ObservabilityAlert:create`,\n  - `observability:ObservabilityAlert:update`\n  \"\"\"\n  upsertInsightNotificationRule(ruleInput: InsightNotificationRuleInput!): InsightNotificationRule\n}\ntype InsightNotificationRulesProvider implements NotificationRulesProvider {\n  \"Information about this provider\"\n  providerInfo: NotificationRulesProviderInfo!\n  \"\"\"\n  Query for specific notification rule by notification rule Id\n  ### API Permissions:\n  - `observability:ObservabilityAlert:read`\n  \"\"\"\n  queryInsightNotificationRuleById(\n    \"Array of notification rule id's to query\"\n    notificationRuleId: String!\n  ): InsightNotificationRule\n  \"\"\"\n  Query for specific notification rule by notification rule Ids\n  ### API Permissions:\n  - `observability:ObservabilityAlert:read`\n  \"\"\"\n  queryInsightNotificationRuleByIds(\n    \"Array of notification rule id's to query\"\n    notificationRuleIds: [String!]!\n  ): [InsightNotificationRule]\n  \"\"\"\n  Query list of Notification Rules with selected list of filters\n  ### API Permissions:\n  - `observability:ObservabilityAlert:read`\n  \"\"\"\n  queryNotificationRules(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"optional filter of field names\"\n    filter: QueryFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"InsightNotificationRule filter with zero or more filter parameters\"\n    insightNotificationRuleFilter: InsightNotificationRuleFilter,\n    \"Sort order for results in InsightConnection\"\n    sort: [QuerySort!]\n  ): InsightNotificationRuleConnection\n}\ntype InsightQuery {\n  insightRuleQuery: InsightRuleQuery!\n  \"Query Observations\"\n  observationQuery: ObservationQuery!\n  \"\"\"\n  Query for specific Insights by insight Ids\n  ### API Permissions:\n  - `observability:ObservabilityAlert:read`\n  \"\"\"\n  queryInsightsByIds(\n    \"Array of insight id's to query\"\n    insightId: [String!]!\n  ): [Insight]\n}\ntype InsightRemediation {\n  action: InsightRemediationAction\n  recommendation: InsightRemediationRecommendation\n}\ntype InsightRemediationAction {\n  id: ID!\n  name: String!\n  provider: String\n  type: String!\n}\ntype InsightRemediationRecommendation {\n  description: String!\n  id: ID!\n  name: String!\n  type: String!\n}\n\"Constarint/Condition used by Insight Correlation Rule\"\ntype InsightRuleConstraint {\n  \"constraints to apply recursively\"\n  constraints: [InsightRuleConstraint!]\n  \"Property of Observation on which to apply constraint\"\n  key: String\n  \"Operator used to apply on properties of a Observation\"\n  operator: InsightRuleOperator!\n  \"Check if the constraint needs to be strict match for insight generation\"\n  strict: Boolean\n  \"Value of property to be compared againts for the key\"\n  value: String\n}\n\"Connection edge for Insight rules\"\ntype InsightRuleEdge implements ConnectionEdge {\n  cursor: String!\n  node: InsightRule!\n}\ntype InsightRuleMutation {\n  \"\"\"\n  Mutation to create alert silence\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `observability:ObservabilityAlert:create`,\n  - `observability:ObservabilityAlert:update`\n  \"\"\"\n  createAlertSilence(input: ObservabilityCreateAlertSilenceInput!): ObservabilityCreateAlertSilenceResponse!\n  \"\"\"\n  Mutation to delete alert silence\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `observability:ObservabilityAlert:create`,\n  - `observability:ObservabilityAlert:update`\n  \"\"\"\n  deleteAlertSilence(input: ObservabilityDeleteAlertSilenceInput!): ObservabilityDeleteAlertSilenceResponse!\n  \"\"\"\n  Query to update alert manager config\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `observability:ObservabilityAlert:create`,\n  - `observability:ObservabilityAlert:update`\n  \"\"\"\n  updateAlertManagerConfig(input: ObservabilityUpdateAlertManagerConfigInput!): ObservabilityAlertManagerConfigResponse!\n  \"\"\"\n  Mutation to update alert silence\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `observability:ObservabilityAlert:create`,\n  - `observability:ObservabilityAlert:update`\n  \"\"\"\n  updateAlertSilence(input: ObservabilityUpdateAlertSilenceInput!): ObservabilityUpdateAlertSilenceResponse!\n}\n\"Insight Rule queries\"\ntype InsightRuleQuery {\n  \"Get AlertManager Config\"\n  getAlertManagerConfig(id: ID): ObservabilityAlertManagerConfigResponse!\n  \"\"\"\n  Query observation runbook\n  ### API Permissions:\n  - `observability:ObservabilityAlert:read`\n  \"\"\"\n  queryRunbook(\n    \"Entity Name, foundation or cluser\"\n    entityName: String,\n    \"Foundation Name\"\n    foundation: String @deprecated(reason: \"Use `entityName` instead\"),\n    \"Runbook template id\"\n    runbookTemplateId: String!,\n    \"Optional list of key/value pairs for resolving runbook template variables\"\n    templateVariables: [TagInput!]\n  ): ObservabilityRunbook!\n  \"\"\"\n  Query silences by list of given search criteria\n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  ### API Permissions:\n  - `observability:ObservabilityAlert:read`\n  \"\"\"\n  querySilences(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Optional field filters\"\n    filter: QueryFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Filter silences by state\"\n    silenceFilter: ObservabilitySilenceFilter,\n    \"Sort order for results in ObservationConnection\"\n    sort: [QuerySort!]\n  ): ObservabilityAlertSilenceConnection!\n}\ntype InsightStats {\n  \"Optional dimension for the stats\"\n  dimension: InsightImpactDimension\n  \"Total impact count\"\n  impactCount: Int!\n  \"Total score\"\n  scoreTotal: Float!\n  \"Worst impact measure\"\n  worstImpactMeasure: InsightImpactMeasure\n}\n\" A license to run Tanzu software \"\ntype License {\n  \"Time the license expires, expressed in UTC ISO-8601 format e.g. `2022-01-31T12:00:00.000Z`  Note expiration will be shown in the case if license verification failed due to past expiration \"\n  expiration: DateTime\n  \"\"\"\n  License Data (like \"FileVersion=1.0.0.0;capacityType=ai;desc=VMware Tanzu Application Service\" \n  \"\"\"\n  extendedAttributes: [LicenseAttribute]!\n  \" Count of foundations this license is applied to \"\n  foundationCount: Int\n  \" The license ID \"\n  id: ID!\n  \"\"\"\n   The license key - this can only be seen by admins \n  ### API Permissions:\n  - `license:LicenseKey:read`\n  \"\"\"\n  key: String\n  \"The license version (like 10.0)\"\n  licenseVersion: String!\n  \"More detailed product description\"\n  productDescription: String\n  \"\"\"\n  Which Tanzu product was licensed \"VMware Tanzu Application Service\" or \"VMware Tanzu Platform\" \n  \"\"\"\n  productId: String!\n}\n\" Encapsulates the result of attempting to add a license \"\ntype LicenseAddResult {\n  \" The result upon successful license creation \"\n  license: License\n  \" True if added license successfully, licenseEntity field will exist. \"\n  success: Boolean!\n  \" Identifies the type of verification failure if unsuccessful \"\n  verificationFailure: LicenseVerificationFailure\n}\ntype LicenseApplicationFoundationWorkflow {\n  \" Optional field in case of errors \"\n  errors: [String!]\n  \" Foundation ID \"\n  foundationId: String!\n  \" Status of the foundation workflow \"\n  status: LicenseApplicationWorkflowStatus!\n  \" Workflow ID for this foundation (null if already applied) \"\n  workflowId: String\n}\ntype LicenseApplyResult {\n  \" Results of license application for each foundation \"\n  licenseApplicationResults: [LicenseApplicationFoundationWorkflow!]!\n}\ntype LicenseAttribute {\n  name: String\n  value: String\n}\n\" Encapsulates the result of attempting to delete a license \"\ntype LicenseDeleteResult {\n  success: Boolean!\n}\ntype LicenseDiscoverLegacyLicensesAppliedResult {\n  legacyLicensesDiscoveredCount: Int!\n}\n\"Tanzu Licensing Mutations\"\ntype LicenseMutation {\n  \"\"\"\n   Adds a license \n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `license:License:create`\n  \"\"\"\n  addLicense(licenseKey: String!): LicenseAddResult!\n  \"\"\"\n   Apply license to foundations\n  ### API Permissions:\n  - `license:LicenseFoundationApply:create`\n  \"\"\"\n  applyLicenseToFoundations(input: LicenseApplyToFoundationsInput!): LicenseApplyResult!\n  \"\"\"\n   Deletes an unused license \n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `license:License:delete`\n  \"\"\"\n  deleteLicense(licenseId: String!): LicenseDeleteResult!\n  \"\"\"\n   Discovers legacy licenses applied to foundations manually in pre-10.3 Tanzu Platform versions \n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `license:LicenseFoundationApply:create`\n  \"\"\"\n  discoverLegacyLicensesApplied: LicenseDiscoverLegacyLicensesAppliedResult!\n  \"\"\"\n  Verifies a license key\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `license:LicenseVerification:create`\n  \"\"\"\n  verifyLicenseKey(licenseKey: String!): LicenseVerification!\n}\n\" Represents a license installed to a foundation \"\ntype LicenseOnFoundation {\n  \" Who installed the license on the foundation \"\n  createdBy: String!\n  \" The date the license was installed \"\n  createdDate: DateTime!\n  \" The license installed to the foundation \"\n  license: License!\n  \" The state of the license being installed \"\n  status: String!\n  \" The ID of the workflow used to install the license on the foundation \"\n  workflowId: String!\n}\ntype LicenseQuery {\n  \"\"\"\n  \n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  \"\"\"\n  queryLicenses: [License]!\n}\ntype LicenseVerification {\n  \"Time the license expires, expressed in UTC ISO-8601 format e.g. `2022-01-31T12:00:00.000Z`  Note expiration will be shown in the case if license verification failed due to past expiration \"\n  expiration: DateTime\n  \"\"\"\n  License Data (like \"FileVersion=1.0.0.0;capacityType=ai;desc=VMware Tanzu Application Service\" \n  \"\"\"\n  extendedAttributes: [LicenseAttribute]\n  \" The license key being verified \"\n  key: String!\n  \"The license edition (like broadcom.tanzu.license.tas.core)\"\n  licenseEdition: String\n  \"The license version (like 10.0)\"\n  licenseVersion: String\n  \"\"\"\n  Which Tanzu product was licensed \"VMware Tanzu Application Service\" or \"VMware Tanzu Platform\" \n  \"\"\"\n  productId: String\n  \"why verification failed\"\n  verificationFailure: LicenseVerificationFailure\n  \"true if successfully verified\"\n  verified: Boolean!\n}\ntype LogConnection implements Connection {\n  \"Count of resources on this page\"\n  count: Int!\n  \"Relay-compatible edges on this page\"\n  edges: [LogRecordEdge!]\n  \"Query results on this page\"\n  logRecords: [LogRecord!]\n  \"Relay-compatible page info\"\n  pageInfo: PageInfo!\n  \"Information about the query task execution\"\n  taskInfo: LogTaskInfo\n  \"Optional total elements count across all pages when available\"\n  totalCount: Int\n}\ntype LogField {\n  \"Field name\"\n  key: String!\n  \"Field value\"\n  value: String!\n}\n\"Represents a pattern in logs\"\ntype LogPattern {\n  \"Statistics for the base log pattern\"\n  base: LogPatternStats\n  \"Statistics for the current log pattern\"\n  current: LogPatternStats!\n  \"Log pattern string\"\n  logPattern: String\n  \"Template for the log pattern\"\n  patternTemplate: LogPatternTemplate\n  \"Information about the log task, including the executed query, query tracker ID, and log query execution statistics\"\n  taskInfo: LogTaskInfo\n  \"Trend percentage of the log pattern\"\n  trend: Float\n}\n\"Log pattern response\"\ntype LogPatternResponse {\n  \"List of log patterns\"\n  logPatterns: [LogPattern]\n  \"Information about the log task, including the executed query, query tracker ID, and log query execution statistics\"\n  taskInfo: LogTaskInfo\n}\ntype LogPatternStatistics {\n  count: Int\n  timestamp: DateTime\n}\n\"Stats mapped to a selected window for a pattern in logs, including the count of log patterns and the rate at which they occur\"\ntype LogPatternStats {\n  \"Count of log patterns\"\n  count: Int!\n  \"Rate of log patterns, calculated as the number of occurrences per minute within a specific time window to understand the frequency of a log pattern's appearance\"\n  rate: Float\n}\ntype LogPatternStatsRecord {\n  pattern: String\n  stats: [LogPatternStatistics]\n}\n\"Represents response object for statistics for log patterns\"\ntype LogPatternStatsResponse {\n  patternStats: [LogPatternStatsRecord]\n  taskInfo: LogTaskInfo\n}\n\"Template for a pattern in logs\"\ntype LogPatternTemplate {\n  \"Message template for a pattern in logs\"\n  message: String\n}\ntype LogQueryExecutionStats {\n  bytesRead: Long\n  queryExecutionTimeMillis: Long\n  rowsRead: Long\n  totalTimeTakenMillis: Long\n}\ntype LogRecord implements Node {\n  \"List of fields\"\n  fields: [LogField!]\n  \"Opaque global node ID\"\n  id: ID!\n}\ntype LogRecordEdge implements ConnectionEdge {\n  cursor: String!\n  node: LogRecord!\n}\ntype LogSchema implements Node {\n  \"Field supports groupBy or not\"\n  allowGroupBy: Boolean!\n  \"Name of the field\"\n  fieldName: String!\n  \"Type of the field\"\n  fieldType: String!\n  \"Opaque global node ID\"\n  id: ID!\n}\ntype LogSchemaConnection implements Connection {\n  \"Count of resources on this page\"\n  count: Int!\n  \"Relay-compatible edges on this page\"\n  edges: [LogSchemaEdge!]\n  \"Relay-compatible page info\"\n  pageInfo: PageInfo!\n  \"Schema resources on this page\"\n  schema: [LogSchema!]\n  \"Optional total elements count across all pages when available\"\n  totalCount: Int\n}\n\"Relay-compatible LogSchemaEdge\"\ntype LogSchemaEdge implements ConnectionEdge {\n  cursor: String\n  node: LogSchema!\n}\ntype LogTaskInfo {\n  executionStats: LogQueryExecutionStats\n  \"Query Tracking Id\"\n  id: String!\n  \"Query that was executed\"\n  query: String!\n}\n\"\"\"\nA management endpoint is an abstraction of the place to which to connect to monitor/manage a system.\n\nIn the public cloud world this can be considered as an \"account\" (AWS), \"subscription\" (Azure), or \"project\" (GCP).\n\nIn the on-prem vCenter / VMX world a management endpoint can refer to a vCenter or NSX-Manager instance and its URL.\n\nIn order to support other management endpoints in the future, the management endpoint is considered a point through\nwhich a system, with its discovered entities, can be monitored and/or managed.\n\"\"\"\ntype ManagementEndpoint implements Node {\n  \"Account Owner Information - Name and Email ID\"\n  accountOwnerInfo: ManagementEndpointAccountOwnerInfo\n  createdBy: User\n  \"Creation time of the endpoint.\"\n  creationTime: DateTime\n  eTag: String\n  \"The user-specified name of the endpoint\"\n  endpointName: String\n  \"Type of Management Endpoint\"\n  endpointType: ManagementEndpointType\n  \"List of management endpoint's service entitlements\"\n  entitlements: [ManagementEndpointEntitlementDetail!]\n  \"Environment in which cloud account is onboarded\"\n  environment: String\n  \"\"\"\n  Hyperlink associated with this Endpoint.\n  Currently only Management Endpoints for foundations will have a hyper link,\n  this will point to Graphql Proxy location that will allow direct calls to this foundation\n  For other types of Management Endpoints this will be null\n  \"\"\"\n  hyperLink: HyperLink\n  \"Opaque global identifier of this Management Endpoint\"\n  id: ID!\n  \"Last Updated time of the endpoint.\"\n  lastUpdateTime: DateTime\n  \"List of Management Endpoint Credential mapped to the endpoint.\"\n  managementEndpointCredentials(\n    \"optionally limit the number of returned credentials\"\n    first: Int,\n    \"filter credentials by ID(s)\"\n    id: [ID!],\n    \"filter credentials by the given permission type(s)\"\n    permissionType: [ManagementEndpointCredentialPermissionType!]\n  ): [ManagementEndpointCredential!]\n  \"contains information about the status of the endpoint.\"\n  managementEndpointDeployments: [ManagementEndpointDeployment!]\n  \"public identifier of this management endpoint, may correspond to a public cloud account ID\"\n  managementEndpointId: String!\n  \"contains the endpoint status and other information about the status\"\n  managementEndpointStatus: ManagementEndpointStatus\n  \"Onboarding information such as a script to be executed and/or instructions on how to onboard the endpoint.\"\n  onboardingDetails: [ManagementEndpointOnboardingDetails!]\n  \"List of properties supported for the endpoint.\"\n  properties(name: [String!]): [ManagementEndpointProperty!]\n  \"Root account entity of the endpoint.\"\n  rootManagementEndpointEntity: Entity\n  \"Root Management endpoint ID of the endpoint.\"\n  rootManagementEndpointId: String\n  \" Scoped Entities associated with endpoint \"\n  scopingEntities: [Entity!]\n  \"Tags associated with the endpoint.\"\n  tags(key: [String!]): [Tag!]\n  updatedBy: User\n}\n\"Account discovery request status details\"\ntype ManagementEndpointAccountDiscoveryStatusDetail {\n  \"Details about the status\"\n  message: String\n  \"Status of the request\"\n  status: ManagementEndpointAccountDiscoveryStatus!\n}\ntype ManagementEndpointAccountOwnerInfo {\n  \"Email Id of the account owner\"\n  email: String\n  \"Name of the account owner\"\n  name: String\n  \"If the account owner's email corresponds to a CSP user, full user details will be fetched for the account\"\n  user: User\n}\ntype ManagementEndpointAgentDownloadInfo {\n  \" Hyper link to agent OVA \"\n  downloadLink: HyperLink!\n  \" One time secret for the agent \"\n  oneTimeKey: ManagementEndpointOneTimeKey!\n}\ntype ManagementEndpointAggregationItem {\n  count: Long!\n  subAggregations: [ManagementEndpointAggregationItems!]\n  value: String!\n}\ntype ManagementEndpointAggregationItems {\n  \"Number of distinct buckets\"\n  bucketCount: Long!\n  buckets: [ManagementEndpointAggregationItem!]\n  \"Field key for which values are being aggregated\"\n  field: String!\n}\ntype ManagementEndpointAggregations {\n  aggregations: [ManagementEndpointAggregationItems!]\n  totalCount: Long!\n}\n\" Management Endpoint Bulk Update Response \"\ntype ManagementEndpointBulkUpdateResponse {\n  \" List of Management Endpoint Credential Mapping responses \"\n  managementEndpointCredentialMappingResponses: [ManagementEndpointCredentialMappingResponse!]\n  \" List of Management Endpoint Credential responses \"\n  managementEndpointCredentialResponses: [ManagementEndpointCredentialResponse!]\n  \" List of Management Endpoint responses \"\n  managementEndpointResponses: [ManagementEndpointResponse!]\n}\ntype ManagementEndpointBulkUpsertWithCredentialResponse {\n  errors: [ManagementEndpointUpsertErrorResponse!]\n  response: [ManagementEndpointUpsertResponse!]\n}\n\"\"\"\nManagementEndpointCollector represents collector metadata for various kinds of\ncollectors, Kubernetes is the supported collector type currently.\n\"\"\"\ntype ManagementEndpointCollector implements Node {\n  collectorConfigProperties(name: [String!]): [ManagementEndpointProperty]\n  collectorHealthDetails: ManagementEndpointCollectorHealthDetails\n  \" Creation time of the collector \"\n  creationTime: DateTime\n  \" Deployment install command: This will be only populated for mutation operation and will be set null for query operations. \"\n  deploymentInstall: String\n  deploymentProperties: [ManagementEndpointCollectorDeploymentProperty!]\n  \" Management collector health status \"\n  healthStatus: ManagementEndpointCollectorHealthStatus!\n  \"Opaque global identifier of this Management Endpoint Collector\"\n  id: ID!\n  \" Last Updated time of the collector \"\n  lastUpdateTime: DateTime\n  \" Latest available version of the collector \"\n  latestAvailableVersion: String\n  \" Management Endpoint ID associated with the collector \"\n  managementEndpoint: ManagementEndpoint!\n  \" Management Endpoint collector credentials for connecting to SaaS \"\n  managementEndpointCollectorCredentials: ManagementEndpointCollectorCredentials!\n  \" Management Endpoint collector properties \"\n  managementEndpointCollectorProperties: ManagementEndpointCollectorProperties!\n  \" Collector Type Version \"\n  managementEndpointCollectorTypeVersion: String\n  \" Type of the managementEndpointType. Example: AWS, Azure \"\n  managementEndpointType: ManagementEndpointType!\n  \" Name of the collector\"\n  name: String!\n  \" Region in which the collector is deployed \"\n  region: String!\n  \" Management collector status \"\n  status: ManagementEndpointCollectorStatus!\n  \" Type of the collector. Example: Kubernetes \"\n  type: ManagementEndpointCollectorType!\n}\ntype ManagementEndpointCollectorConnection implements Connection {\n  count: Int!\n  edges: [ManagementEndpointCollectorEdge!]\n  managementEndpointCollectors: [ManagementEndpointCollector!]\n  pageInfo: PageInfo!\n  totalCount: Int\n}\n\" Management Endpoint Collector Credentials used for first time connection to SaaS \"\ntype ManagementEndpointCollectorCredentials {\n  \" Credentials created/generated time \"\n  creationTime: DateTime\n  \" Type of the credential example: cspCredentialPair \"\n  credentialsType: String\n  \" Credential properties which holds client ID and client secret \"\n  properties: ManagementEndpointCollectorCredentialsProperties\n}\n\" Credential client and secret pair \"\ntype ManagementEndpointCollectorCredentialsProperties {\n  \" clientId \"\n  clientId: String!\n  \" Secret used to connect to SaaS service for initial connection \"\n  clientSecret: String!\n}\ntype ManagementEndpointCollectorDeploymentProperty {\n  name: String\n  value: Object\n}\ntype ManagementEndpointCollectorEdge implements ConnectionEdge {\n  cursor: String!\n  node: ManagementEndpointCollector!\n}\ntype ManagementEndpointCollectorHealthDetails {\n  healthStatus: [ManagementEndpointCollectorHealthInformation!]\n}\ntype ManagementEndpointCollectorHealthInformation {\n  collectionType: ManagementEndpointCollectorCollectionType\n  message: String\n  status: ManagementEndpointCollectorCollectionStatus\n}\n\" Management Endpoint Collector Properties \"\ntype ManagementEndpointCollectorProperties {\n  \" Managed or self attached \"\n  managed: Boolean!\n  \" Version of the Collector \"\n  version: String\n}\ntype ManagementEndpointConnection implements Connection {\n  \"Count of elements in this page\"\n  count: Int!\n  edges: [ManagementEndpointEdge!]\n  managementEndpoints: [ManagementEndpoint!]\n  pageInfo: PageInfo!\n  \"Optional total element count\"\n  totalCount: Int\n}\n\"Credential - holds credential information that can be used to access one or more cloud accounts.\"\ntype ManagementEndpointCredential implements Node {\n  \"Created by user for the credential.\"\n  createdBy: User\n  \"Creation time of the credential.\"\n  creationTime: DateTime!\n  \"The user-specified name of the credential\"\n  credentialName: String\n  \"Type of the credential\"\n  credentialType: ManagementEndpointCredentialType\n  eTag: String\n  \"Opaque global identifier of endpoint credentials.\"\n  id: ID! @deprecated(reason: \"'id' is being renamed as 'managementEndpointCredentialId'. The value of 'id' will be replaced with the NodeId of the credential.\")\n  \"Last Accessed time of the credential\"\n  lastAccessedTime: DateTime\n  \"Last Updated time of the credential.\"\n  lastUpdateTime: DateTime!\n  \"Public identifier of this management endpoint credential\"\n  managementEndpointCredentialId: ID!\n  \"Permission type of the credential\"\n  permissionType: ManagementEndpointCredentialPermissionType\n  \"\"\"\n  List of properties supported for the credential.\n  User Credential has properties userName and password.\n  \"\"\"\n  properties(name: [String!]): [ManagementEndpointProperty!]\n  \"This defines the permission scopes of the credential.\"\n  scopes: [ManagementEndpointCredentialScope!]\n  status: ManagementEndpointCredentialStatusInfo\n  \"Tags associated with the credential.\"\n  tags(key: [String!]): [Tag!]\n  \"Update by user for the credential.\"\n  updatedBy: User\n}\n\"Management Endpoint Credential Broker represents credential broker deployment and it's metadata.\"\ntype ManagementEndpointCredentialBroker implements Node {\n  \" Lemans agentId associated to this credentials broker \"\n  agentId: String\n  \" Creation time of the Credential broker \"\n  creationTime: DateTime!\n  \" Short description of the Credential Broker \"\n  description: String\n  \"\"\"\n   Management Endpoint Credential broker health status, unknown when broker status is pending\n  online when we get updates and offline indicates heartbeat was not received\n  \"\"\"\n  healthStatus: ManagementEndpointCredentialBrokerHealthStatus!\n  \"Opaque global identifier of this credential broker and this represents brokerId\"\n  id: ID!\n  \" Kubernetes version where Credential broker pod is running \"\n  k8sVersion: String\n  \" Last Updated time or heartbeat of the Credential broker  \"\n  lastUpdateTime: DateTime\n  \" Name of the Credential Broker \"\n  name: String!\n  \"\"\"\n   Management Endpoint Credential broker registration status, Pending would indicate that broker not yet registered,\n  Registered status indicates broker is registered.\n  \"\"\"\n  registrationStatus: ManagementEndpointCredentialBrokerRegistrationStatus!\n  \" Version of the Credential broker  \"\n  version: String\n}\ntype ManagementEndpointCredentialBrokerConnection implements Connection {\n  count: Int!\n  credentialBrokers: [ManagementEndpointCredentialBroker!]\n  edges: [ManagementEndpointCredentialBrokerEdge!]\n  pageInfo: PageInfo!\n  totalCount: Int\n}\ntype ManagementEndpointCredentialBrokerEdge implements ConnectionEdge {\n  cursor: String!\n  node: ManagementEndpointCredentialBroker!\n}\n\"Management Endpoint Credential broker Response\"\ntype ManagementEndpointCredentialBrokerResponse {\n  \" Lemans accessKey for corresponding agent/broker, this is a protected for query with read only users\"\n  accessKey: String\n  \" Deployment YAML: This will be only populated for mutation operation and will be set null for query operations. \"\n  deploymentYaml: String\n  \"Management Endpoint Credential broker Response\"\n  managementEndpointCredentialBroker: ManagementEndpointCredentialBroker\n  \" Script URL which is needed for deploying the kubernets pod \"\n  scriptUrl: HyperLink\n}\ntype ManagementEndpointCredentialConnection implements Connection {\n  count: Int!\n  edges: [ManagementEndpointCredentialEdge!]\n  managementEndpointCredentials: [ManagementEndpointCredential!]\n  pageInfo: PageInfo!\n  totalCount: Int\n}\n\"Endpoint Type Definition - contains information on the endpoint type\"\ntype ManagementEndpointCredentialDefinition {\n  \"Unique ID for credential definition\"\n  credentialDefinitionId: String!\n  \"Localized credential type description\"\n  description: LocalizedString\n  \"Localized credential type Name\"\n  displayName: LocalizedString!\n  \"List of properties for the credential\"\n  propertyDefinitions: [ManagementEndpointCredentialPropertyDefinition!]\n}\ntype ManagementEndpointCredentialEdge implements ConnectionEdge {\n  cursor: String!\n  node: ManagementEndpointCredential!\n}\ntype ManagementEndpointCredentialMapping {\n  creationTime: DateTime!\n  lastUpdateTime: DateTime!\n  \"Management Endpoint Credential ID.\"\n  managementEndpointCredentialId: ID!\n  \"Management Endpoint ID.\"\n  managementEndpointId: ID!\n}\ntype ManagementEndpointCredentialMappingResponse {\n  \" Action performed on the management endpoint credential mapping \"\n  action: ManagementEndpointResourceAction!\n  \" In case of failure this contains the Http error status code and error message \"\n  errorResponse: ManagementEndpointErrorResponse\n  \" Management Endpoint Credential Mapping \"\n  managementEndpointCredentialMapping: ManagementEndpointCredentialMapping\n}\ntype ManagementEndpointCredentialPropertyDefinition {\n  \"Localized description for the property\"\n  description: LocalizedString\n  \"Localized name for the property\"\n  displayName: LocalizedString!\n  \"Boolean flag to indicate whether the property is a secret field\"\n  isSecret: Boolean!\n  \"Metadata about the property\"\n  propertyMetadata: ManagementEndpointPropertyMetadata\n  \"Name of the property\"\n  propertyName: String!\n  \"Type of the property\"\n  propertyType: ManagementEndpointPropertyType!\n  \"Boolean flag to indicate whether the property is mandatory\"\n  required: Boolean!\n  \"List of service that the property is applicable for\"\n  services: [ManagementEndpointPropertyService!]\n}\ntype ManagementEndpointCredentialResponse {\n  \" Action performed on the management endpoint credential \"\n  action: ManagementEndpointResourceAction!\n  \" In case of failure this contains the Http error status code and error message \"\n  errorResponse: ManagementEndpointErrorResponse\n  \" Management Endpoint Credential \"\n  managementEndpointCredential: ManagementEndpointCredential\n}\n\" Deliberately nest the status enum in a status info type, so that we can leave the door open to add more fields e.g. error message, additional info, etc\"\ntype ManagementEndpointCredentialStatusInfo {\n  status: ManagementEndpointCredentialStatus\n}\n\"Management endpoint credential usage response\"\ntype ManagementEndpointCredentialUsageConnection implements Connection {\n  count: Int!\n  edges: [ManagementEndpointCredentialUsageEdge!]\n  pageInfo: PageInfo!\n  totalCount: Int\n}\ntype ManagementEndpointCredentialUsageEdge implements ConnectionEdge {\n  cursor: String\n  node: ManagementEndpointCredentialUsageNode!\n}\n\"Credential usage error response\"\ntype ManagementEndpointCredentialUsageErrorResponse {\n  \"Additional details about the error\"\n  errorDetails: [ManagementEndpointKeyValuePair!]\n  \"Error message\"\n  errorMessage: String!\n  \"Type of the error\"\n  errorType: ManagementEndpointCredentialUsageErrorType!\n}\n\"Management endpoint credential usage information\"\ntype ManagementEndpointCredentialUsageNode implements Node {\n  \"Usage category for which credential was requested\"\n  category: String!\n  \"Errors during credential usage (if any)\"\n  errors: [ManagementEndpointCredentialUsageErrorResponse!]\n  \"Opaque global ID\"\n  id: ID!\n  \"Timestamp when the credential was requested\"\n  requestTimestamp: DateTime!\n  \"Source which requested the credential\"\n  source: String!\n  \"Current status of the credential usage\"\n  status: ManagementEndpointCredentialUsageStatus!\n  \"Usage sub category for which credential was requested\"\n  subCategory: String\n  \"Additional details about credential usage\"\n  usageDetails: [ManagementEndpointKeyValuePair!]\n  \"Duration from when the credential was requested to when its usage information was reported back, in milliseconds\"\n  usageDurationMillis: Int!\n}\ntype ManagementEndpointCredentialValidation {\n  \"Identifier of credential associated with the cloud account\"\n  credentialId: String!\n  error: ManagementEndpointCredentialValidationErrorResponse\n  \"Specifies if the account-credential pair is valid\"\n  valid: Boolean!\n}\ntype ManagementEndpointCredentialValidationErrorResponse {\n  \"Error message\"\n  message: String!\n  \"Type of the error\"\n  type: ManagementEndpointCredentialValidationErrorType!\n}\n\"Endpoint Type Definition - contains information on the endpoint and parameters\"\ntype ManagementEndpointDefinition {\n  \"List of credential type definition supported fo the endpoint\"\n  credentialDefinitions: [ManagementEndpointCredentialDefinition!]\n  \"Localized decsription for endpoint type\"\n  description: LocalizedString\n  \"Localized name for endpoint type\"\n  displayName: LocalizedString!\n  \"Unique ID for endpoint definition\"\n  endpointDefinitionId: String!\n  \"List of properties for the endpoint\"\n  propertyDefinitions: [ManagementEndpointPropertyDefinition!]\n}\ntype ManagementEndpointDeployToCloudProxyAgentResponse {\n  \"Cloud proxy agent entity ID\"\n  cloudProxyAgentEntityId: EntityId!\n  \"Management endpoint ID\"\n  managementEndpointId: ID!\n  \"Service's identifier of management endpoint\"\n  managementEndpointServiceId: String!\n  \"Status of add endpoint operation\"\n  status: ManagementEndpointRequestStatus!\n}\ntype ManagementEndpointDeployment {\n  lastUpdateTime: DateTime!\n  status: ManagementEndpointDeploymentStatus!\n  statusType: ManagementEndpointStatusType!\n}\ntype ManagementEndpointDiscoveredAccountResponse {\n  \"Management endpoint used to administer the organisation\"\n  administrativeEndpointId: String\n  \"Paged list of discovered nodes\"\n  discoveredNodeConnection: ManagementEndpointDiscoveredNodeConnection\n  \"Account discovery request status\"\n  discoveryStatus: ManagementEndpointAccountDiscoveryStatusDetail!\n  \"Management endpoint type\"\n  endpointType: ManagementEndpointType!\n  \"Response format\"\n  responseFormat: ManagementEndpointDiscoveredAccountResponseFormat!\n}\n\"\"\"\nDiscovered node represents a node in the organisation structure discovered for a root account. A node can either represent an account group or an actual account.\nThe differentiation between account group and account can be made on the basis of entity type.\n\"\"\"\ntype ManagementEndpointDiscoveredNode implements Node {\n  \"If node represents an account group, children of the node\"\n  childConnection(after: String, first: Int): ManagementEndpointDiscoveredNodeConnection\n  \"Opaque global ID\"\n  id: ID!\n  \"If discovered node represents an account and it's already onboarded, details of onboarded account\"\n  managementEndpoint: ManagementEndpoint\n  \"Name of the node\"\n  name: String\n  \"Identifier as in the cloud account provider\"\n  nodeId: String!\n  \"Parent of the node\"\n  parent: ManagementEndpointDiscoveredNode\n  \"Properties of the node\"\n  properties: [ManagementEndpointProperty!]\n  \"Type of the node\"\n  type: String\n}\ntype ManagementEndpointDiscoveredNodeConnection implements Connection {\n  count: Int!\n  edges: [ManagementEndpointDiscoveredNodeEdge!]\n  nodes: [ManagementEndpointDiscoveredNode!]\n  pageInfo: PageInfo!\n  totalCount: Int\n}\ntype ManagementEndpointDiscoveredNodeEdge implements ConnectionEdge {\n  cursor: String\n  node: ManagementEndpointDiscoveredNode!\n}\ntype ManagementEndpointEdge implements ConnectionEdge {\n  cursor: String!\n  node: ManagementEndpoint!\n}\n\"Entitlement specific details for a management endpoint\"\ntype ManagementEndpointEntitlementDetail {\n  \"Onboarding status of the management endpoint for this specific entitlement\"\n  onboardingStatus: ManagementEndpointEntitlementOnboardingStatus!\n  \"Name of the service\"\n  service: ManagementEndpointDefinitionServiceName!\n}\n\" Management Endpoint Error Response \"\ntype ManagementEndpointErrorResponse {\n  \" Error code for the failure \"\n  errorCode: Int\n  \" Error message for the failure \"\n  errorMessage: String\n  \" Management Endpoint Id or Management Endpoint Credential Id depending on the request \"\n  id: String\n}\ntype ManagementEndpointKeyValuePair {\n  key: String!\n  value: Object!\n}\ntype ManagementEndpointLifecycleScriptDownloadInfo {\n  \" Hyper link to download event stream script \"\n  scriptHyperlinks: [HyperLink!]\n}\n\"Response for Query Member Account by Credential Permission Type\"\ntype ManagementEndpointMemberAccountsByCredPermissionTypeResponse {\n  \"Total count of member accounts which has specified credential permission type\"\n  count: Int!\n  \"List of member accounts which has specified credential permission type\"\n  managementEndpoints: [ManagementEndpoint!]\n}\ntype ManagementEndpointMutation {\n  \"\"\"\n   Attach Management Endpoint collector \n  ### API Permissions:\n  - `managementEndpoint:ManagementEndpointCollector-*:create`\n  \"\"\"\n  attachManagementEndpointCollector(input: ManagementEndpointCollectorInput!): ManagementEndpointCollector @deprecated(reason: \"No longer supported\")\n  \"\"\"\n   Generate and initialize credential broker configuration such as script, access-key, yaml file, brokerId to deploy broker \n  ### API Permissions:\n  - `managementEndpoint:ManagementEndpoint-*:create`\n  \"\"\"\n  attachManagementEndpointCredentialBroker(input: ManagementEndpointCredentialBrokerInput!): ManagementEndpointCredentialBrokerResponse @deprecated(reason: \"No longer supported\")\n  \"\"\"\n   Attach self managed Management Endpoint collector \n  ### API Permissions:\n  - `managementEndpoint:ManagementEndpoint-*:create`,\n  - `managementEndpoint:ManagementEndpointCollector-*:create`\n  \"\"\"\n  attachSelfManagedManagementEndpointCollector(input: ManagementEndpointSelfManagedCollectorInput!, managementEndpointId: ID): ManagementEndpointCollector\n  \"\"\"\n   Bulk create, update and delete ManagementEndpoint, ManagementEndpointCredential and ManagementEndpointCredentialMapping resources\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `managementEndpoint:ManagementEndpoint-*:create`,\n  - `managementEndpoint:ManagementEndpoint-*:update`,\n  - `managementEndpoint:ManagementEndpoint-*:delete`\n  \"\"\"\n  bulkUpdate(managementEndpointCredentialMappingRequests: [ManagementEndpointCredentialMappingRequest!], managementEndpointCredentialRequests: [ManagementEndpointCredentialRequest!], managementEndpointRequests: [ManagementEndpointRequest!]): ManagementEndpointBulkUpdateResponse\n  \"\"\"\n   Bulk onboard cloud accounts. It will create/update the cloud account with provided account and credential details \n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `managementEndpoint:ManagementEndpoint-*:create`,\n  - `managementEndpoint:ManagementEndpoint-*:update`\n  \"\"\"\n  bulkUpsertEndpointWithCredential(input: [ManagementEndpointUpsertWithCredentialInput!]!): ManagementEndpointBulkUpsertWithCredentialResponse @deprecated(reason: \"No longer supported\")\n  \"\"\"\n  Delete an existing Management Endpoint and the credentials associated with it.\n  Credentials that are being used by other endpoints will not be deleted.\n  Setting the boolean conserveCredentials to true will skip deleting the credentials.\n  Setting the boolean forceDelete to true will delete the endpoint even if event stream is connected.\n  ### API Permissions:\n  - `managementEndpoint:ManagementEndpoint-*:delete`\n  \"\"\"\n  deleteEndpoint(conserveCredentials: Boolean = false, forceDelete: Boolean = false, id: ID!): ManagementEndpoint\n  \"\"\"\n  Delete an existing Management Endpoint Credential\n  ### API Permissions:\n  - `managementEndpoint:ManagementEndpoint-*:delete`\n  \"\"\"\n  deleteEndpointCredential(id: ID!): ManagementEndpointCredential\n  \"\"\"\n  delete a mapping between an existing Management Endpoint and a Credential\n  ### API Permissions:\n  - `managementEndpoint:ManagementEndpoint-*:delete`\n  \"\"\"\n  deleteEndpointCredentialMapping(managementEndpointCredentialId: ID!, managementEndpointId: ID!): ManagementEndpointCredentialMapping @deprecated(reason: \"No longer supported\")\n  \"\"\"\n   Detach Management Endpoint collector by ID \n  ### API Permissions:\n  - `managementEndpoint:ManagementEndpoint-*:delete`,\n  - `managementEndpoint:ManagementEndpointCollector-*:delete`\n  \"\"\"\n  detachManagementEndpointCollector(id: ID!): ManagementEndpointCollector\n  \"\"\"\n  Deploy management endpoint to cloud proxy agent\n  ### API Permissions:\n  - `managementEndpoint:ManagementEndpoint-*:update`\n  \"\"\"\n  managementEndpointDeployToCloudProxyAgent(input: ManagementEndpointDeployToCloudProxyAgentInput): ManagementEndpointDeployToCloudProxyAgentResponse @deprecated(reason: \"No longer supported\")\n  \"\"\"\n  \n  ### API Permissions:\n  - `managementEndpoint:ManagementEndpoint-*:update`\n  \"\"\"\n  updateOnboardingInfo(input: ManagementEndpointOnboardingInfoInput): ManagementEndpointOnboardingInfoResponse! @deprecated(reason: \"No longer supported\")\n  \"\"\"\n   Upgrade Management Endpoint collector \n  ### API Permissions:\n  - `managementEndpoint:ManagementEndpointCollector-*:update`\n  \"\"\"\n  upgradeManagementEndpointCollector(input: ID!): ManagementEndpointCollector\n  \"\"\"\n  Update an existing Management Endpoint or create a new one\n  Empty list input for scopingEntityIds disassociates Management Endpoint and the Scoping Entity(s) in Update operation\n  ### API Permissions:\n  - `managementEndpoint:ManagementEndpoint-*:create`,\n  - `managementEndpoint:ManagementEndpoint-*:update`\n  \"\"\"\n  upsertEndpoint(input: ManagementEndpointInput): ManagementEndpoint\n  \"\"\"\n  Create or Update an existing Management Endpoint Credential.\n  ### API Permissions:\n  - `managementEndpoint:ManagementEndpoint-*:create`,\n  - `managementEndpoint:ManagementEndpoint-*:update`\n  \"\"\"\n  upsertEndpointCredential(input: ManagementEndpointCredentialsInput): ManagementEndpointCredential\n  \"\"\"\n  Update a mapping between an existing Management Endpoint and a Credential\n  ### API Permissions:\n  - `managementEndpoint:ManagementEndpoint-*:create`,\n  - `managementEndpoint:ManagementEndpoint-*:update`\n  \"\"\"\n  upsertEndpointCredentialMapping(endpointCredentialMapping: ManagementEndpointCredentialMappingInput!): ManagementEndpointCredentialMapping\n  \"\"\"\n  Insert/Update Management Endpoint and Credential and also create mapping between endpoint and credential\n  ### API Permissions:\n  - `managementEndpoint:ManagementEndpoint-*:create`,\n  - `managementEndpoint:ManagementEndpoint-*:update`\n  \"\"\"\n  upsertEndpointWithCredential(input: ManagementEndpointUpsertWithCredentialInput): ManagementEndpointUpsertResponse\n  \"\"\"\n  Validates Management Endpoint Credentials and update account once credential are validated\n  ### API Permissions:\n  - `managementEndpoint:ManagementEndpoint-*:update`\n  \"\"\"\n  validateAndUpdate(managementEndpointId: ID!): ManagementEndpointValidation @deprecated(reason: \"No longer supported\")\n  \"\"\"\n  Validates Management Endpoint Credentials\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  \"\"\"\n  validateCredentials(input: ManagementEndpointValidateCredentialInput): ManagementEndpointValidateCredentialResponse\n}\ntype ManagementEndpointOnboardingDetails {\n  onboardingProperties: [ManagementEndpointOnboardingDetailsProperty!]\n  orgId: String\n  type: String\n}\ntype ManagementEndpointOnboardingDetailsProperty {\n  name: String\n  value: Object\n}\n\" Management Endpoint Onboarding Info Response \"\ntype ManagementEndpointOnboardingInfoResponse {\n  status: ManagementEndpointRequestStatus!\n}\ntype ManagementEndpointOneTimeKey {\n  \" generated One time key for the agent \"\n  secret: String!\n  \" Unique UUID returned by the service \"\n  uuid: String!\n  \" Validity till when OTK is valid \"\n  validity: DateTime!\n}\ntype ManagementEndpointProperty {\n  name: String!\n  value: Object\n}\ntype ManagementEndpointPropertyDefinition {\n  \"Localized description for the property\"\n  description: LocalizedString\n  \"Localized name for the property\"\n  displayName: LocalizedString!\n  \"Metadata about the property\"\n  propertyMetadata: ManagementEndpointPropertyMetadata\n  \"Name of the property\"\n  propertyName: String!\n  \"Type of the property\"\n  propertyType: ManagementEndpointPropertyType!\n  \"List of service that the property is applicable for\"\n  services: [ManagementEndpointPropertyService!]\n}\ntype ManagementEndpointPropertyMetadata {\n  \"Default value for the property\"\n  defaultValue: Object\n  \"Boolean flag to indicate whether the property is immutable\"\n  isImmutable: Boolean\n  \"Boolean flag to indicate whether the property is internal or public\"\n  isInternal: Boolean\n  \"Flag to indicate whether the property is mandatory\"\n  isRequired: Boolean!\n  \"Boolean flag to indicate whether the property is a secret field. This is applicable only for credential properties.\"\n  isSecret: Boolean\n  \"For numeric properties optionally specify a maximum value\"\n  maxValue: Object\n  \"For numeric properties optionally specify a minimal value\"\n  minValue: Object\n  \"Optionally specify an enumerated list of possible values (can be used for any type)\"\n  permittedValues: [Object!]\n  \"Optionally specify the semantic of the property, permits validation\"\n  propertySemantic: ManagementEndpointPropertySemantic\n}\ntype ManagementEndpointPropertyService {\n  \"Default value for the property\"\n  defaultValue: Object\n  \"Name of the service\"\n  name: ManagementEndpointDefinitionServiceName!\n  \"Flag to indicate whether the property is mandatory for this service\"\n  required: Boolean\n}\ntype ManagementEndpointQuery {\n  \"\"\"\n   Get cloud proxy download info \n  ### API Permissions:\n  \"\"\"\n  queryCloudProxyAgentDownloadInfo(serviceType: ManagementEndpointServiceType!): ManagementEndpointAgentDownloadInfo @deprecated(reason: \"No longer supported\")\n  \"\"\"\n  Query a filtered set of management endpoint collectors for aggregated counts of values of specified fields and all preexisting values\n  \n  This can be used, for example, to fetch counts of each collectors and their types.\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `managementEndpoint:ManagementEndpointCollector-*:read`\n  \"\"\"\n  queryCollectorAggregations(\n    \"Specify aggregation buckets\"\n    aggregations: [ManagementEndpointAggregationInput!]!,queryFilter: ManagementEndpointCollectorQueryFilter  ): ManagementEndpointAggregations! @deprecated(reason: \"No longer supported\")\n  \"\"\"\n   Get Management Endpoint collector \n  ### API Permissions:\n  - `managementEndpoint:ManagementEndpointCollector-*:read`\n  \"\"\"\n  queryCollectorById(collectorId: ID!): ManagementEndpointCollector\n  \"\"\"\n  Query all/specific credential definition\n  ### API Permissions:\n  - `managementEndpoint:ManagementEndpoint-*:read`\n  \"\"\"\n  queryCredentialDefinitions(\n    \"List of Credential Definition Ids to fetch\"\n    credentialDefinitionIds: [String!],\n    \"Filters for fetching credential definitions\"\n    filter: ManagementEndpointDefinitionQueryFilter\n  ): [ManagementEndpointCredentialDefinition!] @deprecated(reason: \"No longer supported\")\n  \"\"\"\n  Query discovered accounts for a given administrative account id.\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `managementEndpoint:ManagementEndpoint-*:read`\n  \"\"\"\n  queryDiscoveredAccounts(input: ManagementEndpointDiscoveredAccountInput): ManagementEndpointDiscoveredAccountResponse @deprecated(reason: \"No longer supported\")\n  \"\"\"\n  Query all/specific endpoint definition\n  ### API Permissions:\n  - `managementEndpoint:ManagementEndpoint-*:read`\n  \"\"\"\n  queryEndpointDefinitions(\n    \"List of Endpoint Definition Ids to fetch\"\n    endpointDefinitionIds: [String!],\n    \"Filters for fetching endpoint definitions\"\n    filter: ManagementEndpointDefinitionQueryFilter\n  ): [ManagementEndpointDefinition!] @deprecated(reason: \"No longer supported\")\n  \"\"\"\n  Query to get download link for lifecycle script\n  ### API Permissions:\n  - `managementEndpoint:ManagementEndpoint-*:read`\n  \"\"\"\n  queryLifeCycleScriptDownloadInfo(endpointType: ManagementEndpointType!): ManagementEndpointLifecycleScriptDownloadInfo @deprecated(reason: \"No longer supported\")\n  \"\"\"\n  Query a filtered set of management endpoints for aggregated counts of values of specified fields and all preexisting values\n  \n  This can be used, for example, to fetch counts of AWS services and their types, or to fetch existing values of a field e.g. for autocomplete / selection drop-down\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `managementEndpoint:ManagementEndpoint-*:read`\n  \"\"\"\n  queryManagementEndpointAggregations(\n    \"Specify aggregation buckets\"\n    aggregations: [ManagementEndpointAggregationInput!]!,queryFilter: ManagementEndpointQueryFilter  ): ManagementEndpointAggregations!\n  \"\"\"\n   Query all management endpoint collectors by various parameters \n  ### API Permissions:\n  - `managementEndpoint:ManagementEndpointCollector-*:read`\n  \"\"\"\n  queryManagementEndpointCollectors(\n    \"relay-compatible cursor of last entry on previous page\"\n    after: String,\n    \"relay-compatible page size\"\n    first: Int = 10,\n    \" filter by management endpoint collector ID(s) \"\n    id: [ID!],\n    \" filter by management endpoint collector status Online/Offline/NA \"\n    managementEndpointCollectorHealthStatus: [ManagementEndpointCollectorHealthStatus!],\n    \" filter by management endpoint collector status Discovered/Ready/Pending \"\n    managementEndpointCollectorStatus: [ManagementEndpointCollectorStatus!],\n    \" filter by management endpoint ID(s) \"\n    managementEndpointId: [ID!],\n    \" filter by management endpoint collector names \"\n    name: [String!],sort: [QuerySort!], \n    \" filter by management endpoint collector types \"\n    type: [ManagementEndpointCollectorType!]\n  ): ManagementEndpointCollectorConnection\n  \"\"\"\n   Query all credential brokers \n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `managementEndpoint:ManagementEndpoint-*:read`\n  \"\"\"\n  queryManagementEndpointCredentialBrokers(\n    \"relay-compatible cursor of last entry on previous page\"\n    after: String,\n    \" filter by credential broker health status ONLINE/OFFLINE/UNKNOWN \"\n    credentialBrokerHealthStatus: [ManagementEndpointCredentialBrokerHealthStatus!],\n    \" filter by credential broker status Ready/Pending \"\n    credentialBrokerStatus: [ManagementEndpointCredentialBrokerRegistrationStatus!],\n    \"relay-compatible page size\"\n    first: Int = 10,\n    \" filter by credential broker ID(s) \"\n    id: [ID!],sort: [QuerySort!]  ): ManagementEndpointCredentialBrokerConnection @deprecated(reason: \"No longer supported\")\n  \"\"\"\n  Query details of credential usages by different stakeholders (sources) for a given management endpoint\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `managementEndpoint:ManagementEndpoint-*:read`\n  \"\"\"\n  queryManagementEndpointCredentialUsage(\n    \"Fetch records after given cursor\"\n    after: String,\n    \"Filters for fetching credential usage\"\n    filter: ManagementEndpointCredentialUsageFilter,\n    \"Limit the number of entries in response to the first N\"\n    first: Int = 10,\n    \"Management endpoint id for which credential usage should be fetched\"\n    managementEndpointId: String!\n  ): ManagementEndpointCredentialUsageConnection\n  \"\"\"\n   Query all management endpoints credentials.\n  ### API Permissions:\n  - `managementEndpoint:ManagementEndpoint-*:read`\n  \"\"\"\n  queryManagementEndpointCredentials(\n    \"relay-compatible cursor of last entry on previous page\"\n    after: String,\n    \"relay-compatible cursor of first entry on current page\"\n    before: String,\n    \"filter by credential name\"\n    credentialName: String,\n    \"filter by Management Endpoint Credential Type\"\n    credentialType: ManagementEndpointCredentialType,\n    \"\"\"\n    Full text search Filter for more advanced filtering\n    Supported fields for filtering are:\n    \n    targetId\n    \"\"\"\n    filter: QueryFilter,\n    \"relay-compatible page size\"\n    first: Int = 10,\n    \"filter by credential ID(s)\"\n    id: [ID!],\n    \"relay-compatible page size\"\n    last: Int,\n    \"filter by credential permission type\"\n    permissionType: ManagementEndpointCredentialPermissionType,\n    \"filter to only return credentials which may be reusable across management endpoints\"\n    reusableOnly: Boolean = true,\n    \"filter by scope\"\n    scope: [ManagementEndpointCredentialScope!],sort: [QuerySort!]  ): ManagementEndpointCredentialConnection\n  \"\"\"\n   Query all management endpoints.\n  ### API Permissions:\n  - `managementEndpoint:ManagementEndpoint-*:read`\n  \"\"\"\n  queryManagementEndpoints(\n    \"relay-compatible cursor of last entry on previous page\"\n    after: String,\n    \"relay-compatible cursor of first entry on current page\"\n    before: String,\n    \"filter by credential IDs\"\n    credentialIds: [String!],\n    \"filter by endpoint name(s)\"\n    endpointName: [String!],\n    \"filter by endpoint name prefix\"\n    endpointNamePrefix: String,\n    \"filter by Management Endpoint Type\"\n    endpointType: ManagementEndpointType @deprecated(reason: \"endpointType is being replaced by managementEndpointType\"),\n    \"Additional field filters are currently not supported.\"\n    filter: QueryFilter,\n    \"relay-compatible page size\"\n    first: Int = 10,\n    \"relay-compatible page size\"\n    last: Int,\n    \"filter by Management endpoint account status\"\n    managementEndpointAccountStatus: ManagementEndpointDeploymentStatus,\n    \"filter by management endpoint ID(s)\"\n    managementEndpointId: [String!],\n    \"filter by Management Endpoint Types\"\n    managementEndpointType: [ManagementEndpointType!],\n    \"filter by credential permission type\"\n    permissionType: ManagementEndpointCredentialPermissionType,\n    \"filter member accounts by root account entity id\"\n    rootManagementEndpointEntityId: [EntityId!],\n    \"filter member accounts by root account id\"\n    rootManagementEndpointId: [String!],\n    \" filter by Scoped Entity IDs \"\n    scopingEntityIds: [EntityId!],\n    \"\"\"\n    Supported sort fields:\n    \n    'endpointName'\n    \n    'endpointType'\n    \n    'creationTime'\n    \n    'lastUpdateTime'\n    \n    'managementEndpointStatus.status'\n    \"\"\"\n    sort: [QuerySort!],\n    \"Optionally filter by tags. OR is used among values for the same key, AND across different keys\"\n    tags: [TagFilterInput!]\n  ): ManagementEndpointConnection\n  \"\"\"\n  Query to get count of member accounts with elevated credential\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `managementEndpoint:ManagementEndpoint-*:read`\n  \"\"\"\n  queryMemberAccountsByCredPermissionType(\n    \"Credential Permission Type\"\n    permissionType: ManagementEndpointCredentialPermissionType!,\n    \"Root Account Id\"\n    rootAccountId: String!\n  ): ManagementEndpointMemberAccountsByCredPermissionTypeResponse @deprecated(reason: \"No longer supported\")\n}\ntype ManagementEndpointResponse {\n  \" Action performed on the management endpoint \"\n  action: ManagementEndpointResourceAction!\n  \" In case of failure this contains the Http error status code and error message \"\n  errorResponse: ManagementEndpointErrorResponse\n  \" Management Endpoint \"\n  managementEndpoint: ManagementEndpoint\n}\ntype ManagementEndpointStatus {\n  info: ManagementEndpointStatusInfo\n  status: ManagementEndpointStatusEnum!\n}\n\"\"\"\n Information about the Management Endpoint Status.\nAs of now it contains the cause but in the future it can extend to hold other information like remediation. \n\"\"\"\ntype ManagementEndpointStatusInfo {\n  cause: ManagementEndpointStatusCause\n}\ntype ManagementEndpointUpsertErrorResponse {\n  credentialType: ManagementEndpointCredentialType\n  endpointType: ManagementEndpointType\n  errorMessage: String!\n  errorType: ManagementEndpointUpsertErrorType!\n  managementEndpointCredentialId: String\n  managementEndpointId: String\n}\ntype ManagementEndpointUpsertResponse {\n  \"Management Endpoint Response\"\n  managementEndpoint: ManagementEndpoint\n  \"Management Endpoint Credential Response\"\n  managementEndpointCredential: ManagementEndpointCredential\n  \"Management Endpoint Deploy to Cloud Proxy Agent Response\"\n  managementEndpointDeployToCloudProxyAgentResponse: ManagementEndpointDeployToCloudProxyAgentResponse\n}\ntype ManagementEndpointValidateCredentialResponse {\n  \"Cloud Account Id\"\n  cloudAccountId: String\n  error: ManagementEndpointCredentialValidationErrorResponse\n  \"Specifies if the account-credential pair is valid\"\n  valid: Boolean!\n}\ntype ManagementEndpointValidation {\n  \"A list of Management Endpoint Credential Validation Result\"\n  credentialValidationResults: [ManagementEndpointCredentialValidation!]!\n  \"Specifies if the account is valid\"\n  valid: Boolean!\n}\ntype MetricLabelValue {\n  labelCount: String\n  labelValue: String\n}\ntype MetricLabelValues {\n  labelValues: [MetricLabelValue!]\n}\ntype MetricLabels {\n  labels: [String!]\n}\ntype MetricNames {\n  names: [String!]\n}\ntype MetricQuery {\n  \"\"\"\n  \n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `observability:ObservabilityStat:read`\n  \"\"\"\n  queryMetricLabelValues(label: String!, metric: String!, namespace: String!, pattern: String): MetricLabelValues\n  \"\"\"\n  \n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `observability:ObservabilityStat:read`\n  \"\"\"\n  queryMetricLabels(metric: String!, namespace: String!, pattern: String): MetricLabels\n  \"\"\"\n  \n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `observability:ObservabilityStat:read`\n  \"\"\"\n  queryMetricNames(namespace: String!, pattern: String): MetricNames\n}\ntype Mutation {\n  \"Contains mutations used for managing system-level operations and configurations.\"\n  adminMutation: AdminMutation!\n  \"Auth subsystem mutations\"\n  authMutation: AuthMutation!\n  \"\"\"\n  dashboard specific mutations\n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  \"\"\"\n  dashboardMutations: DashboardMutation!\n  \"Mutation derived-data subsystem\"\n  derivedDataMutation: DerivedDataMutation!\n  \"Document mutations\"\n  documentMutation: DocumentMutation\n  \"\"\"\n  Fleet Management Mutation\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  \"\"\"\n  fleetManagementMutation: FleetManagementMutation!\n  \"\"\"\n  Mutation for managing Grouping constructs such as Foundation Groups\n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  \"\"\"\n  groupMutation: GroupMutation!\n  \"\"\"\n  Policy framework mutation\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  \"\"\"\n  hubPolicyMutation: TanzuHubPolicyMutation!\n  \"\"\"\n  Entry point for Licensing mutations\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  \"\"\"\n  licenseMutation: LicenseMutation\n  \"\"\"\n  Mutations on management endpoint.\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  \"\"\"\n  managementEndpointMutation: ManagementEndpointMutation!\n  \"\"\"\n  Mutate notification subsystem\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `notification:*:create`,\n  - `notification:*:update`,\n  - `notification:*:delete`,\n  - `notification:Target-Platform:read`\n  \"\"\"\n  notificationMutation: NotificationMutation!\n  \"Platform consumption report mutation\"\n  platformConsumptionReportMutation: PlatformConsumptionReportMutation!\n  \"Contains mutations for managing service instances like create and delete operations as well as operations on service-related resources.\"\n  serviceMutation: ServiceMutation!\n  \"User specific mutations\"\n  userMutation: UserMutation!\n  \"\"\"\n  Entry point for Tanzu Warehouse mutations.\n  This field serves as the namespace for all warehouse-related mutation operations.\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  \"\"\"\n  warehouseMutation: WarehouseMutation\n  \"\"\"\n  Conversation specific mutations\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `tia:ChatFeedback:create`,\n  - `tia:Chat:update`,\n  - `tia:Chat:delete`\n  \"\"\"\n  conversationalMutation: ConversationalMutation!\n  \"\"\"\n  Mutations specific to the app-manager service.\n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  \"\"\"\n  businessAppMutation: BusinessAppMutation!\n  \"Mutation query for insight\"\n  insightMutation: InsightMutation!\n  \"Assessment scan Mutations\"\n  assessmentMutation: AssessmentMutation!\n  \"\"\"\n  Spring artifact mutations\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `springassessment:Assessment:create`,\n  - `springassessment:Assessment:update`\n  \"\"\"\n  springArtifactMutations: SpringArtifactMutations!\n}\n\"Mutate notification subsystem\"\ntype NotificationMutation {\n  \"\"\"\n  Notification Rule Mutation\n  ### API Permissions:\n  - `notification:Rule-*:create`,\n  - `notification:Rule-*:update`,\n  - `notification:Rule-*:delete`,\n  - `notification:Target-Platform:read`\n  \"\"\"\n  notificationRuleMutation: NotificationRuleMutation!\n  \"\"\"\n  Notification Target Mutation\n  ### API Permissions:\n  - `notification:Target-*:create`,\n  - `notification:Target-*:update`,\n  - `notification:Target-*:delete`\n  \"\"\"\n  notificationTargetMutation: NotificationTargetMutation!\n}\n\"Query the notification subsystem\"\ntype NotificationQuery {\n  \"\"\"\n  Query Notification Rules\n  ### API Permissions:\n  - `notification:Rule-*:read`\n  \"\"\"\n  notificationRulesQuery: NotificationRulesQuery!\n  \"\"\"\n  Query Notification Targets & Target Types\n  ### API Permissions:\n  - `notification:Target-*:read`\n  \"\"\"\n  notificationTargetsQuery: NotificationTargetsQuery!\n}\ntype NotificationRuleConnectionEdgePrivate implements ConnectionEdge & NotificationRuleConnectionEdge {\n  \"Optional cursor to refer to this node\"\n  cursor: String\n  \"Node element available through this edge\"\n  node: NotificationRulePrivate!\n}\ntype NotificationRuleConnectionPrivate implements Connection & NotificationRuleConnection {\n  \"Count of elements in the current page\"\n  count: Int!\n  \"Edges to nodes available through the connection\"\n  edges: [NotificationRuleConnectionEdgePrivate!]\n  \"List of notificationRules in this page\"\n  notificationRules: [NotificationRulePrivate!]\n  \"Paging support\"\n  pageInfo: PageInfo!\n  \"Optional total elements count across all pages when available\"\n  totalCount: Int\n}\ntype NotificationRuleMutation {\n  \"Notification Rule Mutation per provider\"\n  providers: NotificationRuleMutationProviders!\n}\ntype NotificationRuleMutationProviders {\n  \"\"\"\n  \n  ### API Permissions:\n  - `notification:Rule-Events:create`,\n  - `notification:Rule-Events:update`,\n  - `notification:Rule-Events:delete`,\n  - `notification:Target-Platform:read`\n  \"\"\"\n  events: EventsNotificationRuleMutationProvider!\n  insights: InsightNotificationRuleMutationProvider!\n  observabilityAlerts: ObservabilityAlertNotificationRuleMutationProvider!\n}\ntype NotificationRulePrivate implements Node & NodeVersion & NotificationRule {\n  \"User who created the notification rule\"\n  createdBy: User\n  \"Creation time of the notification rule\"\n  creationTime: DateTime!\n  \"List of email addresses the notifications of this rule needs to be delivered to. Should be provided when notification target type is EMAIL\"\n  emailAddresses: [String!]\n  \"Enabled turns the notification rule on/off\"\n  enabled: Boolean!\n  \"Opaque global ID\"\n  id: ID!\n  \"Last update time of the notification rule\"\n  lastUpdateTime: DateTime!\n  \"Name of the notification rule\"\n  name: String!\n  \"Versioning ID\"\n  nodeVersion: ID!\n  \"ID of the notification rule\"\n  notificationRuleId: String!\n  \"List of notification targets that this notification needs to be delivered\"\n  notificationTargets: [NotificationTargetPrivate!]\n  \"Provider name of the notification rule\"\n  provider: String!\n}\ntype NotificationRulesProviderInfo {\n  \"Name of the notification target provider that this rules provider would publish its notifications with\"\n  notificationTargetProviderName: String!\n  \"Name for this notification rules provider - queries and mutations directed to this provider name will be sent to this provider.\"\n  providerName: String!\n  \"List of supported types and their provider name\"\n  supportedTargetTypes: [NotificationSupportedTargetType!]\n}\ntype NotificationRulesProviders {\n  \"Notification rules provider from insight\"\n  insights: InsightNotificationRulesProvider!\n  \"Notification rules provider from observability alert\"\n  observabilityAlerts: ObservabilityAlertNotificationRulesProvider!\n}\ntype NotificationRulesQuery {\n  \"\"\"\n  Direct access to individual notification rules provider queries through per-provider fields.\n  \n  The top-level notification rules queries leverage these providers based upon the notification rules query's provider name.\n  \"\"\"\n  notificationRulesProviders: NotificationRulesProviders!\n  \"\"\"\n  Query notification rules for the given provider and filters\n  ### API Permissions:\n  - `notification:Rule-*:read`\n  \"\"\"\n  queryNotificationRules(after: String, filter: QueryFilter, first: Int = 10, providerName: String!, sort: [QuerySort!]): NotificationRuleConnection\n}\n\"Type object encapsulating the target type and the target provider name that will provide the targets for the type\"\ntype NotificationSupportedTargetType {\n  targetProviderName: String!\n  targetType: [String!]!\n}\ntype NotificationTargetConnectionPrivate implements Connection & NotificationTargetConnection {\n  \"Count of notification targets in current page\"\n  count: Int!\n  \"Relay-compatible connection edge\"\n  edges: [NotificationTargetEdgePrivate!]\n  \"List of notification targets in current page\"\n  notificationTargets: [NotificationTargetPrivate!]\n  \"Relay-compatible paging information\"\n  pageInfo: PageInfo!\n  \"Total count of notification targets\"\n  totalCount: Int\n}\ntype NotificationTargetEdgePrivate implements ConnectionEdge & NotificationTargetEdge {\n  \"Optional cursor to refer to this node\"\n  cursor: String!\n  \"Node element available through this edge\"\n  node: NotificationTargetPrivate!\n}\ntype NotificationTargetMutation {\n  \"Notification Target Mutation per provider\"\n  providers: NotificationTargetMutationProviders!\n}\ntype NotificationTargetMutationProviders {\n  \"\"\"\n  \n  ### API Permissions:\n  - `notification:Target-Platform:create`,\n  - `notification:Target-Platform:update`,\n  - `notification:Target-Platform:delete`\n  \"\"\"\n  aria: AriaNotificationTargetsMutationProvider!\n}\ntype NotificationTargetPrivate implements Node & NodeVersion & NotificationTarget {\n  \"The time this notification target was created\"\n  creationTime: DateTime!\n  \"Name of this notification target\"\n  displayName: String!\n  \"Enabled turns the notification target on/off\"\n  enabled: Boolean!\n  \"Node-compatible opaque global identifier\"\n  id: ID!\n  \"The last time this notification target was successfully updated\"\n  lastUpdateTime: DateTime!\n  \"Opaque version string for this graph node instance\"\n  nodeVersion: ID!\n  \"Unique identifier of the notification target instance\"\n  notificationTargetId: String!\n  \"Name for this notification target provider.\"\n  providerName: String!\n  \"Scoping entities that are included\"\n  scopingEntities: [Entity!]\n  \"Status holds details about the healthiness of the notification target\"\n  status: NotificationTargetStatus!\n  \"Notification target type\"\n  type: NotificationTargetTypePrivate!\n}\ntype NotificationTargetProperty {\n  name: String!\n  type: NotificationPropertyValueDataType!\n  value: Object\n}\ntype NotificationTargetStatus {\n  lastUpdateTime: DateTime\n  message: String\n  value: NotificationTargetStatusValue!\n}\ntype NotificationTargetTypeConnectionPrivate implements Connection & NotificationTargetTypeConnection {\n  \"Count of notification target types in current page\"\n  count: Int!\n  \"Relay-compatible connection edge\"\n  edges: [NotificationTargetTypeEdgePrivate!]\n  \"List of notification target types in current page\"\n  notificationTargetTypes: [NotificationTargetTypePrivate!]\n  \"Relay-compatible paging information\"\n  pageInfo: PageInfo!\n  \"Total count of notification target types\"\n  totalCount: Int\n}\ntype NotificationTargetTypeEdgePrivate implements ConnectionEdge & NotificationTargetTypeEdge {\n  \"Optional cursor to refer to this node\"\n  cursor: String!\n  \"Node element available through this edge\"\n  node: NotificationTargetTypePrivate!\n}\ntype NotificationTargetTypeInputProperty {\n  \"Is property value mandatory\"\n  isMandatory: Boolean!\n  \"The name of property\"\n  name: String!\n  \"Type of the property ex: String, JSON, Password, Integer, Float, Boolean\"\n  type: NotificationPropertyValueDataType!\n}\ntype NotificationTargetTypePrivate implements Node & NotificationTargetType {\n  \"Node-compatible opaque global identifier\"\n  id: ID!\n  \"\"\"\n  RequiresAddress shows whether notification targets of this type need an address to be passed in order to work.\n  Examples of address are email address, Slack channel, etc.\n  \"\"\"\n  requiresAddress: Boolean!\n  \"Notification target type\"\n  type: String!\n}\ntype NotificationTargetsProviderInfo {\n  \"Name for this notification rules provider - queries and mutations directed to this provider name will be sent to this provider.\"\n  providerName: String!\n}\n\"Direct access to individual notification target providers through per-provider fields.\"\ntype NotificationTargetsProviders {\n  \"\"\"\n  \n  ### API Permissions:\n  - `notification:Target-Platform:read`\n  \"\"\"\n  aria: AriaNotificationTargetsProvider\n}\ntype NotificationTargetsQuery {\n  notificationTargetsProviders: NotificationTargetsProviders!\n  \"\"\"\n  Query notification target types supported for given notification target provider\n  ### API Permissions:\n  - `notification:Target-*:read`\n  \"\"\"\n  queryNotificationTargetTypes(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Input query filter to help filtering output of the query\"\n    filter: QueryFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Name of the provider to query the notification target types for\"\n    providerName: String!\n  ): NotificationTargetTypeConnection\n  \"\"\"\n  Query notification targets supported for given notification target provider\n  ### API Permissions:\n  - `notification:Target-*:read`\n  \"\"\"\n  queryNotificationTargets(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Input query filter to help filtering output of the query\"\n    filter: QueryFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Name of the provider to query the notification target for\"\n    providerName: String!,\n    \"Sort order for results in the connection\"\n    sort: [QuerySort!]\n  ): NotificationTargetConnection\n}\ntype OAuthApp implements Node {\n  \"Time in seconds to access token expiration after it is issued\"\n  accessTokenTTLSecs: Int!\n  \"The time of creation\"\n  createdAt: DateTime!\n  \"The user who created the OAuth app\"\n  createdBy: User\n  \"The details of OAuth app that created this OAuth app in case this OAuth app is created by another OAuth app\"\n  createdByOAuthApp: OAuthApp\n  \"Description of the OAuth App\"\n  description: String\n  \"List of grant types that can be used to obtain a token with this client.\"\n  grantTypes: [OAuthAppGrantType!]!\n  \"Opaque globally scoped identifier of this node\"\n  id: ID!\n  \"The time of last update on OAuth app\"\n  lastUpdatedAt: DateTime!\n  \"Name of the OAuth App\"\n  name: String!\n  \"ID of the OAuth App\"\n  oauthAppId: String!\n  \"Entity to which oauthApp is scoped to. When scopingEntity is null, the OAuth app us scoped to the organization\"\n  scopingEntity: Entity\n}\ntype OAuthAppAccessToken {\n  \"JWT access token generated from the clientId and ClientSecret provided in input\"\n  accessToken: String!\n  \"Pre-prepared HTTP authorization header\"\n  authorization: String!\n  \"Number of seconds before this token expires from the time of issuance\"\n  expiresInSeconds: Int!\n}\ntype OAuthAppConnection implements Connection {\n  \"Count of OAuth apps in this page.\"\n  count: Int!\n  \"relay-compatible connection edge\"\n  edges: [OAuthAppEdge!]\n  oauthApps: [OAuthApp!]\n  pageInfo: PageInfo!\n  \"Optional total count of matching OAuth apps\"\n  totalCount: Int\n}\ntype OAuthAppCreationResult {\n  \"Time in seconds to access token expiration after it is issued\"\n  accessTokenTTLSecs: Int!\n  \"The time of creation\"\n  createdAt: DateTime\n  \"The user who created the OAuth app, it will be null if oAuthApp is created using another oAuthApp\"\n  createdBy: User\n  \"The client which created the OAuth app, it will be null if oAuthApp is created by user\"\n  createdByOAuthApp: OAuthApp\n  \"Description of the OAuth App\"\n  description: String\n  \"List of grant types that can be used to obtain a token with this client. \"\n  grantTypes: [OAuthAppGrantType!]!\n  \"Opaque globally scoped identifier of this node\"\n  id: ID\n  \"The time of last update on OAuth app\"\n  lastUpdatedAt: DateTime\n  \"Name of the OAuth App\"\n  name: String!\n  \"ID of the OAuth App\"\n  oauthAppId: String\n  \"A secret string used for authenticating as this OAuth App. Please make sure to copy the secret, there is no way retrieve the secret of the OAuth App once returned.\"\n  oauthAppSecret: String\n  \"Scoping Entity of OAuth app. scopingEntity will be null, if the OAuth App is created in Org scope.\"\n  scopingEntity: Entity\n  \"Type representing the status of the operation\"\n  status: OAuthAppMutationResultStatus!\n}\ntype OAuthAppDeletionResult {\n  \"Time in seconds to access token expiration after it is issued\"\n  accessTokenTTLSecs: Int\n  \"The time of creation\"\n  createdAt: DateTime\n  \"The user who created the OAuth app\"\n  createdBy: User\n  \"The client which created the OAuth app, it will be null if oAuthApp is created by user\"\n  createdByOAuthApp: OAuthApp\n  \"Description of the OAuth App\"\n  description: String\n  \"List of grant types that can be used to obtain a token with this client. \"\n  grantTypes: [OAuthAppGrantType!]\n  \"Opaque globally scoped identifier of this node\"\n  id: ID!\n  \"The time of last update on OAuth app\"\n  lastUpdatedAt: DateTime\n  \"Name of the OAuth App\"\n  name: String\n  \"ID of the OAuth App\"\n  oauthAppId: String!\n  \"Type representing the status of the operation\"\n  status: OAuthAppMutationResultStatus!\n}\ntype OAuthAppEdge implements ConnectionEdge {\n  cursor: String!\n  node: OAuthApp!\n}\ntype OAuthAppMutation {\n  \"\"\"\n  Mutation to create an OAuth app.\n  OAuth apps can only be created by Users having oauth app create permission in global scope.\n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  ### API Permissions:\n  - `auth:OAuthApp:create`\n  \"\"\"\n  create(input: [OAuthAppCreateInput]!): [OAuthAppCreationResult!]!\n  \"\"\"\n  Mutation to delete an OAuth app.\n  OAuth apps can only be delete by Users having oauth app delete permission in global scope.\n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  ### API Permissions:\n  - `auth:OAuthApp:delete`\n  \"\"\"\n  delete(oauthAppId: [String!]!): [OAuthAppDeletionResult!]!\n  \"Retrieve Client Credentials token for a given clientId and clientSecret of an OAuth application.\"\n  generateAccessTokenForOAuthApp(input: OAuthAppTokenInput!): OAuthAppAccessToken!\n  \"\"\"\n  Rotates the secret for one or more OAuth applications.\n  This mutation generates a new secret for the specified OAuth applications\n  and returns the updated secret details. The old secret will expire based on\n  the input.\n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  ### API Permissions:\n  - `auth:OAuthApp:update`\n  \"\"\"\n  rotateSecret(input: [OAuthAppRotateSecretInput!]!): [OAuthAppRotateSecretResult!]!\n  \"\"\"\n  Mutation to update fields of an OAuth app.\n  To update the secret of an OAuth app, please use changeSecret mutation.\n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  ### API Permissions:\n  - `auth:OAuthApp:update`\n  \"\"\"\n  update(input: [OAuthAppUpdateInput!]!): [OAuthAppUpdateResult!]!\n}\ntype OAuthAppMutationResultStatus {\n  \"Optional error message\"\n  errorMessage: String\n  \"Enum representing the status of the operation\"\n  status: OAuthAppMutationStatusEnum!\n}\ntype OAuthAppQuery {\n  \"\"\"\n  Query OAuth Apps created in the Org\n  ### API Permissions:\n  - `auth:OAuthApp:read`\n  \"\"\"\n  query(\n    \"Retrieve elements after the given cursor.\"\n    after: String,\n    \"Retrieve the first N elements in the response. Default is 10.\"\n    first: Int = 10,\n    \"Filter OAuth Apps by Ids\"\n    oauthAppId: [String!],\n    \"Filter OAuth Apps by scoping entity id\"\n    scopingEntityId: String,\n    \"Filter OAuth Apps by name using the searchTerm provided\"\n    searchTerm: String\n  ): OAuthAppConnection!\n}\ntype OAuthAppRotateSecretResult {\n  \"OAuth app id\"\n  oauthAppId: String!\n  \"\"\"\n  The newly generated secret for the OAuth application after a secret change request.\n  This secret should be securely stored as it will not be retrievable again.\n  Ensure to update any dependent configurations with this new secret.\n  \"\"\"\n  secret: String!\n  \"\"\"\n  The time in seconds after which the rotated secret expires.\n  After this period, the old secret will no longer be valid for authentication.\n  If the value is less than 60, the old secret will be removed immediately\n  \"\"\"\n  secretRotationExpirationInSeconds: Int!\n  \"Status of the secret change operation\"\n  status: OAuthAppMutationResultStatus!\n}\ntype OAuthAppUpdateResult {\n  \"Time in seconds to access token expiration after it is issued\"\n  accessTokenTTLSecs: Int\n  \"The time of creation\"\n  createdAt: DateTime\n  \"The user who created the OAuth app, it will be null if oAuthApp is created using another oAuthApp\"\n  createdBy: User\n  \"The client which created the OAuth app, it will be null if oAuthApp is created by user\"\n  createdByOAuthApp: OAuthApp\n  \"Description of the OAuth App\"\n  description: String\n  \"List of grant types that can be used to obtain a token with this client. \"\n  grantTypes: [OAuthAppGrantType!]\n  \"Opaque globally scoped identifier of this node\"\n  id: ID!\n  \"The time of last update on OAuth app\"\n  lastUpdatedAt: DateTime\n  \"Name of the OAuth App\"\n  name: String\n  \"ID of the OAuth App\"\n  oauthAppId: String!\n  \"Type representing the status of the operation\"\n  status: OAuthAppMutationResultStatus!\n}\n\"Observability Alert connection\"\ntype ObservabilityAlertConnection implements Connection & HubPolicyConnection {\n  \"count of polices on this page\"\n  count: Int!\n  \"Hub Policy edge\"\n  edges: [ObservabilityAlertEdge!]\n  \"Represents pagination information in Relay about the edges.\"\n  pageInfo: PageInfo!\n  \"Policies\"\n  policies: [ObservabilityAlert!]\n  \"Total count of polices\"\n  totalCount: Int\n}\n\"Observability Alert  edge\"\ntype ObservabilityAlertEdge implements ConnectionEdge & HubPolicyEdge {\n  \"Cursor is an opaque string, you can use it to request subsequent or preceding items in the list\"\n  cursor: String!\n  \"Policy node\"\n  node: ObservabilityAlert!\n}\n\"Basic authentication configuration\"\ntype ObservabilityAlertManagerBasicAuth {\n  \"Password for basic auth\"\n  password: String!\n  \"Username or identity for basic auth\"\n  username: String!\n}\n\"Response for AlertManager configuration operations\"\ntype ObservabilityAlertManagerConfigResponse {\n  \"The configuration data (for successful operations)\"\n  configuration: ObservabilityAlertManagerConfiguration\n  \"Operation success status\"\n  success: Boolean!\n}\n\"Complete AlertManager configuration with all components\"\ntype ObservabilityAlertManagerConfiguration {\n  \"Global configuration as YAML string\"\n  global: String\n  \"Inhibit rules configuration as YAML string\"\n  inhibitRules: String\n  \"Receivers configuration with all notification channels\"\n  receivers: ObservabilityAlertManagerReceiversConfig\n  \"Route configuration as YAML string\"\n  routes: String\n  \"Time interval configurations for scheduling\"\n  timeIntervals: [ObservabilityAlertManagerTimeInterval!]\n  \"Configuration version for optimistic locking\"\n  version: Int!\n  \"Complete YAML configuration as a string\"\n  yamlConfig: String\n}\n\"Email notification configuration\"\ntype ObservabilityAlertManagerEmailConfig {\n  \"Authentication password secret\"\n  authPassword: ObservabilityAlertManagerSecret\n  \"Authentication secret\"\n  authSecret: ObservabilityAlertManagerSecret\n  \"Email configuration as YAML string\"\n  receiverConfig: String!\n  \"Name of the receiver\"\n  receiverName: String!\n  \"TLS configuration for secure connections\"\n  tlsConfig: ObservabilityAlertManagerTlsConfig\n}\n\"HTTP configuration for external service communication\"\ntype ObservabilityAlertManagerHttpConfig {\n  \"Basic authentication configuration\"\n  basicAuth: ObservabilityAlertManagerBasicAuth\n  \"Bearer token secret for authentication\"\n  bearerToken: ObservabilityAlertManagerSecret\n  \"TLS configuration for secure connections\"\n  tlsConfig: ObservabilityAlertManagerTlsConfig\n}\n\"PagerDuty notification configuration\"\ntype ObservabilityAlertManagerPagerDutyConfig {\n  \"HTTP configuration for API calls\"\n  httpConfig: ObservabilityAlertManagerHttpConfig\n  \"PagerDuty configuration as YAML string\"\n  receiverConfig: String!\n  \"Name of the receiver\"\n  receiverName: String!\n  \"PagerDuty routing key secret\"\n  routingKey: ObservabilityAlertManagerSecret\n  \"PagerDuty service key secret\"\n  serviceKey: ObservabilityAlertManagerSecret\n}\n\"Receivers configuration containing all notification channels\"\ntype ObservabilityAlertManagerReceiversConfig {\n  \"Email notification configurations\"\n  emailConfigs: [ObservabilityAlertManagerEmailConfig!]\n  \"PagerDuty notification configurations\"\n  pagerdutyConfigs: [ObservabilityAlertManagerPagerDutyConfig!]\n  \"Slack notification configurations\"\n  slackConfigs: [ObservabilityAlertManagerSlackConfig!]\n  \"Webhook notification configurations\"\n  webhookConfigs: [ObservabilityAlertManagerWebhookConfig!]\n}\n\"Secret configuration for sensitive data\"\ntype ObservabilityAlertManagerSecret {\n  \"The secret value (may be masked in responses)\"\n  secret: String!\n}\n\"Slack notification configuration\"\ntype ObservabilityAlertManagerSlackConfig {\n  \"HTTP configuration for API calls\"\n  httpConfig: ObservabilityAlertManagerHttpConfig\n  \"Slack configuration as YAML string\"\n  receiverConfig: String!\n  \"Name of the receiver\"\n  receiverName: String!\n  \"Slack API URL secret\"\n  slackApiUrl: ObservabilityAlertManagerSecret\n}\n\"Time interval configuration for scheduling alerts\"\ntype ObservabilityAlertManagerTimeInterval {\n  \"Configuration as YAML string\"\n  timeIntervalConfig: String!\n  \"Name of the time interval\"\n  timeIntervalName: String!\n}\n\"TLS certificates configuration\"\ntype ObservabilityAlertManagerTlsCertificates {\n  \"Certificate in PEM format\"\n  certPem: String!\n  \"Private key in PEM format\"\n  privateKeyPem: String!\n}\n\"TLS configuration for secure connections\"\ntype ObservabilityAlertManagerTlsConfig {\n  \"Certificate Authority certificate\"\n  ca: String\n  \"Skip TLS certificate verification\"\n  insecureSkipVerify: Boolean!\n  \"Server name for TLS verification\"\n  serverName: String\n  \"TLS certificates configuration\"\n  tlsCertificates: ObservabilityAlertManagerTlsCertificates\n}\n\"Webhook notification configuration\"\ntype ObservabilityAlertManagerWebhookConfig {\n  \"HTTP configuration for webhook calls\"\n  httpConfig: ObservabilityAlertManagerHttpConfig\n  \"Webhook configuration as YAML string\"\n  receiverConfig: String!\n  \"Name of the receiver\"\n  receiverName: String!\n}\n\"mutations for Observability Alert provider\"\ntype ObservabilityAlertMutationProvider implements HubPolicyMutationProvider {\n  \"\"\"\n  create Observability Metric Alert definition\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `observability:ObservabilityAlert:create`,\n  - `observability:ObservabilityAlert:update`\n  \"\"\"\n  createMetricAlert(input: ObservabilityMetricAlertCreateInput!): ObservabilityMetricAlert!\n  \"\"\"\n  delete observability alerts\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `observability:ObservabilityAlert:create`,\n  - `observability:ObservabilityAlert:update`\n  \"\"\"\n  deleteAlerts(input: [HubPolicyIdInput!]): ObservabilityAlertUpdateResult\n  \"name of provider : Alert\"\n  name: String!\n  \"\"\"\n  Enable/Disable an alert\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `observability:ObservabilityAlert:create`,\n  - `observability:ObservabilityAlert:update`\n  \"\"\"\n  updateAlertStatus(input: ObservabilityAlertStatusUpdateInput): ObservabilityAlertUpdateResult!\n  \"\"\"\n  Update Observability Log Alert definition\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `observability:ObservabilityAlert:update`\n  \"\"\"\n  updateLogAlert(input: ObservabilityLogAlertUpdateInput!): ObservabilityLogAlert!\n  \"\"\"\n  Update Observability Metric Alert definition\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `observability:ObservabilityAlert:create`,\n  - `observability:ObservabilityAlert:update`\n  \"\"\"\n  updateMetricAlert(input: ObservabilityMetricAlertUpdateInput!): ObservabilityMetricAlert!\n  \"\"\"\n  Update Observability Runbook Dashboard for an Alert definition having specific runbook template. Returns ids of the policies that are affected.\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `observability:ObservabilityAlert:update`\n  \"\"\"\n  updateRunbookDashboard(input: ObservabilityRunbookAlertUpdateInput!): ObservabilityAlertUpdateResult\n}\ntype ObservabilityAlertNotificationCriteria {\n  \"based on the name of the Observability Alert\"\n  name: String\n  \"This is the originatingEntity of the Observability Alert\"\n  resource: String\n  \"based on the severity of the Observability Alert\"\n  severities: [InsightSeverity]\n  \"can be a list of source from AWS/Azure etc\"\n  sources: [ObservationSource]\n  \"based on the status of the Observability Alert\"\n  statuses: [ObservationStatus]\n}\ntype ObservabilityAlertNotificationRule implements Node & NodeVersion & NotificationRule {\n  \"User who created the notification rule\"\n  createdBy: User\n  \"Creation time of the notification rule\"\n  creationTime: DateTime!\n  \"List of email addresses the notifications of this rule needs to be delivered to. Should be provided when notification target type is EMAIL\"\n  emailAddresses: [String!]\n  \"Enabled turns the notification rule on/off\"\n  enabled: Boolean!\n  \"Opaque global ID. We will not persist this. For Query response this ID will be given base64 encoding of notificationRuleId\"\n  id: ID!\n  \"Last update time of the notification rule\"\n  lastUpdateTime: DateTime!\n  \"Name of the notification rule\"\n  name: String!\n  \"Versioning ID. We will populate this with lastUpdateTime, so will not be persisted.\"\n  nodeVersion: ID!\n  \"Criteria to notify\"\n  notificationCriteria: ObservabilityAlertNotificationCriteria\n  \"ID of the notification rule\"\n  notificationRuleId: String!\n  \"List of notification targets that this notification needs to be delivered to\"\n  notificationTargets: [AriaNotificationTarget!]\n  \"Policy ID\"\n  policyId: String\n  \"Provider name of the notification rule\"\n  provider: String!\n  \"\"\"\n  Slack channel the notifications of this rule needs to be delivered to. Should be provided when notification target type is SLACK,\n  If not provided will be notified to default configured channel\"\n  \"\"\"\n  slackChannel: String\n  \"User who updated this last\"\n  updatedBy: User\n}\ntype ObservabilityAlertNotificationRuleConnection implements Connection & NotificationRuleConnection {\n  \"Count of elements in the current page\"\n  count: Int!\n  \"Edges to nodes available through the connection\"\n  edges: [ObservabilityAlertNotificationRuleConnectionEdge!]\n  notificationRules: [ObservabilityAlertNotificationRule!]\n  \"Paging support\"\n  pageInfo: PageInfo!\n  \"Optional total elements count across all pages when available\"\n  totalCount: Int\n}\ntype ObservabilityAlertNotificationRuleConnectionEdge implements ConnectionEdge & NotificationRuleConnectionEdge {\n  \"Optional cursor to refer to this node\"\n  cursor: String\n  \"Node element available through this edge\"\n  node: ObservabilityAlertNotificationRule!\n}\ntype ObservabilityAlertNotificationRuleMutationProvider implements NotificationRulesMutationProvider {\n  \"\"\"\n  Delete a notification rule\n  ### API Permissions:\n  - `observability:ObservabilityAlert:create`,\n  - `observability:ObservabilityAlert:update`\n  \"\"\"\n  deleteObservabilityAlertNotificationRule(notificationRuleId: String!): ObservabilityAlertNotificationRule\n  \"\"\"\n  Delete notification template\n  ### API Permissions:\n  - `observability:ObservabilityAlert:create`,\n  - `observability:ObservabilityAlert:update`\n  \"\"\"\n  deleteObservabilityAlertNotificationTemplate(notificationTargetId: [String!]!): [ObservabilityAlertNotificationTemplate!]\n  \"Information about this provider\"\n  name: String\n  \"\"\"\n  Create/update notification rules. Also handles bulk notification target update.\n  ### API Permissions:\n  - `observability:ObservabilityAlert:create`,\n  - `observability:ObservabilityAlert:update`\n  \"\"\"\n  upsertObservabilityAlertNotificationRules(ruleInput: ObservabilityAlertNotificationRuleInput!): [ObservabilityAlertNotificationRule]\n  \"\"\"\n  Create/update notification template.\n  ### API Permissions:\n  - `observability:ObservabilityAlert:create`,\n  - `observability:ObservabilityAlert:update`\n  \"\"\"\n  upsertObservabilityAlertNotificationTemplate(notificationTemplateInput: ObservabilityAlertNotificationTemplateInput!): ObservabilityAlertNotificationTemplate\n}\ntype ObservabilityAlertNotificationRulesProvider implements NotificationRulesProvider {\n  \"Information about this provider\"\n  providerInfo: NotificationRulesProviderInfo!\n  \"\"\"\n  Query list of Notification Rules with selected list of filters\n  ### API Permissions:\n  - `observability:ObservabilityAlert:read`\n  \"\"\"\n  queryNotificationRules(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"optional filter of field names\"\n    filter: QueryFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"ObservabilityAlertNotificationRule filter with zero or more filter parameters\"\n    observabilityAlertNotificationRuleFilter: ObservabilityAlertNotificationRuleFilter,\n    \"Sort order for results in ObservabilityAlertConnection\"\n    sort: [QuerySort!]\n  ): ObservabilityAlertNotificationRuleConnection\n  \"\"\"\n  Query for specific notification rule by notification rule Id\n  ### API Permissions:\n  - `observability:ObservabilityAlert:read`\n  \"\"\"\n  queryObservabilityAlertNotificationRuleById(\n    \"Array of notification rule id's to query\"\n    notificationRuleId: String!\n  ): ObservabilityAlertNotificationRule\n  \"\"\"\n  Query for specific notification rule by notification rule Ids\n  ### API Permissions:\n  - `observability:ObservabilityAlert:read`\n  \"\"\"\n  queryObservabilityAlertNotificationRuleByIds(\n    \"Array of notification rule id's to query\"\n    notificationRuleIds: [String!]!\n  ): [ObservabilityAlertNotificationRule]\n  \"\"\"\n  Query alert notification template by notification target id\n  ### API Permissions:\n  - `observability:ObservabilityAlert:read`\n  \"\"\"\n  queryObservabilityAlertNotificationTemplateByTargetId(\n    \"Notification target id\"\n    notificationTargetId: String!\n  ): ObservabilityAlertNotificationTemplate\n}\ntype ObservabilityAlertNotificationTemplate implements Node & NodeVersion {\n  \"Opaque global ID. We will not persist this. For Query response this ID will be given base64 encoding of notificationTargetId\"\n  id: ID!\n  \"Opaque version string for this graph node instance\"\n  nodeVersion: ID!\n  \"Opaque identifier for a notification template, notification target identifier to which the notification template content is associated\"\n  notificationTargetId: ID!\n  \"Content for notification template\"\n  notificationTemplate: String!\n  \"Notification template type\"\n  notificationTemplateType: ObservabilityNotificationTemplateType!\n}\ntype ObservabilityAlertOverrideRule {\n  \"Hub entity name which needs override\"\n  labelName: String!\n  \"Entity values which needs to be applied for override\"\n  labelValues: [String!]\n  \"This will define an unique name to a override rule\"\n  ruleName: String!\n  \"alert tags\"\n  tags: [Tag]\n  \"Override values which will be applied for defined entities\"\n  threshold: ObservabilityMetricAlertThresholdCondition!\n}\n\"provider for alert query\"\ntype ObservabilityAlertQueryProvider implements HubPolicyQueries & HubPolicyQueriesProvider {\n  \"name of provider : ObservabilityAlert\"\n  name: String!\n  \"\"\"\n  Query to validate stats query and validate tags required and number of series\n  ### API Permissions:\n  - `observability:ObservabilityStat:read`\n  \"\"\"\n  observabilityAlertValidation(\n    \"Optional list of entityIds to query for stats. If no entityIds are specified, the stats are queried based on the input\"\n    entityId: [EntityId!],\n    \"Entity Type for which test query is triggered\"\n    entityType: ObservabilityAlertEntityType,\n    \"Query parameters\"\n    input: StatsInput\n  ): ObservabilityAlertValidationResponse!\n  \"Information about this provider\"\n  providerInfo: HubPolicyProviderInfo!\n  \"\"\"\n  Get policy details based on filter criteria\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `observability:ObservabilityAlert:read`\n  \"\"\"\n  queryHubPolicies(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"alert specific filter\"\n    alertFilter: ObservabilityAlertFilterInput,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Optional filters to filter policies that are fetched\"\n    filter: QueryFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Results are sorted as per fields and order specified. Supported fields are policyName, createdBy and updatedBy\"\n    sort: [QuerySort!]\n  ): ObservabilityAlertConnection\n  \"\"\"\n  Get policy run details\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `observability:ObservabilityAlert:read`\n  \"\"\"\n  queryHubPolicyRuns(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Optional filters to filter policy runs that are fetched.\"\n    filter: QueryFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Results are sorted as per fields and order specified. Supported fields are name, status. Default Sort will be on LastUpdateTime\"\n    sort: [QuerySort!]\n  ): HubPolicyRunConnection\n  \"\"\"\n  Get usage limit status for a given resource type. Also returns status if limit is breached\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `observability:ObservabilityAlert:read`\n  \"\"\"\n  queryUsageLimit(\n    \"limits are applied to specific resource types\"\n    resourceType: [ObservabilityResourceType!]\n  ): [UsageLimitResponse]\n}\n\"A point-in-time observation about the state of something in the system which may interest our insight service\"\ntype ObservabilityAlertSilence implements Node {\n  \"comment section\"\n  comment: String!\n  \"creator of the silence\"\n  creator: String!\n  \"End time of silence\"\n  endTimeInMillis: DateTime!\n  \"Ensemble generated id unique for the Observation. UUID Primary key format agnostic to the cloud/source provider and will be used for Insight to Observation mapping\"\n  id: ID!\n  \"Matcher of silence\"\n  matchers: [ObservabilityMatchers]\n  \"Silence id\"\n  silenceId: String!\n  \"Start time of silence\"\n  startTimeInMillis: DateTime!\n  \"state of a silence\"\n  state: ObservabilityAlertSilenceState!\n}\ntype ObservabilityAlertSilenceConnection implements Connection {\n  count: Int!\n  edges: [ObservabilityAlertSilenceEdge!]\n  pageInfo: PageInfo!\n  probableCauseCount: Int\n  silences: [ObservabilityAlertSilence!]\n  totalCount: Int\n}\ntype ObservabilityAlertSilenceEdge implements ConnectionEdge {\n  cursor: String!\n  node: ObservabilityAlertSilence!\n}\ntype ObservabilityAlertUpdateFailure {\n  \"Error\"\n  errorMessage: String\n  \"Versioning ID\"\n  nodeVersion: ID!\n  \"Unique identifier for the policy\"\n  policyId: String!\n}\ntype ObservabilityAlertUpdateResult {\n  \"Update/Delete/Enable/Disable failures with error messages\"\n  failure: [ObservabilityAlertUpdateFailure!]\n  \"Total count of updated alert policies update failed\"\n  failureCount: Int\n  \"Hub policies successfully updated/deleted/enabled/disabled. For delete operation, this will contain the hub policy before deletion\"\n  success: [ObservabilityAlert!]\n  \"Total count of successfully updated alert policies\"\n  successCount: Int\n}\n\"Observability Alert Test Query Response\"\ntype ObservabilityAlertValidationResponse {\n  \"Stats Query Series Analysis Results\"\n  seriesDataAnalysisStatus: StatsQuerySeriesDataAnalysisStatus!\n  \"Stats Query Series Analysis Result Reason eg: Series > 50 etc\"\n  seriesDataAnalysisStatusReason: String!\n  \"Stats Query Response\"\n  statsQueryResponse: [Stats!]\n}\ntype ObservabilityCreateAlertSilenceResponse {\n  \"Error to display in case of error\"\n  errorString: String\n  \"Status for create silence\"\n  status: ObservabilityAlertConfigUpdateStatus!\n}\ntype ObservabilityDeleteAlertSilenceResponse {\n  \"Error to display in case of error\"\n  errorString: String\n  \"Status for deleting silence\"\n  status: ObservabilityAlertConfigUpdateStatus!\n}\n\"Observability Log Alert to trigger Alerts on logs\"\ntype ObservabilityLogAlert implements HubPolicy & Node & NodeVersion & ObservabilityAlert {\n  \"Alert evaluation status\"\n  alertStatus: ObservabilityAlertStatus!\n  \"Type of the Observability Alert\"\n  alertType: ObservabilityAlertType!\n  \"CSP user who created hub policy\"\n  createdBy: User!\n  \"Timestamp at which hub policy is created. Expressed in UTC ISO-8601 format\"\n  creationTime: DateTime!\n  \"CSP project id associated with policy\"\n  cspProjects: [Entity!] @deprecated(reason: \"No longer supported\")\n  \"Dashboard ID of the observability alert custom runbook\"\n  dashboardId: String\n  \"Policy description\"\n  description: LocalizedString\n  \"Evaluation is enabled for this policy\"\n  enabled: Boolean!\n  \"ID of entity on which observability alert is triggered\"\n  entityId: String @deprecated(reason: \"Use `entityInfo` instead\")\n  \"Entity from which the observation alert is triggered\"\n  entityInfo: Entity!\n  \"Type of entity on which observability alert is triggered\"\n  entityType: String! @deprecated(reason: \"Use `entityInfo` instead\")\n  \"Opaque identifier for a policy, to be used to identify a policy uniquely in hub graph\"\n  id: ID!\n  \"Flag defining if observability alert is custom\"\n  isCustomAlert: Boolean!\n  \"Last evaluation run time\"\n  lastRunTime: DateTime\n  \"Timestamp at which hub policy is updated. Expressed in UTC ISO-8601 format\"\n  lastUpdateTime: DateTime\n  \"Opaque version string for this graph node instance\"\n  nodeVersion: ID!\n  \"Notification Rule\"\n  notificationRule: ObservabilityAlertNotificationRule\n  \"unique policy identifier/alert identifier\"\n  policyId: String!\n  \"Name of the Alert\"\n  policyName: LocalizedString!\n  \"provider name for this policy\"\n  policyProvider: String!\n  \"Log Alert rule\"\n  rule: ObservabilityLogAlertRule!\n  \"Template ID of the observability alert runbook\"\n  runbookTemplateId: String\n  \"Source for alerts\"\n  source: String!\n  \"CSP user who updated hub policy\"\n  updatedBy: User\n}\n\"Observability Log Alert Condition\"\ntype ObservabilityLogAlertCondition {\n  \"Operator to be applied\"\n  operator: ObservabilityAlertThresholdOperator!\n  \"Threshold to be applied\"\n  threshold: ObservabilityLogAlertThresholdCondition!\n}\n\"Observability Log Alert rule\"\ntype ObservabilityLogAlertRule {\n  \"Aggregation which needs to be applied on queried logs\"\n  aggregation: ObservabilityAggregationFunction!\n  \"Observability alerting condition which needs to be applied on queried logs\"\n  alertCondition: ObservabilityLogAlertCondition!\n  \"Frequency of alert evaluation in minutes\"\n  alertEvaluationFrequencyInMins: Int!\n  \"EntityIds against which query will be applied\"\n  entityId: [String!]\n  \"Optional namespace from which to collect logs\"\n  namespace: String\n  \"Query options to filter logs\"\n  queryString: ObservabilityQueryFilterType!\n  \"\"\"\n  If provided and the value is positive non-zero, then this indicates window in minutes the condition needs to be inactive/false to resolve Alert.\n  If not provided or the value is either zero or negative, then this indicates that the log alert doesn't need resolution management and is stateless.\n  \"\"\"\n  resolveWindowInMins: Int\n  \"Window in minutes the condition needs to be active to trigger the alert\"\n  triggerWindowInMins: Int!\n}\n\"Log Alert Threshold condition\"\ntype ObservabilityLogAlertThresholdCondition {\n  \"Severity of the alert\"\n  alertSeverity: ObservabilityAlertSeverity!\n  \"Threshold to compare the aggregated value with\"\n  thresholdValue: Float!\n}\n\"Log query to fetch logs from hub\"\ntype ObservabilityLogQuery {\n  \"Filter logs using Entity Id\"\n  entityId: [String!]\n  \"Log query display name\"\n  name: String!\n  \"Query logs by selecting fields via logical operators\"\n  queryFilter: ObservabilityQueryFilterType!\n}\ntype ObservabilityMatchers {\n  \"Key for Matchers\"\n  key: String!\n  \"Operators, can be regex like DOES_NOT_CONTAINS(!~), CONTAINS(=~), or EQUAL(=), NOT_EQUAL(!=)\"\n  operator: ObservabilityMatchersOperator!\n  \"Value for Matchers\"\n  value: String!\n}\n\"Observability Metric Alert to trigger Alerts on metrics\"\ntype ObservabilityMetricAlert implements HubPolicy & Node & NodeVersion & ObservabilityAlert {\n  \"Alert evaluation status\"\n  alertStatus: ObservabilityAlertStatus!\n  \"Type of the Observability Alert\"\n  alertType: ObservabilityAlertType!\n  \"CSP user who created hub policy\"\n  createdBy: User!\n  \"Timestamp at which hub policy is created. Expressed in UTC ISO-8601 format\"\n  creationTime: DateTime!\n  \"CSP project id associated with policy\"\n  cspProjects: [Entity!] @deprecated(reason: \"No longer supported\")\n  \"Dashboard ID of the observability alert custom runbook\"\n  dashboardId: String\n  \"Policy description\"\n  description: LocalizedString\n  \"Evaluation is enabled for this policy\"\n  enabled: Boolean!\n  \"ID of entity on which observability alert is triggered\"\n  entityId: String @deprecated(reason: \"Use `entityInfo` instead\")\n  \"Entity from which the observation alert is triggered\"\n  entityInfo: Entity\n  \"Type of entity on which observability alert is triggered\"\n  entityType: String! @deprecated(reason: \"Use `entityInfo` instead\")\n  \"Opaque identifier for a policy, to be used to identify a policy uniquely in hub graph\"\n  id: ID!\n  \"Flag defining if observability alert is custom\"\n  isCustomAlert: Boolean!\n  \"Last evaluation run time\"\n  lastRunTime: DateTime\n  \"Timestamp at which hub policy is updated. Expressed in UTC ISO-8601 format\"\n  lastUpdateTime: DateTime\n  \"Opaque version string for this graph node instance\"\n  nodeVersion: ID!\n  \"Notification Rule\"\n  notificationRule: ObservabilityAlertNotificationRule\n  \"unique policy identifier/alert identifier\"\n  policyId: String!\n  \"Name of the Alert\"\n  policyName: LocalizedString!\n  \"provider name for this policy\"\n  policyProvider: String!\n  \"Metric Alert rule\"\n  rule: ObservabilityMetricAlertRule!\n  \"Template ID of the observability alert runbook\"\n  runbookTemplateId: String\n  \"Source for alerts\"\n  source: String!\n  \"Type of the Observability Alert Threshold\"\n  thresholdType: ObservabilityAlertThresholdType!\n  \"CSP user who updated hub policy\"\n  updatedBy: User\n}\n\"Observability Metric Alert Condition\"\ntype ObservabilityMetricAlertCondition {\n  \"Frequency of alert evaluation in minutes\"\n  alertEvaluationFrequencyInMins: Int!\n  \"Alert will be evaluated only for these entities\"\n  includedEntityIds: [String]\n  \"Operator to be applied\"\n  operator: ObservabilityAlertThresholdOperator!\n  \"override rule per entity\"\n  overrideRules: [ObservabilityAlertOverrideRule]\n  \"Window in minutes the condition needs to be inactive/false to resolve Alert\"\n  resolveWindowInMins: Int!\n  \"Default rule name\"\n  ruleName: String!\n  \"alert tags\"\n  tags: [Tag]\n  \"Threshold to be applied\"\n  threshold: ObservabilityMetricAlertThresholdCondition!\n  \"Window in minutes the condition needs to be active to trigger Alert\"\n  triggerWindowInMins: Int!\n}\n\"Observability Metric Alert rule\"\ntype ObservabilityMetricAlertRule {\n  \"Observability Alerting condition on threshold\"\n  alertCondition: ObservabilityMetricAlertCondition!\n  \"Optional namespace from which to collect stats\"\n  namespace: String\n  \"Prometheus query expression used to evaluate threshold on\"\n  queryString: String!\n  \"Optional query string which will contain addition metadata for above queryString\"\n  queryStringMetadata: String\n}\n\"metric Alert Threshold condition\"\ntype ObservabilityMetricAlertThresholdCondition {\n  \"Severity of the alert\"\n  alertSeverity: ObservabilityAlertSeverity!\n  \"\"\"\n  Sensitivity measure used for detecting violations from baseline.\n  0 - Highest sensitivity\n  100 - Lowest sensitivity\n  \"\"\"\n  confidenceLevel: Int\n  \"Threshold bound describing type of filtering required for dynamic alerts ex: LOWER, UPPER, BOTH\"\n  direction: ObservabilityAlertDynamicThresholdDirection\n  \"Threshold to compare the metric value with\"\n  thresholdValue: Float!\n}\n\"Metric query to fetch stats from hub\"\ntype ObservabilityMetricQuery {\n  \"Metric chart type, default to LINE if not specified\"\n  chartType: ObservabilityMetricChartType\n  \"Metric query display name\"\n  name: String!\n  \"Stats query string\"\n  queryString: String!\n}\ntype ObservabilityNamespace {\n  \"name of the namespace\"\n  name: String!\n}\ntype ObservabilityQuery {\n  \"\"\"\n  Query event groups\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `observability:ObservabilityLog:read`\n  \"\"\"\n  queryEventGroups(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Optionally filter by entityIds\"\n    entityId: [EntityId!]!,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Input to get event groups\"\n    input: EventGroupInput!\n  ): EventGroupConnection\n  \"\"\"\n  Query event stats\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `observability:ObservabilityLog:read`\n  \"\"\"\n  queryEventStats(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Optionally filter by entityIds\"\n    entityId: [EntityId!]!,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Input to get event stats\"\n    input: EventStatsInput!\n  ): EventStatsConnection\n  \"\"\"\n  Query events.\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `observability:ObservabilityLog:read`\n  \"\"\"\n  queryEvents(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Optionally filter by entityIds\"\n    entityId: [EntityId!]!,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Input to get events\"\n    input: EventInput!\n  ): EventConnection\n  \"\"\"\n  \n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `observability:ObservabilityLog:read`\n  \"\"\"\n  queryExceptionGroups(after: String, entityId: [EntityId!]!, first: Int = 10, input: ExceptionGroupInput): ExceptionGroupConnection\n  \"\"\"\n  \n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `observability:ObservabilityLog:read`\n  \"\"\"\n  queryExceptionStats(after: String, entityId: [EntityId!]!, first: Int = 10, input: ExceptionStatsInput): ExceptionStatsResponse\n  \"\"\"\n  \n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `observability:ObservabilityLog:read`\n  \"\"\"\n  queryExceptionTrends(after: String, entityId: [EntityId!]!, first: Int = 10, input: ExceptionTrendInput): ExceptionTrendResponse\n  \"\"\"\n  Query exceptions.\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `observability:ObservabilityLog:read`\n  \"\"\"\n  queryExceptions(after: String, entityId: [EntityId!]!, first: Int = 10, input: ExceptionInput): ExceptionConnection\n  \"\"\"\n  Query Log Pattern Statistics\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `observability:ObservabilityLog:read`\n  \"\"\"\n  queryLogPatternStats(\n    \"Optionally filter by entityIds\"\n    entityId: [EntityId!],\n    \"Number of log types to be returned\"\n    first: Int = 50,\n    \"Filters for querying log pattern\"\n    input: LogPatternInput!\n  ): LogPatternStatsResponse\n  \"\"\"\n  Query Log Patterns\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `observability:ObservabilityLog:read`\n  \"\"\"\n  queryLogPatterns(\n    \"Optionally filter by entityIds\"\n    entityId: [EntityId!],\n    \"Number of log types to be returned\"\n    first: Int = 50,input: LogPatternInput  ): LogPatternResponse\n  \"\"\"\n  Query log records.\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `observability:ObservabilityLog:read`\n  \"\"\"\n  queryLogs(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Optionally filter by entityIds\"\n    entityId: [EntityId!],\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,input: LogInput  ): LogConnection\n  \"\"\"\n  Query Log Schema. Returns list of fields and their metadata.\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `observability:ObservabilityLog:read`\n  \"\"\"\n  queryLogsSchema(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Optionally filter by entityIds\"\n    entityId: [EntityId],\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"namespace from which schema needs to be returned\"\n    namespace: String!\n  ): LogSchemaConnection\n  \"\"\"\n  Get list of Observability namespaces\n  \n  Namespace should be used when querying for observability data\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `observability:ObservabilityLog:read`\n  \"\"\"\n  queryObservabilityNamespaces: [ObservabilityNamespace!]\n}\n\"Type representation to capture query filter parameters.\"\ntype ObservabilityQueryFilterType {\n  \"performs 'and' for embedded query filters - does not include top-level field/operator/value in operation\"\n  and: [ObservabilityQueryFilterType!]\n  \"\"\"\n  The field name to use for the filter.\n  Nested field names should use the dot notation.\n  For example `tags.<name>` or `namespaces.<namespaceName>.properties.<propName>`\n  \"\"\"\n  field: String\n  \"performs 'not' for embedded query filter - does not include top-level field/operator/value in operation\"\n  not: [ObservabilityQueryFilterType!]\n  \"The operator to be used for comparison\"\n  operator: QueryFilterOperator\n  \"performs 'or' for embedded query filters - does not include top-level field/operator/value in operation\"\n  or: [ObservabilityQueryFilterType!]\n  \"The values to use for comparison\"\n  values: [Object!]\n}\n\"Troubleshooting steps for an observability alert\"\ntype ObservabilityRunbook implements Node {\n  \"Runbook description\"\n  description: String\n  \"Opaque unique id of an ObservabilityRunbook\"\n  id: ID!\n  \"Runbook name\"\n  name: String!\n  \"List of runbook steps\"\n  runbookSteps: [ObservabilityRunbookStep!]!\n  \"Template ID of the observability alert runbook\"\n  runbookTemplateId: String!\n}\n\"Troubleshooting step\"\ntype ObservabilityRunbookStep {\n  \"Runbook step description\"\n  description: String\n  \"List of log queries\"\n  logQueries: [ObservabilityLogQuery!]\n  \"List of metric queries\"\n  metricQueries: [ObservabilityMetricQuery!]\n  \"Runbook step name\"\n  name: String!\n  \"Metric/log query time range is timeOffsetInMin before/after alert firing time\"\n  timeOffsetInMin: Int\n}\ntype ObservabilityUpdateAlertSilenceResponse {\n  \"Error to display in case of error\"\n  errorString: String\n  \"Status for updating silence\"\n  status: ObservabilityAlertConfigUpdateStatus!\n}\n\"A point-in-time observation about the state of something in the system which may interest our insight service\"\ntype Observation implements Node {\n  \"Entity type for which observation belongs to\"\n  alertEntityType: ObservabilityAlertEntityType\n  \"Contains native payload of observation. TODO alternative is to define sub-types with additional fields\"\n  body: JSON\n  \"Time at which the observation generated at source. Expressed in UTC ISO-8601 format\"\n  creationTime: DateTime!\n  description: String\n  \"Optional hyperlink of observation source\"\n  hyperLinks: [HyperLink!]\n  id: ID!\n  \"impacts of observation w.r.t. one or more dimensions/measures\"\n  impacts: [InsightImpact]!\n  \"Inferred tags\"\n  inferredTags: [Tag]\n  \"\"\"\n  Details of insights related to observation\n  ### API Permissions:\n  - `observability:ObservabilityAlert:read`\n  \"\"\"\n  insightConnection(\n    \"Optional additional field filters.\"\n    filter: QueryFilter,\n    \"Most recent first\"\n    mostRecentFirst: Boolean = true @deprecated(reason: \"Refer to sort!\"),\n    \"Sort order for results in insightConnection\"\n    sort: [QuerySort!]\n  ): InsightConnection\n  \"Transient observations are expected to have a follow-up observation indicating the end of a insight sequence\"\n  isTransient: Boolean\n  \"Time at which the observation is updated at source. Expressed in UTC ISO-8601 format\"\n  lastUpdateTime: DateTime!\n  \"Alert name or definition\"\n  name: String\n  \"Ensemble generated id unique for the Observation. UUID Primary key format agnostic to the cloud/source provider and will be used for Insight to Observation mapping\"\n  observationId: ID!\n  \"status of observation based on point-product's observation status e.g. NEW\"\n  observationStatus: ObservationStatus!\n  \"Time at which the observation was received. Expressed in UTC ISO-8601 format\"\n  observationTime: DateTime!\n  \"type of observation, which is defined by observation providers. e.g. VROPS-Alert:Infrastructure\"\n  observationType: String!\n  \"Entities from which the observation will be originated\"\n  originatingEntities: [Entity!]\n  \"entityIds from which the observation will be originated\"\n  originatingEntityIds: [EntityId!] @deprecated(reason: \"Refer to originatingEntities field!\")\n  \"originating observation id which can be from point-product. e.g. vrn:<org>/provider:VROPS/Alert:<VROPS-Alert-uuid>\"\n  originatingObservationId: String!\n  \"originating per-product entityIds\"\n  originatingProductEntityIds: [EntityId!]\n  policy: ObservabilityAlert\n  \"Severity of an observation from source\"\n  severity: InsightSeverity\n  \"Source of the observation\"\n  source: ObservationSource!\n  \"suggested trigger type of insight that should be created from this observation, if known e.g. ANOMALOUS\"\n  suggestedTriggerType: InsightTriggerType\n  \"Custom tags\"\n  tags: [Tag!]\n}\ntype ObservationAggregationItem implements CommonAggregationItem {\n  \"Count of instances of the given value\"\n  count: Long!\n  subAggregations: [ObservationAggregationItems!]\n  \"field value\"\n  value: String!\n}\ntype ObservationAggregationItems implements CommonAggregationItems {\n  \"Number of distinct buckets\"\n  bucketCount: Long!\n  buckets: [ObservationAggregationItem!]\n  \"Field key for which values are being aggregated.\"\n  field: String!\n}\ntype ObservationAggregations implements CommonAggregations {\n  aggregations: [ObservationAggregationItems!]\n  totalCount: Long!\n}\ntype ObservationConnection implements Connection {\n  count: Int!\n  edges: [ObservationEdge!]\n  observations: [Observation!]\n  originatingEntities: [Entity!]\n  pageInfo: PageInfo!\n  probableCauseCount: Int\n  sources: [ObservationSource!]\n  totalCount: Int\n}\ntype ObservationCountBySource {\n  count: Int!\n  source: ObservationSource!\n}\ntype ObservationEdge implements ConnectionEdge {\n  cursor: String!\n  node: Observation!\n}\n\"Total Alert Count for Given Entity\"\ntype ObservationEntityAlertCountResponse {\n  \"Entity Info\"\n  entity: Entity!\n  \"Total count of alerts for entity\"\n  totalCount: Long!\n}\ntype ObservationHistogramResult {\n  countBySource: [ObservationCountBySource!]\n  dateTime: DateTime!\n  totalCount: Int!\n}\n\"\"\"\nObservationMappingRule type. ObservationMappingRule specifies how to map an alert from generic source to\nObservation object, along with paired alert template used to configure external monitor tool webhook.\nPaired alert template is a convenience to user, API doesn't enforce its presence, because if user has other\nways to send alerts, so long as alert content conforms to spec, it can be mapped to Observation.\n\"\"\"\ntype ObservationMappingRule implements InsightRule & Node {\n  \"Status of the Rule\"\n  active: Boolean!\n  \"Alert template in json string format\"\n  alertTemplate: String\n  \"The user who created the Rule\"\n  createdBy: User!\n  \"Time at which the Rule was created in UTC ISO-8601 format\"\n  creationTime: DateTime!\n  \"Description of the Rule\"\n  description: LocalizedString!\n  \"opaque unique id of a rule\"\n  id: ID!\n  \"Time at which the Rule was last updated in UTC ISO-8601 format\"\n  lastUpdateTime: DateTime\n  \"The user who last updated the Rule\"\n  lastUpdatedBy: User\n  \"Name of the rule\"\n  name: LocalizedString!\n  \"Spec schema version\"\n  schemaVersion: ObservationMappingRuleSchemaVersion!\n  \"Data source\"\n  source: String!\n  \"Observation mapping spec in json string format\"\n  specJsonString: String!\n}\n\"Observation queries\"\ntype ObservationQuery {\n  \"\"\"\n  Query aggregated information on observations\n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  ### API Permissions:\n  - `observability:ObservabilityAlert:read`\n  \"\"\"\n  queryAggregations(\n    \"Specify aggregation buckets\"\n    aggregations: [ObservationAggregationInput!]!,\n    \"Optional additional field filters.\"\n    filter: QueryFilter,\n    \"Specify query filter\"\n    observationFilter: ObservationFilter\n  ): ObservationAggregations!\n  \"\"\"\n  Query Entity Alert Count\n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  ### API Permissions:\n  - `observability:ObservabilityAlert:read`\n  \"\"\"\n  queryEntityAlertCount(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Specify Entity Type\"\n    entityType: [ObservabilityAlertEntityType!]!,\n    \"Optional additional field filters.\"\n    filter: QueryFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Specify query filter\"\n    observationFilter: ObservationFilter,\n    \"Sort Order for queries\"\n    sortOrder: QuerySortOrder\n  ): [ObservationEntityAlertCountResponse!]\n  \"\"\"\n  Query histogram of observations\n  ### API Permissions:\n  - `observability:ObservabilityAlert:read`\n  \"\"\"\n  queryObservationHistogram(\n    \"Histogram input parameter\"\n    histogramParam: ObservationHistogramInput!\n  ): [ObservationHistogramResult!]\n  \"\"\"\n  Query observations by list of given search criteria\n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  ### API Permissions:\n  - `observability:ObservabilityAlert:read`\n  \"\"\"\n  queryObservations(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Optional field filters\"\n    filter: QueryFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Observation filter with filter parameters\"\n    observationFilter: ObservationFilter,\n    \"Sort order for results in ObservationConnection\"\n    sort: [QuerySort!]\n  ): ObservationConnection!\n}\n\"ObservationTagGroup type. ObservationTagGroup is to group ML tags with similar semantic meaning\"\ntype ObservationTagGroup {\n  \"Status of the ObservationTagGroup\"\n  active: Boolean!\n  \"Name of the ObservationTagGroup\"\n  name: String!\n  \"Tags that have been assigned to the ObservationTagGroup\"\n  tagKeys: [String!]!\n}\n\"An entity to keep metadata of a tag\"\ntype ObservationTagOccurrence implements Node {\n  id: ID!\n  \"count of observations assigned with the tag\"\n  observationCount: Int!\n  \"source of the tag\"\n  sources: [ObservationSource!]!\n  \"tag group id of which the tag is assigned to\"\n  tagGroupId: String\n  \"name of the tag\"\n  tagName: String!\n}\n\"TaggingRule type. TaggingRules are rules used to add user-defined tags to Observations based on rule conditions.\"\ntype ObservationTaggingRule implements InsightRule & Node {\n  \"Status of the Rule\"\n  active: Boolean!\n  \"conditions to apply on observations\"\n  condition: InsightRuleConstraint\n  \"The user who created the Rule\"\n  createdBy: User!\n  \"Time at which the Rule was created in UTC ISO-8601 format\"\n  creationTime: DateTime!\n  \"Description of the Rule\"\n  description: LocalizedString!\n  \"opaque unique id of a rule\"\n  id: ID!\n  \"condition to check if tag shall be copied to inferred tag\"\n  inferredTag: Boolean\n  \"Time at which the Rule was last updated in UTC ISO-8601 format\"\n  lastUpdateTime: DateTime\n  \"The user who last updated the Rule\"\n  lastUpdatedBy: User\n  \"Name of the rule\"\n  name: LocalizedString!\n  \"properties to be added as tags in Observation\"\n  properties: [ObservationTaggingRuleProperty!]!\n  \"Type of the rule. Can be STATIC, COMPOSITION or EXTRACTION\"\n  type: ObservationTaggingRuleType!\n}\n\"\"\"\nProperty to be added to Observation tags\n(key,value) for static tagging\n(observationTaggingTemplate,destinationKeyName) for composition tagging\n(observationTaggingPattern, sourceKeyName, destinationKeyName) for extraction tagging\n\"\"\"\ntype ObservationTaggingRuleProperty {\n  \"Key name for extraction/composition tag to be added\"\n  destinationKeyName: String\n  \"Key for a static tag\"\n  key: String\n  \"Pattern to extract tag value from already existing tag\"\n  observationTaggingPattern: String\n  \"Template to form composition tags\"\n  observationTaggingTemplate: String\n  \"Key name from which pattern is to be extracted\"\n  sourceKeyName: String\n  \"Value for the key of static tag\"\n  value: String\n}\n\"Relay-compatible paging support. Please see: [GraphQL Cursor Connections Specification](https://relay.dev/graphql/connections.htm)\"\ntype PageInfo {\n  \"Cursor of the last element in the page. Can be null if there are no results\"\n  endCursor: String\n  hasNextPage: Boolean!\n  hasPreviousPage: Boolean!\n  \"Cursor of the first element in the page. Can be null if there are no results\"\n  startCursor: String\n}\ntype PixieProxyQuery {\n  \"\"\"\n  Query a pixie deployment for a flamegraph representing the process(es) in a single pod or across the entire node\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  \"\"\"\n  queryPixieFlamegraph(\n    \"The query input\"\n    input: PixieFlamegraphQueryInput!\n  ): [PixieStackTrace!]!\n}\ntype PixieStackTrace {\n  \"The command line which started the process under evaluation\"\n  cmdLine: String!\n  \"The number of times this stack has been seen across the entire time window\"\n  count: Long!\n  \"\"\"\n  The count of all stacks reported in the time window. This is not returned in a \"node\" aggregated flamegraph\n  \"\"\"\n  countX: Long\n  \"The name of the container within the pod\"\n  kContainerName: String!\n  \"The namespace of the pod for which the flamegraph was requested\"\n  kNamespace: String!\n  \"The name of the node for which the flamegraph was requested\"\n  kNodeName: String!\n  \"The name of the pod for which the flamegraph was requested\"\n  kPodName: String!\n  \"The percentage of the time windows this stack occupies.\"\n  percent: Float!\n  \"The number by which we must calculate percentages. This ends up being the number of CPU's on the node.\"\n  scalingFactor: Long!\n  \"A uniqueId of the current stack trace\"\n  stackTraceId: Long!\n  \"A list, in order, of the frames for the stack reported. Most recent frame in the stack is first.\"\n  trace: [String!]!\n}\ntype PlatformConsumptionReport {\n  \"document id\"\n  id: ID!\n}\ntype PlatformConsumptionReportMutation {\n  createConsumptionReport: PlatformConsumptionReport!\n}\ntype PlatformNodeResources {\n  memoryPerNodeGb: Int!\n  nodes: Int!\n  storagePerNodeGb: Int!\n  vcpusPerNode: Int!\n}\ntype PlatformObservabilityLoad {\n  activeMetrics: Int!\n  logAlerts: Int!\n  logMessagesPerSecond: Int!\n  metricAlerts: Int!\n}\ntype PlatformObservabilityQuery {\n  \"\"\"\n  Get currently deployed installation profile for tanzu platform\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `observability:PlatformProfile:read`\n  \"\"\"\n  queryPlatformProfile(\n    \"details to be fetched for current vs recommended profile\"\n    type: PlatformProfileType = CURRENT\n  ): PlatformProfile\n}\ntype PlatformProfile {\n  installationFlavor: String!\n  observabilityLoad: PlatformObservabilityLoad!\n  profileName: String!\n  resourceRequirements: PlatformResourceRequirements!\n  usageLimits: PlatformUsageLimits!\n}\ntype PlatformResourceDimension {\n  clustersFoundations: Int!\n  projects: Int!\n  spaces: Int!\n}\ntype PlatformResourceRequirements {\n  controlPlane: PlatformNodeResources!\n  workers: PlatformWorkerResources!\n}\ntype PlatformUsageLimits {\n  applicationInstances: Int!\n  concurrentAssessments: Int!\n  ingestRPS: Int!\n  queryQPS: Int!\n  resourceDimensions: PlatformResourceDimension!\n}\ntype PlatformWorkerResources {\n  containerdStoragePerNodeGb: Int!\n  ephemeralStoragePerNodeGb: Int!\n  memoryPerNodeGb: Int!\n  nodes: Int!\n  pvcStorageGb: Int!\n  vcpusPerNode: Int!\n}\ntype Query {\n  \"\"\"\n  Query Dashboard subsystem\n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  ### API Permissions:\n  - `user:SharedDashboard:read`,\n  - `user:UserDashboard:read`\n  \"\"\"\n  dashboardQuery: DashboardQuery!\n  \"\"\"\n  Query derived-data subsystem\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `deriveddata:Export:read`\n  \"\"\"\n  derivedDataQuery: DerivedDataQuery!\n  \"Query the documents subsystem\"\n  documentQuery: DocumentQuery\n  \"\"\"\n  Query the inventory and CMDB subsystem\n  ### API Permissions:\n  - `entity:*:read`\n  \"\"\"\n  entityQuery: EntityQuery!\n  \"\"\"\n  Query the Fleet Management System\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  \"\"\"\n  fleetManagementQuery: FleetManagementQuery\n  \"\"\"\n  Policy framework query\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `policy:*:read`\n  \"\"\"\n  hubPolicyQuery: TanzuHubPolicyQuery!\n  \"Query available hyperlinks\"\n  hyperlinkQuery: HyperlinkQuery\n  \"\"\"\n  \n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  \"\"\"\n  licenseQuery: LicenseQuery!\n  \"\"\"\n  Management Endpoint Query\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  \"\"\"\n  managementEndpointQuery: ManagementEndpointQuery!\n  \"\"\"\n  Query notification subsystem\n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  ### API Permissions:\n  - `notification:*:read`\n  \"\"\"\n  notificationQuery: NotificationQuery!\n  \"Query User subsystem\"\n  userQuery: UserQuery!\n  \"\"\"\n   Entry point for Tanzu Warehouse queries. \n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  \"\"\"\n  warehouseQuery: WarehouseQuery\n  \"\"\"\n  \n  ### API Permissions:\n  - `entity:*:read`\n  \"\"\"\n  workflowRunQuery: WorkflowRunQuery\n  \"\"\"\n  Conversational Query subsystem\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `tia:Chat:create`,\n  - `tia:Chat:update`,\n  - `tia:Chat:read`\n  \"\"\"\n  conversationalQuery: ConversationalQuery!\n  \"Query capacity related stats\"\n  capacityQuery: CapacityQuery!\n  \"\"\"\n  Query insights\n  ### API Permissions:\n  - `observability:ObservabilityAlert:read`\n  \"\"\"\n  insightQuery: InsightQuery!\n  metricQuery: MetricQuery!\n  observabilityQuery: ObservabilityQuery!\n  \"Query pixie deployments in kubernetes clusters\"\n  pixieProxyQuery: PixieProxyQuery\n  platformObservabilityQuery: PlatformObservabilityQuery!\n  \"Query time-series stats and forecasts\"\n  statsQuery: StatsQuery!\n  \"\"\"\n  Query artifact metadata\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `springassessment:Assessment:read`\n  \"\"\"\n  artifactMetadataQuery: ArtifactMetadataQuery!\n  \"Query the application portfolio assessment\"\n  assessmentQuery: AssessmentQuery\n  \"\"\"\n  Query repository\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `springassessment:Assessment:read`\n  \"\"\"\n  repositoryQuery: RepositoryQuery!\n  \"\"\"\n  Query vulnerability and affected entities\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `springassessment:Assessment:read`\n  \"\"\"\n  vulnerabilityQuery: ArtifactVulnerabilityQuery!\n  \"Return the GraphQL Schema in SDL\"\n  sdl: String!\n  stitchedSdl: String\n  \"Query the authentication / authorization subsystem\"\n  authQuery: AuthQuery!\n  \"Return static complexity analysis value for this query\"\n  queryComplexity: Float!\n}\n\"Generic Error type for all the CUD operations under repository-assessment-mutations\"\ntype RepositoryAssessmentErrors {\n  \"Optional entityId\"\n  entityId: EntityId\n  \"Name of the entity\"\n  entityName: String!\n  \"error message\"\n  errorMsg: String!\n}\ntype RepositoryAssessmentMutation {\n  \"\"\"\n  Upsert repositories at a repository group level.\n  input: repository group entityId & Repository details.\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `repository:Repository:create`,\n  - `repository:Repository:update`\n  \"\"\"\n  createOrUpdateRepositories(repositories: [RepositoryInput!]!, repositoryGroupEntityId: EntityId!): [RepositoryResponse!]!\n  \"\"\"\n  Create repository groups OR update existing repository groups.\n  If a repository input file is provided, then it should be uploaded to the DocumentService and the document ID should be passed into this API.\n  Any document passed in would be appended to the existing list of repositories for this repository group.\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `repository:RepositoryGroup:create`,\n  - `repository:RepositoryGroup:update`\n  \"\"\"\n  createOrUpdateRepositoryGroups(repositoryGroupInputs: [RepositoryGroupInput!]!): [RepositoryGroupResponse!]!\n  \"\"\"\n  Create rules or override existing rules for a specified scope.\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `repository:AssessmentRule:create`,\n  - `repository:AssessmentRule:update`\n  \"\"\"\n  createOrUpdateRules(ruleInputs: [AssessmentRuleWithScopeInput!]!): AssessmentRuleConnection\n  \"\"\"\n  Delete repositories from multiple repository groups\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `repository:Repository:delete`\n  \"\"\"\n  deleteRepositoriesFromRepositoryGroups(inputs: [RepositoryGroupOperationInput!]!): [[Boolean!]!]\n  \"\"\"\n  Delete repository groups.\n  This operation will delete the repository group along with repositories and results.\n  input: List of repository group entityIds to delete\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `repository:RepositoryGroup:delete`\n  \"\"\"\n  deleteRepositoryGroups(repositoryGroupEntityIds: [EntityId!]!): [Boolean!]\n  \"\"\"\n  Delete a list of rules\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `repository:AssessmentRule:delete`\n  \"\"\"\n  deleteRules(ruleIds: [EntityId!]!): [Boolean!]\n  \"\"\"\n  Run assessment analyses on multiple repository groups\n  This API will trigger the analysis of the selected repositories for each repository group, which will be asynchronous operations.\n  The API would queue the runs and return with a list of Tanzu.Portfolio.AssessmentRun entities representing the ongoing runs.\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `repository:AssessmentRun:create`\n  \"\"\"\n  runAssessments(repositoryAssessmentInputs: [RepositoryGroupOperationInput!]!): [Entity!]!\n}\ntype RepositoryAssessmentQuery {\n  \"\"\"\n  Query all available rule tags\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `entity:Tanzu.Portfolio.AssessmentRule:read`\n  \"\"\"\n  queryRuleTags: [Tag!]\n  \"\"\"\n  Query rules at the level of an optional 'scopeId'\n  When scopeId is empty, we will return rule overrides at global scope\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `entity:Tanzu.Portfolio.AssessmentRule:read`\n  \"\"\"\n  queryRules(\n    \"relay-compatible cursor of last entry on previous page\"\n    after: String,\n    \"relay-compatible cursor of first entry on current page\"\n    before: String,\n    \"Filter the rules based on properties and tags\"\n    filter: QueryFilter,\n    \"relay-compatible page size\"\n    first: Int = 10,\n    \"relay-compatible page size\"\n    last: Int,\n    \"Entity id of repository group, repository etc. Should be empty for global scope\"\n    scopeId: EntityId\n  ): AssessmentRuleConnection\n  \"\"\"\n  Test if input list of repositories are accessible (Optionally with credentials).\n  The credentials (if present) will be considered valid if they work successfully for at least one of the input list of repositories.\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `repository:RepositoryGroup:create`,\n  - `repository:RepositoryGroup:update`\n  \"\"\"\n  validateRepositoryConnection(gitCreds: RepositoryGitCredentialsInput, inputRepositoryURLs: [String]!, proxyInput: RepositoryProxyInput, scmType: RepositorySCMType): [RepositoryConnectionValidationResponse!]\n}\ntype RepositoryConnectionValidationResponse {\n  \"Optional error message in case the creds failed\"\n  errMsg: String\n  \"Boolean result detecting if the repositories are accessible with creds\"\n  result: Boolean!\n}\ntype RepositoryGroupResponse {\n  \"The repository group entity that will be created after successful upsert request\"\n  entity: Entity\n  \"Optional errors that might occur during the upsert of an assessment\"\n  errors: [RepositoryGroupResponseErrors!]\n  \"Workflow id of upsert repository group task\"\n  workflowId: String\n}\n\"Generic Error type for all the CUD operations under repository-assessment-mutations\"\ntype RepositoryGroupResponseErrors {\n  \"Optional entityId\"\n  entityId: EntityId\n  \"Name of the entity\"\n  entityName: String!\n  \"error message\"\n  errorMsg: String!\n}\ntype RepositoryProviderInfo {\n  \"name of provider\"\n  name: String!\n}\ntype RepositoryQuery {\n  \"Direct access to individual repository provider queries through per-provider fields.\"\n  repositoryQueryProviders: RepositoryQueryProviders!\n}\ntype RepositoryQueryProviders {\n  \"Query provider for Spring Artifact Repositories\"\n  springArtifact: SpringArtifactRepositoryQueryProvider!\n}\ntype RepositoryResponse {\n  \"Entity of type Tanzu.Portfolio.Repository, that will be created when a repository is successfully created\"\n  entity: Entity\n  \"Errors occurred during create / delete / update of repositories\"\n  error: [RepositoryAssessmentErrors!]\n}\ntype RepositorySbomStatus {\n  error: LocalizedString\n  status: String\n}\n\" NOTE: The prefix is Service, so ALL types and inputs MUST start with it.\"\ntype ServiceMutation {\n  \"\"\"\n  \n  ### API Permissions:\n  \"\"\"\n  bind(input: ServiceBindInput!): WorkflowRun!\n  \"\"\"\n  Creates a new service instance within a Space Group.\n  \n  - The response is a list of all created service instances in the Space Group.\n  - In the Comet Release, a Space Group maps to exactly one Space (1:1 mapping),\n  so the response will contain only one item.\n  - In future releases, when a Space Group maps to multiple Spaces (1:many),\n  the response may contain multiple items.\n  \n  Release: Comet\n  ### API Permissions:\n  \"\"\"\n  create(input: ServiceCreateInput!): WorkflowRun!\n  \"\"\"\n  \n  ### API Permissions:\n  \"\"\"\n  delete(input: ServiceDeleteInput!): WorkflowRun!\n  \"\"\"\n  \n  ### API Permissions:\n  \"\"\"\n  unbind(input: ServiceBindInput!): WorkflowRun!\n  \"\"\"\n  Updates the visibility of the service plans of a given service offering.\n  ### API Permissions:\n  \"\"\"\n  updateServicePlanVisibility(input: ServicePlanVisibilityUpdateInput!): WorkflowRun!\n}\n\"\"\"\nAssessment is systematically evaluating and appraising a Spring or non-spring Artifacts/GIT Repository.\nThis comprehensive analysis aims to derive valuable insights, findings, and recommendations,\nultimately resulting in a detailed report that focuses on specific aspects of the Tanzu Hub product.\n\"\"\"\ntype SpringArtifactAssessment implements ArtifactAssessment & Node {\n  \"assessment instance identifier\"\n  artifactAssessmentId: String!\n  \"artifactMetadataVersion with which this assessment is associated\"\n  artifactMetadataVersions(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Optionally filter by artifactMetadataId\"\n    artifactMetadataId: [String!],\n    \"Optionally filter by artifactMetadata name, will support wildcard *\"\n    artifactMetadataName: [String!],\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Input filters to filter Vulnerabilities. This is not supported as of now, will be supported in future\"\n    filter: QueryFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10\n  ): SpringArtifactMetadataVersionConnection!\n  \"Assessment meta\"\n  assessmentMeta: JSON\n  \"Recommendations for this assessment\"\n  assessmentRecommendations(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10\n  ): SpringArtifactRecommendationConnection!\n  \"Type of assessment\"\n  assessmentType: SpringArtifactAssessmentType\n  \"CSP user who created Assessment\"\n  createdBy: User!\n  \"Timestamp at which Assessment is created. Expressed in UTC ISO-8601 format\"\n  creationTime: DateTime!\n  \"csp project entity for which this assessment will be visible\"\n  cspProjectEntity: Entity\n  \"Global opaque identifier to meet Node contract\"\n  id: ID!\n  \"Timestamp at which Assessment is updated. Expressed in UTC ISO-8601 format\"\n  lastUpdateTime: DateTime\n  \"Name of the assessment.\"\n  name: String\n  \"repository commit information on which this assessment was triggered. Assessments may be run outside of a source repository, Eg. sbom file upload\"\n  repositoryVersion: SpringArtifactRepositoryVersion\n  \"CSP user who updated Assessment\"\n  updatedBy: User\n}\ntype SpringArtifactAssessmentConnection implements ArtifactAssessmentConnection & Connection {\n  \"Assessment instances\"\n  assessments: [SpringArtifactAssessment!]\n  \"Count of Assessments on this page\"\n  count: Int!\n  \"Relay-compatible Assessment edges\"\n  edges: [SpringArtifactAssessmentEdge!]\n  \"Relay-compatible page info\"\n  pageInfo: PageInfo!\n  \"Total count of Assessments, may not always be an exact number and hence consumers should not rely only on this\"\n  totalCount: Int\n}\ntype SpringArtifactAssessmentEdge implements ArtifactAssessmentEdge & ConnectionEdge {\n  \"Cursor is an opaque string, you can use it to request subsequent or preceding items in the list\"\n  cursor: String!\n  \"Assessment node\"\n  node: SpringArtifactAssessment!\n}\n\"\"\"\nThis represents meta data for an Spring artifact.\nThis meta data will be enriched by different assessments, where each assessment will add some information to the metadata\n\"\"\"\ntype SpringArtifactMetadata implements ArtifactMetadata & Node {\n  \"Domain-specific artifact metadata instance identifier\"\n  artifactMetadataId: String!\n  \"metadata versions for this ArtifactMetadata\"\n  artifactMetadataVersions(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Optionally filter by artifactMetadata version ids, this should support wildcards Eg. 2.*\"\n    artifactMetadataVersionId: [String!],\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"This is not supported as of now, will be supported in future\"\n    filter: QueryFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Sort by one or more attributes, default SORT order: creationTime descending\"\n    sort: [QuerySort!]\n  ): SpringArtifactMetadataVersionConnection!\n  \"Global opaque identifier to meet Node contract\"\n  id: ID!\n  \"Artifact name\"\n  name: String!\n}\ntype SpringArtifactMetadataConnection implements ArtifactMetadataConnection & Connection {\n  \"List artifact SBOM(s).\"\n  artifactMetadata: [SpringArtifactMetadata!]\n  \"count of Packages on this page\"\n  count: Int!\n  \"relay-compatible Package edges\"\n  edges: [SpringArtifactMetadataEdge!]\n  \"relay-compatible page info\"\n  pageInfo: PageInfo!\n  \"Total count of Packages, may not always be an exact number and hence consumers should not rely only on this\"\n  totalCount: Int\n}\ntype SpringArtifactMetadataEdge implements ArtifactMetadataEdge & ConnectionEdge {\n  \"Cursor is an opaque string, you can use it to request subsequent or preceding items in the list\"\n  cursor: String!\n  \"Package node\"\n  node: SpringArtifactMetadata!\n}\n\"# Spring Artifact specific implementation\"\ntype SpringArtifactMetadataQueryProvider implements ArtifactMetadataQueries & ArtifactMetadataQueryProvider {\n  \"Provider name, expected to be the same as the field name used to access this provider, possibly with case differences\"\n  name: String!\n  \"Information about this provider\"\n  providerInfo: ArtifactMetadataProviderInfo!\n  \"\"\"\n  Query aggregated information on assessments\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `springassessment:Assessment:read`\n  \"\"\"\n  queryArtifactAssessmentAggregations(\n    \"Specify aggregation buckets\"\n    aggregations: [ArtifactAssessmentAggregationInput!]!,\n    \"Optional filter\"\n    filter: ArtifactAssessmentAggregationFilterInput\n  ): [ArtifactAssessmentAggregations!]!\n  \"\"\"\n  query assessment report\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `springassessment:Assessment:read`\n  \"\"\"\n  queryArtifactAssessmentReport(artifactMetaVersionId: String!): [Byte]!\n  \"\"\"\n  query assessment stats\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `springassessment:Assessment:read`\n  \"\"\"\n  queryArtifactAssessmentStats(filter: ArtifactAssessmentStatsFilterInput!): [ArtifactAssessmentStats!]!\n  \"\"\"\n  Query available artifact assessments\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `springassessment:Assessment:read`\n  \"\"\"\n  queryArtifactAssessments(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Optionally filter by artifactMetadataId\"\n    artifactMetadataId: [String!],\n    \"Optionally filter by artifactMetadata name\"\n    artifactMetadataName: [String!],\n    \"Optionally filter by artifactMetadata version ids\"\n    artifactMetadataVersionId: [String!],\n    \"Optionally filter by  ids\"\n    assessmentId: [String!],\n    \"Optionally filter by  ids\"\n    assessmentName: [String!],\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"This is not supported as of now, will be supported in future\"\n    filter: QueryFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Sort by one or more attributes, default sort : Sort by creationTime descending\"\n    sort: [QuerySort!]\n  ): SpringArtifactAssessmentConnection!\n  \"\"\"\n  Query available artifact metadata\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `springassessment:Assessment:read`\n  \"\"\"\n  queryArtifactMetadata(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Optionally filter by artifactMetadataId\"\n    artifactMetadataId: [String!],\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"This is not supported as of now, will be supported in future\"\n    filter: QueryFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Optionally filter by artifactMetadata name\"\n    name: [String!],\n    \"\"\"\n    Results are sorted as per fields and order specified. Supported fields are name\"\n    default sort : sort by name ascending\n    \"\"\"\n    sort: [QuerySort!]\n  ): SpringArtifactMetadataConnection!\n}\n\"Spring Artifact Metadata version\"\ntype SpringArtifactMetadataVersion implements ArtifactMetadataVersion & Node {\n  \"Query aggregated information on meta version\"\n  artifactAggregations(\n    \"Specify aggregation buckets\"\n    aggregationsInput: [ArtifactAssessmentAggregationInput!]!\n  ): [ArtifactAssessmentAggregations]!\n  \"Artifact metadata with which this version is associated\"\n  artifactMetadata: SpringArtifactMetadata!\n  \"Domain-specific artifact metadata version identifier\"\n  artifactMetadataVersionId: String!\n  \"Recommendations for this artifact metadata version\"\n  artifactRecommendations(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10\n  ): SpringArtifactRecommendationConnection!\n  \"List of SBOMs associated with this artifact metadata version\"\n  artifactSBOM(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"This is not supported as of now, will be supported in future\"\n    filter: QueryFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,sbomFilter: SpringArtifactSBOMFilterInput  ): SpringArtifactSBOMConnection!\n  \"SBOM summary associated with this artifact metadata version\"\n  artifactSBOMSummary: SpringArtifactSBOMSummary\n  assessment: SpringArtifactAssessment\n  \"Timestamp at which this version is created. Expressed in UTC ISO-8601 format\"\n  creationTime: DateTime!\n  \"external version identifier, this may represent a RepositoryVersion or a CatalogItem identifier\"\n  externalVersionId: String!\n  \"Global opaque identifier to meet Node contract\"\n  id: ID!\n  \"Timestamp at which the analysis was done. Expressed in UTC ISO-8601 format\"\n  lastAnalysisTime: DateTime!\n  \"The repository version associated with this metadata version\"\n  repositoryVersion: SpringArtifactRepositoryVersion\n  \"Indicates if this metadata version contains Spring Governance Starter dependency\"\n  springGovernanceStarter: Boolean!\n}\ntype SpringArtifactMetadataVersionConnection implements ArtifactMetadataVersionConnection & Connection {\n  \"List artifact SBOM(s).\"\n  artifactMetadataVersions: [SpringArtifactMetadataVersion!]\n  \"count of Packages on this page\"\n  count: Int!\n  \"relay-compatible Package edges\"\n  edges: [SpringArtifactMetadataVersionEdge!]\n  \"relay-compatible page info\"\n  pageInfo: PageInfo!\n  \"Total count of Packages, may not always be an exact number and hence consumers should not rely only on this\"\n  totalCount: Int\n}\ntype SpringArtifactMetadataVersionEdge implements ArtifactMetadataVersionEdge & ConnectionEdge {\n  \"Cursor is an opaque string, you can use it to request subsequent or preceding items in the list\"\n  cursor: String!\n  \"Package node\"\n  node: SpringArtifactMetadataVersion!\n}\ntype SpringArtifactMutations {\n  \"\"\"\n  Delete Assessments\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `springassessment:Assessment:create`,\n  - `springassessment:Assessment:update`,\n  - `springassessment:Assessment:delete`\n  \"\"\"\n  deleteAssessments(assessmentIds: [String!]!): [SpringArtifactAssessment!]!\n  \"\"\"\n  Re-Run a single Assessment.\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `springassessment:Assessment:create`,\n  - `springassessment:Assessment:update`\n  \"\"\"\n  reRunAssessment(artifactMetaVersionId: String!): SpringArtifactAssessment!\n  \"\"\"\n  Run repository assessment and schedule it with default scheduler for further assessment.\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `springassessment:Assessment:create`,\n  - `springassessment:Assessment:update`\n  \"\"\"\n  runRepositoryAssessment(\n    \"Unique identifier for the Repository\"\n    repositoryAssessmentInput: [RepositoryAssessmentInput!]!\n  ): [SpringArtifactRepository]!\n  \"\"\"\n  Update Repository.\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `springassessment:Assessment:create`,\n  - `springassessment:Assessment:update`\n  \"\"\"\n  updatedSpringArtifactRepository(repositoryUpdateInput: [SpringArtifactRepositoryUpdateInput!]!): [SpringArtifactRepository]!\n  \"\"\"\n  Upload Assessment file And Run Assessment\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `springassessment:Assessment:create`,\n  - `springassessment:Assessment:update`\n  \"\"\"\n  uploadAssessmentFileAndRunAssessment(content: SpringArtifactUpload!, input: SpringArtifactAssessmentInput): SpringArtifactAssessment!\n  \"\"\"\n  Upsert Artifact Metadata\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `springassessment:Assessment:create`,\n  - `springassessment:Assessment:update`\n  \"\"\"\n  upsertArtifactMetadata(input: SpringArtifactMetadataInput): SpringArtifactMetadata!\n}\n\"\"\"\nAssessment recommendations based on the Artifact Metadata, contributing to other tanzu hub products upsell.\"\n\"\"\"\ntype SpringArtifactRecommendation implements ArtifactAssessmentRecommendation & Node {\n  \"Domain-specific artifact assessment recommendation instance identifier\"\n  artifactAssessmentRecommendationId: String!\n  \"Artifact metadata version assessment for which this recommendation was generated\"\n  artifactMetadataVersion: SpringArtifactMetadataVersion\n  \"assessment for which this recommendation was generated\"\n  assessment: SpringArtifactAssessment!\n  \"\"\"\n  Description of Recommendation.\n  This will be represented as HTML element as we may need to showcase specific words as hyperlinks in recommendation description,\n  offering users the ability to access Tanzu product subscription link by clicking on those designated words.\n  \"\"\"\n  description: LocalizedString\n  \"Global opaque identifier to meet Node contract\"\n  id: ID!\n  \"Timestamp at which Recommendation is updated. Expressed in UTC ISO-8601 format\"\n  lastUpdateTime: DateTime\n  \"Name of recommendation\"\n  name: LocalizedString!\n  \"Type of recommendation\"\n  type: SpringArtifactRecommendationType!\n}\ntype SpringArtifactRecommendationConnection implements ArtifactAssessmentRecommendationConnection & Connection {\n  \"Count of recommendations on this page\"\n  count: Int!\n  \"Relay-compatible recommendation edges\"\n  edges: [SpringArtifactRecommendationEdge!]\n  \"Relay-compatible page info\"\n  pageInfo: PageInfo!\n  \"Recommendations instances\"\n  recommendations: [SpringArtifactRecommendation!]\n  \"Total count of recommendations, may not always be an exact number and hence consumers should not rely only on this\"\n  totalCount: Int\n}\ntype SpringArtifactRecommendationEdge implements ArtifactAssessmentRecommendationEdge & ConnectionEdge {\n  cursor: String!\n  node: SpringArtifactRecommendation!\n}\n\"\"\"\nRepository can be a git repository or just folder structure where source code is present.\nUser will be generating the SBOM or library libraryDependency file from the source code repository.\n\"\"\"\ntype SpringArtifactRepository implements Node & Repository {\n  \"It shows whether is continouse monitoring is enabled on this repository\"\n  continuousMonitor: Boolean\n  \"Timestamp at which Assessment is created. Expressed in UTC ISO-8601 format\"\n  creationTime: DateTime!\n  \"Repository endpoint for this repository\"\n  endpoint: SpringArtifactRepositoryEndpoint!\n  \"Global opaque identifier to meet Node contract\"\n  id: ID!\n  \"latest SpringArtifactMetadataVersion based on the last creation time\"\n  latestArtifactMetadataVersion: SpringArtifactMetadataVersion\n  \"latest repository version based on committed timestamp\"\n  latestVersion: SpringArtifactRepositoryVersion\n  \"\"\"\n  Name of repository\n  Eg. for hhttps://github.com/org-name/my-repository, We can have name as my-repository\n  \"\"\"\n  name: String!\n  \"\"\"\n  repository project/sub directory/module path\n  Eg. for https://github.com/org-name/my-repository, path will be org-name/my-repository\n  \"\"\"\n  path: String!\n  \"Unique identifier for the Repository\"\n  repositoryId: String!\n  \"Repository Status\"\n  repositoryStatus: SpringArtifactRepositoryStatus!\n  \"repositoryVersions associated with this repository\"\n  repositoryVersions(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Optionally filter by repository branch\"\n    branch: [String!],filter: QueryFilter, \n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Optionally filter by repository version ids\"\n    repositoryVersionId: [String!],\n    \"Sort by one or more attributes, default sort : Sort by creationTime descending\"\n    sort: [QuerySort!]\n  ): SpringArtifactRepositoryVersionConnection!\n}\ntype SpringArtifactRepositoryConnection implements Connection & RepositoryConnection {\n  \"Count of elements in the current page\"\n  count: Int!\n  \"Edges to nodes available through the connection\"\n  edges: [SpringArtifactRepositoryEdge!]\n  \"Paging support\"\n  pageInfo: PageInfo!\n  \"List of Repository\"\n  repositories: [SpringArtifactRepository!]\n  \"Optional total elements count across all pages when available\"\n  totalCount: Int\n}\ntype SpringArtifactRepositoryEdge implements ConnectionEdge & RepositoryEdge {\n  \"Optional cursor to refer to this node\"\n  cursor: String\n  \"Node element available through this edge\"\n  node: SpringArtifactRepository!\n}\n\"\"\"\nRepresents an endpoint that can be used access one or more repositories. Eg. gitlab.eng.vmware.com\nAs of now we are only supporting PRIVATE repositories, so there is no need to configure credentials in SAAS.\nPUBLIC will be supported in next phase\n\"\"\"\ntype SpringArtifactRepositoryEndpoint implements Node & RepositoryEndpoint {\n  \"CSP user who created Assessment\"\n  createdBy: User!\n  \"Timestamp at which Assessment is created. Expressed in UTC ISO-8601 format\"\n  creationTime: DateTime!\n  \"csp project entity for which this repository endpoint will be visible\"\n  cspProjectEntity: [Entity!]\n  \"repository access type , can PUBLIC or PRIVATE\"\n  endpointAccessType: SpringArtifactRepositoryEndpointAccessType\n  \"Global opaque identifier to meet Node contract\"\n  id: ID!\n  \"Repository endpoint name\"\n  name: String!\n  \"Repositories associated with this repository endpoint\"\n  queryRepositories(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,filter: QueryFilter, \n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Optionally filter by repository ids\"\n    repositoryId: [String!],\n    \"Optionally filter by repository name, this shall support wildcards\"\n    repositoryName: [String!],\n    \"Sort by one or more attributes, default sort : Sort by creationTime descending\"\n    sort: [QuerySort!]\n  ): SpringArtifactRepositoryConnection!\n  \"unique identifier for a repository endpoint\"\n  repositoryEndpointId: String!\n  \"Repository endpoint type\"\n  repositoryEndpointType: SpringArtifactRepositoryEndpointType\n  \"Repository endpoint URL\"\n  repositoryEndpointUrl: String!\n}\ntype SpringArtifactRepositoryEndpointConnection implements Connection & RepositoryEndpointConnection {\n  \"Count of elements in the current page\"\n  count: Int!\n  \"Edges to nodes available through the connection\"\n  edges: [SpringArtifactRepositoryEndpointEdge!]\n  \"Paging support\"\n  pageInfo: PageInfo!\n  \"List of SpringArtifactRepositoryEndpoint\"\n  repositoryEndpoints: [SpringArtifactRepositoryEndpoint!]\n  \"Optional total elements count across all pages when available\"\n  totalCount: Int\n}\ntype SpringArtifactRepositoryEndpointEdge implements ConnectionEdge & RepositoryEndpointEdge {\n  cursor: String\n  node: SpringArtifactRepositoryEndpoint!\n}\ntype SpringArtifactRepositoryQueryProvider implements RepositoryQueries & RepositoryQueryProvider {\n  \"Provider name, expected to be the same as the field name used to access this provider, possibly with case differences\"\n  name: String!\n  \"Information about this provider\"\n  providerInfo: RepositoryProviderInfo!\n  \"\"\"\n  Query Repositories\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `springassessment:Assessment:read`\n  \"\"\"\n  queryRepositories(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,filter: QueryFilter, \n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Optionally filter by repository name, this shall support wildcards\"\n    name: [String!],\n    \"Optionally filter by repository path, this shall support wildcards\"\n    path: [String!],\n    \"Optionally filter by repository ids\"\n    repositoryId: [String!],\n    \"Sort by one or more attributes, default sort : Sort by creationTime descending\"\n    sort: [QuerySort!]\n  ): SpringArtifactRepositoryConnection!\n  \"\"\"\n  Query available repository endpoints\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `springassessment:Assessment:read`\n  \"\"\"\n  queryRepositoryEndpoints(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"filter by project ids\"\n    cspProjectEntityId: [EntityId!],filter: QueryFilter, \n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Optionally filter by repositoryEndpointId\"\n    repositoryEndpointId: [String!],\n    \"Optionally filter by name, this shall support wildcards\"\n    repositoryEndpointName: [String!],\n    \"Optionally filter by repositoryEndpointUrl\"\n    repositoryEndpointUrl: [String!],\n    \"Sort by one or more attributes, default sort : Sort by creationTime descending\"\n    sort: [QuerySort!]\n  ): SpringArtifactRepositoryEndpointConnection!\n  \"\"\"\n  Query repository recommendations\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `springassessment:Assessment:read`\n  \"\"\"\n  queryRepositoryRecommendations(\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10\n  ): [ArtifactRepositoryRecommendation!]!\n}\n\"Spring Artifact Repository commit information capturing repository snapshot\"\ntype SpringArtifactRepositoryVersion implements Node & RepositoryVersion {\n  \"Optional ArtifactMetadataVersions with which this RepositoryVersion is associated\"\n  artifactMetadataVersions(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,filter: QueryFilter, \n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10\n  ): SpringArtifactMetadataVersionConnection!\n  \"Assessments on this repository version\"\n  assessments(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Input filters to assessments\"\n    filter: SpringArtifactAssessmentFilterInput,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10\n  ): SpringArtifactAssessmentConnection!\n  \"branch for the repository\"\n  branch: String\n  \"Author of commit\"\n  committedBy: String\n  \"Timestamp at which this version is created. Expressed in UTC ISO-8601 format\"\n  creationTime: DateTime!\n  \"Global opaque identifier to meet Node contract\"\n  id: ID!\n  \"\"\"\n  Query aggregated information on artifacts\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `springassessment:Assessment:read`\n  \"\"\"\n  queryArtifactMetadataAggregations(\n    \"Specify aggregation buckets\"\n    aggregations: [ArtifactAssessmentAggregationInput!]!\n  ): [ArtifactAssessmentAggregations]!\n  \"Optional Entities with which this RepositoryVersion is associated\"\n  relatedEntities(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,filter: QueryFilter, \n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10\n  ): EntityConnection!\n  \"repository for this commit\"\n  repository: SpringArtifactRepository!\n  \"Error of SBOM generation\"\n  repositorySbomGenerationStatus: RepositorySbomStatus\n  \"\"\"\n  Domain-specific repository version identifier.\n  For git this will be commit id\n  \"\"\"\n  repositoryVersionId: String!\n  \"Status of SBOM generation\"\n  sbomGenerationStatus: String @deprecated(reason: \"New schema RepositorySbomGenerationStatus is created which is having object of both status and error\")\n}\ntype SpringArtifactRepositoryVersionConnection implements Connection & RepositoryVersionConnection {\n  \"Count of elements in the current page\"\n  count: Int!\n  \"Edges to nodes available through the connection\"\n  edges: [SpringArtifactRepositoryVersionEdge!]\n  \"Paging support\"\n  pageInfo: PageInfo!\n  \"List of RepositoryVersions\"\n  repositoryVersions: [SpringArtifactRepositoryVersion!]\n  \"Optional total elements count across all pages when available\"\n  totalCount: Int\n}\ntype SpringArtifactRepositoryVersionEdge implements ConnectionEdge & RepositoryVersionEdge {\n  \"Optional cursor to refer to this node\"\n  cursor: String\n  \"Node element available through this edge\"\n  node: SpringArtifactRepositoryVersion!\n}\n\"Represents a software bundle or unit. This is a hierarchical structure where one package may have other packages as dependencies.\"\ntype SpringArtifactSBOM implements ArtifactSBOM & Node {\n  \"\"\"\n  Domain-specific artifact sbom identifier\n  unique identifier for a package, may be hash value or checksum generated from the package's content\n  \"\"\"\n  artifactSBOMId: String!\n  \"Connection of interconnected packages contained within a Package\"\n  dependencies(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"This is not supported as of now, will be supported in future\"\n    filter: QueryFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Input filters to filter Package Dependencies\"\n    sbomFilter: SpringArtifactSBOMFilterInput,\n    \"Sort by one or more attributes\"\n    sort: [QuerySort!]\n  ): SpringArtifactSBOMConnection!\n  \"Global opaque identifier to meet Node contract\"\n  id: ID!\n  \"Latest Version of the package\"\n  latestVersion: String\n  \"\"\"\n  license is determined by the SPDX document creator (which is often an SBOM tool or the document creator in the case of disjunctive licenses)\n  refer : https://fossa.com/blog/understanding-using-spdx-license-identifiers-license-expressions\n  \"\"\"\n  licenseConcluded: String\n  \"\"\"\n  license is stated by the component (e.g. package or file) author\n  refer : https://fossa.com/blog/understanding-using-spdx-license-identifiers-license-expressions\n  \"\"\"\n  licenseDeclared: String\n  \"Name of the package\"\n  name: String!\n  \"Open-source support information about Package\"\n  ossSupport: SpringArtifactSBOMOssSupport\n  \"\"\"\n  Package URL - standardized format for representing package metadata.\n  Eg. pkg:rpm/fedora/curl@7.50.3-1.fc25?arch=i386&distro=fedora-25 , pkg:pypi/django@1.11.1\n  Refer : https://github.com/package-url/purl-spec , https://github.com/package-url/purl-spec/blob/master/PURL-SPECIFICATION.rst\n  \"\"\"\n  packageUrl: String\n  \"Effort required to upgrade Package\"\n  upgradeEffort: SpringArtifactSBOMUpgradeEffort\n  \"Version of the package\"\n  version: String\n  \"\"\"\n  Connection of potential vulnerabilities detected for a Package.\n  The vulnerabilities will be aggregated from all levels to the root,\n  \"\"\"\n  vulnerabilities(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Input filters to filter Package Dependencies\"\n    filter: QueryFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Input filters to filter Vulnerabilities\"\n    vulnerabilityFilter: SpringArtifactSBOMVulnerabilityFilterInput\n  ): SpringArtifactVulnerabilityConnection!\n  \"Package Vulnerability Summary based on severity type\"\n  vulnerabilitySummary: SpringArtifactSBOMVulnerabilitySummary\n}\ntype SpringArtifactSBOMConnection implements ArtifactSBOMConnection & Connection {\n  \"List artifact SBOM(s).\"\n  artifactSBOMs: [SpringArtifactSBOM!]\n  \"count of Packages on this page\"\n  count: Int!\n  \"relay-compatible Package edges\"\n  edges: [SpringArtifactSBOMInfoEdge!]\n  \"relay-compatible page info\"\n  pageInfo: PageInfo!\n  \"Total count of Packages, may not always be an exact number and hence consumers should not rely only on this\"\n  totalCount: Int\n}\ntype SpringArtifactSBOMInfoEdge implements ArtifactSBOMEdge & ConnectionEdge {\n  \"Cursor is an opaque string, you can use it to request subsequent or preceding items in the list\"\n  cursor: String!\n  \"Package node\"\n  node: SpringArtifactSBOM!\n}\ntype SpringArtifactSBOMOssSupport {\n  \"commercial support end date\"\n  commercialSupportEndDate: String\n  \"OSS release date for package\"\n  initialReleaseDate: String\n  \"OSS support end date for package\"\n  ossSupportEndDate: String\n  \"Support status\"\n  ossSupportStatus: SpringArtifactSBOMSupportStatus\n}\n\"Spring Artifact SBOM Summary\"\ntype SpringArtifactSBOMSummary {\n  \"Support Status Summary\"\n  supportStatus: SpringArtifactSummaryItems\n  \"Support Status Summary Projections by upgrade effort\"\n  supportStatusProjection(effort: SpringArtifactUpgradeEffort!): SpringArtifactSummaryItems\n  \"Total count of Artifacts\"\n  totalArtifactsCount: Long!\n  \"Vulnerability Summary\"\n  vulnerability: SpringArtifactSummaryItems\n  \"Vulnerability Summary Projections by upgrade effort\"\n  vulnerabilityProjection(effort: SpringArtifactUpgradeEffort!): SpringArtifactSummaryItems\n}\n\"Describes upgrade effort and associated plan for upgrading an spring artifact\"\ntype SpringArtifactSBOMUpgradeEffort {\n  \"Represents effort needed to upgrade a spring artifact version\"\n  effort: SpringArtifactUpgradeEffort!\n  \"Describes how a spring artifact can be upgraded\"\n  upgradePlan: SpringArtifactSBOMUpgradePlan!\n}\n\"Describes how a spring artifact can be upgraded\"\ntype SpringArtifactSBOMUpgradePlan {\n  \"describes upgrade step\"\n  plan: String!\n  \"optionally provide link to artifact release URL\"\n  planUrl: HyperLink\n}\n\"Spring Artifact SBOM Vulnerability Summary\"\ntype SpringArtifactSBOMVulnerabilitySummary {\n  \"Represents vulnerability severity of a spring artifact\"\n  vulnerabilitySeverity: SpringArtifactVulnerabilitySeverity\n  \"Vulnerability summary items associated with SBOM\"\n  vulnerabilitySummaryItems: SpringArtifactSummaryItems\n}\n\"Spring Artifact Summary Item\"\ntype SpringArtifactSummaryItem {\n  count: Long!\n  itemType: String!\n}\n\"Spring Artifact Summary Items\"\ntype SpringArtifactSummaryItems {\n  items: [SpringArtifactSummaryItem!]\n  total: Long!\n}\ntype SpringArtifactTraits {\n  \"Get the latest spring Artifact Metadata Version for Entity\"\n  latestSpringArtifactMetadataVersion: SpringArtifactMetadataVersion\n  \"\"\"\n  Query aggregated information on spring artifacts\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `springassessment:Assessment:read`\n  \"\"\"\n  querySpringArtifactAggregations(\n    \"Specify aggregation buckets\"\n    aggregationInputs: [ArtifactAssessmentAggregationInput!]!\n  ): [ArtifactAssessmentAggregations!]!\n  \"List of SBOMs associated with this entity id\"\n  querySpringArtifactSBOM(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Query filters for advanced filtering\"\n    filter: QueryFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,sbomFilter: SpringArtifactSBOMFilterInput, \n    \"Sort by one or more attributes\"\n    sort: [QuerySort!]\n  ): SpringArtifactSBOMConnection!\n  \"\"\"\n  \n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `springassessment:Assessment:read`\n  \"\"\"\n  querySpringArtifactVulnerability(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Input filters to filter Vulnerabilities\"\n    vulnerabilityFilter: SpringArtifactSBOMVulnerabilityFilterInput\n  ): SpringArtifactVulnerabilityConnection!\n}\n\"Represents a software vulnerability that can be exploited\"\ntype SpringArtifactVulnerability implements ArtifactVulnerability & Node {\n  \"Details of Packages affected by this vulnerability\"\n  affectedPackages: [ArtifactVulnerabilityDetectionInfo!]\n  \"Contains information about the packages that are associated with vulnerability\"\n  artifactSBOM: SpringArtifactSBOMConnection\n  \"Domain-specific artifact vulnerability instance identifier - CVE_ID\"\n  artifactVulnerabilityId: String!\n  \"CVE Numbering Authority \"\n  cna: String\n  \"Description of the Vulnerability\"\n  description: String!\n  \"Global opaque identifier to meet Node contract\"\n  id: ID!\n  \"CVE Name\"\n  name: String!\n  \"\"\"\n  Date on which vulnerability is published, e.g. Expressed in UTC ISO-8601 format \"2022-11-22T02:15:00Z\"\n  \"\"\"\n  publishedDate: DateTime!\n  \"CVSS score\"\n  scores: [ArtifactVulnerabilityScore!]\n  \"Threat level of vulnerability\"\n  severity: String\n  \"\"\"\n  Optional Date on which the vulnerability was reassessed/updated, e.g. Expressed in UTC ISO-8601 format \"2022-11-22T02:15:00Z\"\n  \"\"\"\n  updatedDate: DateTime\n  \"Related url to the vulnerability\"\n  url: String\n}\ntype SpringArtifactVulnerabilityConnection implements ArtifactVulnerabilityConnection & Connection {\n  \"Vulnerabilities instances\"\n  artifactVulnerabilities: [SpringArtifactVulnerability!]\n  \"Count of Vulnerabilities on this page\"\n  count: Int!\n  \"Relay-compatible Vulnerability edges\"\n  edges: [SpringArtifactVulnerabilityEdge!]\n  \"Relay-compatible page info\"\n  pageInfo: PageInfo!\n  \"Total count of Vulnerabilities, may not always be an exact number and hence consumers should not rely only on this\"\n  totalCount: Int\n}\ntype SpringArtifactVulnerabilityEdge implements ArtifactVulnerabilityEdge & ConnectionEdge {\n  \"Cursor is an opaque string, you can use it to request subsequent or preceding items in the list\"\n  cursor: String!\n  \"Vulnerability node\"\n  node: SpringArtifactVulnerability!\n}\n\"Time-series stat\"\ntype Stat {\n  \"\"\"\n  Anomaly data\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  \"\"\"\n  anomaly: StatAnomaly\n  \"Samples of numeric stats\"\n  data: [Float!]\n  \"Forecast data\"\n  forecast: StatForecast\n  \"Stat key e.g. cpu_alloc, cpu_demand etc. - populated when available, but some queries may aggregate across keys\"\n  key: String\n  \"Modes of sample numeric stats e.g. NUM, NAN etc.\"\n  modes: [StatDataMode!]\n  \"Stats namespace\"\n  namespace: String!\n  \"Stat tags in the form of key/value pairs\"\n  tags: [Tag!]\n  \"Sample timestamps in milliseconds since epoch\"\n  timestampsMillis: [Long!]\n  \"Samples of string/enum stats\"\n  values: [String!]\n}\ntype StatAnomaly {\n  \"Anomaly data -1 in case of downward anomaly , +1 in case of upward anomaly and 0 in case of no anomaly\"\n  data: [Int!]\n  \"History Start time\"\n  historyStartTime: DateTime!\n  \"Number of data points present in the time series including current and history time\"\n  length: Int!\n  \"Lower bound value used to calculate anomalies. Stat values below this will be marked as anomalies with value -1\"\n  lower: [Float!]\n  \"Seasonality period of the time-series\"\n  period: Int!\n  \"Seasonality of the time-series representing whether it is seasonal or non seasonal\"\n  seasonal: Boolean!\n  \"Anomaly timestamps in milliseconds since epoch\"\n  timestampsMillis: [Long!]\n  \"Upper bound value used to calculate anomalies. Stat values above this will be maked as anomalies with value +1\"\n  upper: [Float!]\n}\n\"Forecast data for this times-eries\"\ntype StatForecast {\n  \"Forecast data\"\n  data: [Float!]\n  \"Confidence lower band\"\n  lower: [Float!]\n  \"\"\"\n  Predicted timestamp when requested threshold is reached (in milliseconds since epoch)\n  It is not set if threshold is already reached before forecastStartTime, and it is -1 if threshold\n  cannot be determined (e.g., a trend line could not be determined).\n  \"\"\"\n  predictedThresholdReachedTimestampMillis: Long\n  \"Forecast timestamps in milliseconds since epoch\"\n  timestampsMillis: [Long!]\n  \"Confidence upper band\"\n  upper: [Float!]\n}\n\"List of time-series stats for the given entity.\"\ntype Stats {\n  \"Reference to the Entity for these stats\"\n  entity: Entity\n  stats: [Stat!]\n}\n\"This is the default implementation of the StatsProviderInterface\"\ntype StatsProvider implements StatsProviderInterface {\n  \"Information about this provider\"\n  providerInfo: StatsProviderInfo!\n  \"Stats query interface that must be implemented by a provider\"\n  queryStats(\n    \"\"\"\n    Optional list of entityIds to query for stats.\n    If no entityIds are specified, the stats are queried based on the input\n    Note that entity stats queries with the registered namesapce will be redirected to this query interface\n    via the EntityStatsDataLoader and so will submit batches of queries typically with 1000 entityIds in each batch\n    and if with a list of EntityIds in each batch, it's the responsibility of the implementor to subdivide\n    if a smaller batch size is required (e.g. vRNI requires individual stats queries).\n    \"\"\"\n    entityId: [EntityId!],\n    \"Query parameters\"\n    input: StatsInput\n  ): [Stats!]\n}\ntype StatsProviderInfo {\n  \"\"\"\n  Namespace for this stats provider - stats queries directed to this namespace will be sent to this provider.\n  This would usually be the same as the fieldname in the _StatsProviders but there may be a difference e.g. in casing,\n  the namespace field here is used for the actual stats namespace.\n  \"\"\"\n  namespace: String!\n  \"If set to false, the namespace supports stats queries without providing any entityIds.\"\n  requiresEntityId: Boolean\n  \"Indicates if the stats provider can support a queryString as input\"\n  supportsQueryString: Boolean\n  \"\"\"\n  If set to false, stats provider is invoked with the default entityIds.\n  Set to true if the stats provider should be invoked with EntityIds coming from the 'id' field from the entity\n  namespace with the same namespace name as the stats provider.\n  \"\"\"\n  useNamespaceId: Boolean!\n}\n\"\"\"\nDirect access to individual stats providers through per-provider fields.\n\nThe general stats queries can also access these providers via specifying the stats namespace in their queries,\nwith the default stats namespace for an entity stats query coming from the entity's own provider.\n\"\"\"\ntype StatsProviders {\n  \"\"\"\n  \n  ### API Permissions:\n  - `observability:ObservabilityStat:read`\n  \"\"\"\n  aria: StatsProvider!\n  \"\"\"\n  \n  ### API Permissions:\n  - `observability:ObservabilityStat:read`\n  \"\"\"\n  ariaKubernetes: StatsProvider!\n  \"\"\"\n  \n  ### API Permissions:\n  - `observability:ObservabilityStat:read`\n  \"\"\"\n  aws: StatsProvider!\n  \"\"\"\n  \n  ### API Permissions:\n  - `observability:ObservabilityStat:read`\n  \"\"\"\n  azure: StatsProvider!\n  \"\"\"\n  \n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `observability:ObservabilityStat.PlatformHealth:read`\n  \"\"\"\n  platformHealth: StatsProvider!\n}\ntype StatsQuery {\n  \"\"\"\n  Starting with a given entity, query for the top N related entities, sorting the related entities by a given stat, using the given traversal.\n  ### API Permissions:\n  - `observability:ObservabilityStat:read`\n  \"\"\"\n  queryRelatedEntitiesByStat(entityId: EntityId!, input: StatsRelatedEntitiesQueryInput!): [StatsRelatedEntity!]\n  \"\"\"\n  Query time-series stats for a given list of entity IDs.\n  ### API Permissions:\n  - `observability:ObservabilityStat:read`,\n  - `observability:ObservabilityStat.PlatformHealth:read`\n  \"\"\"\n  queryStats(\n    \"Optional list of entityIds to query for stats. If no entityIds are specified, the stats are queried based on the input\"\n    entityId: [EntityId!],\n    \"Query parameters\"\n    input: StatsInput\n  ): [Stats!]\n  \"\"\"\n  Direct access to individual stats provider queries through per-provider fields.\n  \n  The top-level stats queries leverage these providers based upon the stats query's namespace.\n  If no namespace is specified by the user, the namespaces and thus providers are chosen from the provider information from the entityIds.\n  \"\"\"\n  statsProviders: StatsProviders!\n}\ntype StatsRelatedEntity {\n  entity: Entity!\n  stat: Stat!\n}\n\"Tag containing key and optional value strings\"\ntype Tag {\n  key: String!\n  value: String\n}\n\"Hub policy\"\ntype TanzuHubPolicy implements HubPolicy & Node & NodeVersion {\n  \"CSP user who created hub policy\"\n  createdBy: User!\n  \"Timestamp at which hub policy is created. Expressed in UTC ISO-8601 format\"\n  creationTime: DateTime!\n  \"Policy description\"\n  description: LocalizedString\n  \"\"\"\n  If the policy is enabled or not\n  If disabled, schedule based policy evaluation will stop. But user will still be able to evaluate the policy using API.\n  \"\"\"\n  enabled: Boolean!\n  \"Policy execution schedule\"\n  executionSchedule: TanzuHubPolicyExecutionSchedule!\n  \"Opaque global ID\"\n  id: ID!\n  \"last run time\"\n  lastRunTime: DateTime\n  \"Timestamp at which hub policy is updated. Expressed in UTC ISO-8601 format\"\n  lastUpdateTime: DateTime\n  \"Versioning ID\"\n  nodeVersion: ID!\n  \"Policy id\"\n  policyId: String!\n  \"Policy name\"\n  policyName: LocalizedString!\n  \"Policy Providers like Cost, Spring, Aria/Tanzu\"\n  policyProvider: String!\n  \"\"\"\n  Rules for this policy.\n  A rule is a set Graphql Query + post processing that filters data in the Hub Graph.\n  Rule has associated actions.\n  A rule is considered evaluated to NON_COMPLIANT if there are resources returned by the graphQL query + post-processing\n  If a rule evaluates to NON_COMPLIANT, the associated actions are executed.\n  \n  Rules for a policy are a executed sequentially and if any rule evaluates to NON_COMPLIANT further rule execution is stopped.\n  \"\"\"\n  rules: [TanzuHubPolicyRule!]!\n  \"policy run status\"\n  runStatus: HubPolicyRunStatus\n  \"CSP user who updated hub policy\"\n  updatedBy: User\n}\n\"TanzuHubPolicyAlert\"\ntype TanzuHubPolicyAlert {\n  \"Alert category\"\n  category: TanzuHubPolicyAlertCategory!\n  \"Alert severity\"\n  severity: TanzuHubPolicyFindingSeverity!\n  \"Custom tags to be populated\"\n  tags: [Tag!]\n  \"Alert type\"\n  type: TanzuHubPolicyAlertType!\n}\n\"Policy\"\ntype TanzuHubPolicyConnection implements Connection & HubPolicyConnection {\n  \"count of polices on this page\"\n  count: Int!\n  \"Hub Policy edge\"\n  edges: [TanzuHubPolicyEdge!]\n  \"Represents pagination information in Relay about the edges.\"\n  pageInfo: PageInfo!\n  \"Policies\"\n  policies: [TanzuHubPolicy!]\n  \"Total count of polices\"\n  totalCount: Int\n}\n\"Policy edge\"\ntype TanzuHubPolicyEdge implements ConnectionEdge & HubPolicyEdge {\n  \"Cursor is an opaque string, you can use it to request subsequent or preceding items in the list\"\n  cursor: String!\n  \"Policy node\"\n  node: TanzuHubPolicy!\n}\n\"Policy Execution Schedule\"\ntype TanzuHubPolicyExecutionSchedule {\n  \"\"\"\n  Cron expression in \"tz sec min hour dom m dow\" format plus last-day-of-month support ('L')\n  \"\"\"\n  cronExpression: String\n  \"Schedule meta information for policy execution on a schedule basis.\"\n  schedule: TanzuHubPolicySchedule\n}\ntype TanzuHubPolicyMutation {\n  \"\"\"\n  Delete the policy\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `policy:*:delete`\n  \"\"\"\n  deleteHubPolicy(input: [HubPolicyIdInput!]): TanzuHubPolicyUpdateResult!\n  \"\"\"\n  Evaluate Policy in an ad-hoc manner. The regular execution will still happen.\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `policy:*:read`\n  \"\"\"\n  evaluateHubPolicy(policyId: String!): TanzuHubPolicyRun!\n  providers: HubPolicyMutationProviders!\n  \"\"\"\n  This will enable/disable the scheduled execution of the policy\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `policy:*:update`\n  \"\"\"\n  setHubPolicyActivationStatus(input: [HubPolicyIdInput!], status: Boolean = true): TanzuHubPolicyUpdateResult!\n}\ntype TanzuHubPolicyMutationProvider implements HubPolicyMutationProvider {\n  \"\"\"\n  Create a Hub Policy.\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `policy:*:create`\n  \"\"\"\n  createHubPolicy(\n    \"Policy details\"\n    input: TanzuHubPolicyCreateInput!\n  ): TanzuHubPolicy!\n  \"\"\"\n  \n  ### API Permissions:\n  - `policy:*:read`\n  \"\"\"\n  name: String!\n  \"\"\"\n  Test the policy. This includes validation and query execution.\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `policy:*:read`\n  \"\"\"\n  testHubPolicy(input: TanzuHubPolicyCreateInput!): TanzuHubPolicyTestRun!\n  \"\"\"\n  Update the policy\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `policy:*:update`\n  \"\"\"\n  updateHubPolicy(\n    \"Policy details\"\n    input: TanzuHubPolicyEditInput!\n  ): TanzuHubPolicy!\n}\ntype TanzuHubPolicyQuery {\n  providers: HubPolicyQueryProviders!\n}\ntype TanzuHubPolicyQueryProvider implements HubPolicyQueries & HubPolicyQueriesProvider {\n  name: String!\n  providerInfo: HubPolicyProviderInfo!\n  \"\"\"\n  Get policy details based on filter criteria\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  \"\"\"\n  queryHubPolicies(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Optional filters to filter policies that are fetched. It will be supported in future\"\n    filter: QueryFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Results are sorted as per fields and order specified. Supported fields are policyName, createdBy and updatedBy\"\n    sort: [QuerySort!],\n    \"Optional filters to filter policies that are fetched\"\n    tanzuHubPolicyFilter: TanzuHubPolicyFilter\n  ): TanzuHubPolicyConnection\n  \"\"\"\n  Get policy run details\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  \"\"\"\n  queryHubPolicyRuns(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Optional filters to filter policies that are fetched. It will be supported in future\"\n    filter: QueryFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Results are sorted as per fields and order specified. Supported fields are name, status. Default Sort will be on LastUpdateTime\"\n    sort: [QuerySort!],\n    \"Optional filters to filter policies that are fetched\"\n    tanzuHubPolicyRunFilter: TanzuHubPolicyRunFilter\n  ): TanzuHubPolicyRunConnection\n}\n\"Policy rule\"\ntype TanzuHubPolicyRule {\n  \"graphQL query to be executed to fetch the data\"\n  graphQLQuery: String!\n  \"graphQL variables needed for query execution\"\n  graphQLQueryVariables: JSON\n  \"Pagination details \"\n  paginationData: DerivedDataPagination\n  \"Policy Rule actions provided\"\n  policyRuleActions: TanzuHubPolicyRuleAction\n  \"Rules/conditions that are going to get evaluated\"\n  processingRules: DerivedDataProcessingRules\n  \"Rule id\"\n  ruleId: String!\n  \"Rule name\"\n  ruleName: LocalizedString!\n}\n\"TanzuHubPolicyRuleAction\"\ntype TanzuHubPolicyRuleAction {\n  \"HubPolicyAlert\"\n  alert: TanzuHubPolicyAlert\n}\n\"Rule run status\"\ntype TanzuHubPolicyRuleRun {\n  \"Rule execution result\"\n  evaluationResult: JSON\n  \"Associated Policy run\"\n  policyRun: TanzuHubPolicyRun!\n  \"Associated Policy rule\"\n  rule: TanzuHubPolicyRule!\n  \"Rule evaluation status\"\n  ruleEvaluationStatus: TanzuHubPolicyRuleEvaluationStatus\n}\n\"Test Rule run status\"\ntype TanzuHubPolicyRuleTestRun {\n  \"Rule execution result\"\n  evaluationResult: JSON\n  \"Associated Policy rule\"\n  rule: TanzuHubPolicyRule!\n  \"Rule evaluation status\"\n  ruleEvaluationStatus: TanzuHubPolicyRuleEvaluationStatus\n}\n\"Policy run created after policy evaluation\"\ntype TanzuHubPolicyRun implements HubPolicyRun & Node {\n  \"Timestamp at which hub policy is executed. Expressed in UTC ISO-8601 format\"\n  creationTime: DateTime!\n  \"Opaque global ID\"\n  id: ID!\n  \"Associated policy\"\n  policy: TanzuHubPolicy!\n  \"Associated policy rule runs\"\n  policyRuleRuns: [TanzuHubPolicyRuleRun!]\n  \"Policy run status\"\n  status: HubPolicyRunStatus\n}\n\"\"\"\nTime during the day schedule should run at, its value are in 24 hr format.\ne.g.\ntimezone -> 'Asia/Kolkata'\nhour -> 14\nmin  -> 50\n\"\"\"\ntype TanzuHubPolicyRunAt {\n  hour: Int!\n  min: Int!\n  timezone: String!\n}\n\"Policy run details- Connection object\"\ntype TanzuHubPolicyRunConnection implements Connection & HubPolicyRunConnection {\n  \"count of policy runs on this page\"\n  count: Int!\n  \"Hub Policy run edge\"\n  edges: [TanzuHubPolicyRunEdge!]\n  \"Represents pagination information in Relay about the edges.\"\n  pageInfo: PageInfo!\n  \"policy runs\"\n  policyRuns: [TanzuHubPolicyRun!]\n  \"Total count of policy runs\"\n  totalCount: Int\n}\n\"Policy run details\"\ntype TanzuHubPolicyRunEdge implements ConnectionEdge & HubPolicyRunEdge {\n  \"Cursor is an opaque string, you can use it to request subsequent or preceding items in the list\"\n  cursor: String!\n  \"Policy node\"\n  node: TanzuHubPolicyRun!\n}\n\"Schedule for policy execution on a schedule basis.\"\ntype TanzuHubPolicySchedule {\n  \"\"\"\n  Date of the month that tasks run. Returns a date between 1-31.If 29 is returned then it will run on 29th of every month expect February(28)\n  i.e. it will be skipped for February.Returned for Monthly interval only.\n  \"\"\"\n  dayOfMonth: Int\n  \"Day of week.\"\n  dayOfWeek: [TanzuHubPolicyDaysOfWeek!]\n  \"Frequency that the schedule runs for the specified interval. For example, if the interval is Hourly, a frequency of 2 means the task runs every 2 hours.\"\n  frequency: Int!\n  \"\"\"\n  Interval or repeat frequency at which the schedule runs.\n  NOTE:\n  1) When a `WEEK` interval is selected then `dayOfWeek` is required.\n  2) When a `MONTH` interval is selceted then `dayOfMonth` is required.\n  \"\"\"\n  interval: TanzuHubPolicyIntervalType!\n  \"\"\"\n  Time during the day it should run at - any value between 00:00 to 23:59\n  NOTE: runAt is not applicable for 'HOURLY' intervals.\n  \"\"\"\n  runAt: TanzuHubPolicyRunAt\n}\ntype TanzuHubPolicyTestRun {\n  \"Associated policy rule test runs\"\n  policyRuleRuns: [TanzuHubPolicyRuleTestRun!]\n  \"Policy run status\"\n  status: HubPolicyRunStatus\n}\ntype TanzuHubPolicyUpdateFailure {\n  \"Error\"\n  errorMessage: String\n  \"Versioning ID\"\n  nodeVersion: ID!\n  \"Unique identifier for the policy\"\n  policyId: String!\n}\ntype TanzuHubPolicyUpdateResult {\n  \"Delete/Enable/Disable failures with error messages\"\n  failure: [TanzuHubPolicyUpdateFailure!]\n  \"Hub policies successfully deleted/enabled/disabled. For delete operation, this will contain the hub policy before deletion\"\n  success: [TanzuHubPolicy!]\n}\ntype UsageLimitResponse {\n  \"Current value found in system for data type \"\n  currentValue: Int\n  \"Max value configured in system for data type \"\n  maxValue: Int\n  \"Observability resource type\"\n  resourceType: ObservabilityResourceType\n  \"Returns usage limit status\"\n  status: UsageLimitStatus\n}\n\"User type. Users are defined in CSP and this type has fields from CSP together with additional semantics from Ensemble\"\ntype User implements Node {\n  \"The actual email to contact the user. This field doesn't always equal to the 'username'\"\n  email: String\n  \"The first name of the user.\"\n  firstName: String\n  groups: [UserGroup!]\n  \"Opaque globally scoped identifier of this node\"\n  id: ID!\n  \"The last name of the user.\"\n  lastName: String\n  organizationRoles: [UserOrganizationRole!]\n  \"\"\"\n  The below fields are also in the CSP type but I didn't think it useful to expose through graphql - we may wish to do so later.\n     \"The identity provider (IdP) domain of the user. The value will be 'vmwareid' in case the user is VMware ID user.\"\n     domain: String\n     \"The user's Identity Provider Identifier.\"\n     idpId: String\n     \"User is inaccessible if it will not be able to login with it's VMware ID credentials. Since the user is federated and will be redirected to it's Identity Provider.\"\n     accessible: Boolean\n  \"\"\"\n  serviceRoles: [UserServiceRole!]\n  \"The account identifier string used by the user to log in. Users might not necessarily use their email.\"\n  userAccount: String\n  \"Unique user ID - this is the immutable identifier of a user\"\n  userId: String\n  \"Array of user preferences. Each user pref would specify the entity and a list of user preferences. Only populated for current user.\"\n  userPrefs: [UserPref!]\n  \"username of the user\"\n  username: String!\n}\n\"Relay compatible page of Users\"\ntype UserConnection implements Connection {\n  \"Count of users in this page.\"\n  count: Int!\n  \"relay-compatible connection edge\"\n  edges: [UserEdge!]\n  pageInfo: PageInfo!\n  \"Optional total count of matching users\"\n  totalCount: Int\n  \"User list\"\n  users: [User!]\n}\ntype UserEdge implements ConnectionEdge {\n  cursor: String!\n  node: User!\n}\n\"Each UserEntityField holds information associated to a given entity-user combination, such as preferences or interest scores.\"\ntype UserEntityFields {\n  \"User to whom these fields apply\"\n  user: User!\n  \"User's Interest Level in the entity : LOW, MEDIUM, HIGH. If  the user has not interacted with the entity, interest will fall into LOW bucket\"\n  userInterestLevel: UserInterestLevel\n  \"Score representing User's interest in the parent entity\"\n  userInterestScore: Float\n  \"User preference associated to the user\"\n  userPrefs(name: [String!]): [UserPref!]\n}\ntype UserGroup implements Node {\n  description: String\n  groupId: String\n  groupName: String\n  \"Opaque globally scoped identifier of this node\"\n  id: ID!\n}\n\"Relay compatible page of groups\"\ntype UserGroupConnection implements Connection {\n  \"Count of users in this page.\"\n  count: Int!\n  \"relay-compatible connection edge\"\n  edges: [UserGroupEdge!]\n  \"Group list\"\n  groups: [UserGroup!]\n  pageInfo: PageInfo!\n  \"Optional total count of matching groups\"\n  totalCount: Int\n}\ntype UserGroupEdge implements ConnectionEdge {\n  cursor: String!\n  node: UserGroup!\n}\n\" Represent User's Interest Score in a entity\"\ntype UserInterestScore implements Node {\n  entity: Entity!\n  id: ID!\n  score: Float!\n  user: User!\n}\ntype UserMutation {\n  \"\"\"\n  Upsert a user preference. If input.value is null, any existing UserPref is deleted.\n  ### API Permissions:\n  - `user:UserPreference:create`\n  \"\"\"\n  upsertUserPref(input: UserPrefInput!): UserPref\n}\n\"User Organization Role type\"\ntype UserOrganizationRole {\n  \"Display name of organization role\"\n  displayName: String!\n  \"Datetime stamp when organization role expires\"\n  expiresAt: DateTime\n  \"Name of the role. e.g. value: project_admin\"\n  name: String!\n}\ntype UserPref {\n  \"Time this pref was created. Note: Expressed in UTC ISO-8601 timestamp\"\n  creationTime: DateTime!\n  \"Optional entity to which this userPref is associated\"\n  entity: Entity\n  \"Last time this pref was updated. Note: Expressed in UTC ISO-8601 timestamp\"\n  lastUpdateTime: DateTime!\n  \"name of this user-pref in the context of the user and entityId\"\n  name: String!\n  \"Scope of the preference: USER (user-specific) or GLOBAL (organization-wide)\"\n  scope: UserPrefScope!\n  \"user owning this preference\"\n  user: User!\n  \"Max size for value in UTF-8 is 32Kb. May contain a JSON-serialized String\"\n  value: String\n}\ntype UserQuery {\n  \"Fetch information for the logged in user\"\n  currentUser: User!\n  \"\"\"\n  \n  ### API Permissions:\n  - `auth:Groups:read`\n  \"\"\"\n  queryGroups(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Optional Search criteria to search for groups by their display names\"\n    searchTerm: String\n  ): UserGroupConnection\n  \"Query UserPrefs optionally filtering by entityId, preference name, and/or scope\"\n  queryUserPrefs(entityId: [EntityId!], name: [String!], scope: [UserPrefScope]): [UserPref!]\n  \"\"\"\n  \n  ### API Permissions:\n  - `auth:Users:read`\n  \"\"\"\n  queryUsers(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Optional Search criteria to search for users by their first name, last name and email\"\n    searchTerm: String\n  ): UserConnection\n}\n\"User Service Role type\"\ntype UserServiceRole {\n  \"Name of the role. e.g. value: ensemble:admin\"\n  name: String!\n}\n\"Internal validate credential response\"\ntype WarehouseCredentialsValidationResponse {\n  httpCode: Int\n  isValid: Boolean!\n  message: String\n}\n\"Result data from the entities reconciliation process\"\ntype WarehouseEntitiesReconciliationResult {\n  \"Number of entities that were really updated on the relationships\"\n  entitiesActuallyUpdated: Int!\n  \"Number of entities actually sent for persisting relation\"\n  entitiesSentForUpdate: Int!\n  \"Number of entities visited for reconciliation\"\n  entitiesVisited: Int!\n  \"Product type requested for reconciliation\"\n  productType: WarehouseProductType\n}\ntype WarehouseIndexerState {\n  lastIndexFinished: DateTime\n  lastIndexStarted: DateTime\n  running: Boolean!\n  warehouseTokenValid: Boolean\n}\n\"Tanzu Warehouse Mutations\"\ntype WarehouseMutation {\n  \"\"\"\n  Forces the warehouse to be re-indexed from the external source of truth (e.g., TanzuNet)\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `warehouse:Catalog:update`\n  \"\"\"\n  catalogUpdate(input: WarehouseProductReleaseInput): String!\n  \"\"\"\n  Provision a product release (also known as a capability) from the external source into the central foundation.\n  Returns a unique task ID that can be used to track the provisioning progress.\n  \n  @param input The provision request parameters\n  @return String A unique workflow ID for tracking the progress\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `warehouse:ProductDownload:create`\n  \"\"\"\n  downloadProductRelease(input: WarehouseDownloadProductReleaseInput): String!\n  \"\"\"\n  Reset the reconcile status and get ready to invoke a fresh reconciliation process for the specified product type\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `warehouse:Catalog:update`\n  \"\"\"\n  reconcileProducts(input: WarehouseReconcileProductsInput!): WarehouseReconcileProductsResult!\n  \"\"\"\n  Validate credentials\n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  \"\"\"\n  validateWarehouseCredentials(input: WarehouseCredentialsValidationInput): WarehouseCredentialsValidationResponse!\n}\ntype WarehouseQuery {\n  \"\"\"\n  \n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  ### API Permissions:\n  - `warehouse:indexer:read`\n  \"\"\"\n  state: WarehouseIndexerState!\n}\ntype WarehouseReconcileProductsResult {\n  \"Message indicating the actions executed\"\n  message: String!\n  \"Result data from the entities reconciliation process in case the reconcile happened\"\n  result: WarehouseEntitiesReconciliationResult\n}\n\"A WorkflowRun is a workflow execution instance.\"\ntype WorkflowRun implements Node {\n  completionTime: String!\n  \"createdBy is the user that created this workflow run.\"\n  createdBy: String!\n  \"creationTime is the date and time when this workflow run was created.\"\n  creationTime: String!\n  \"errorMessage is populated when this workflow run fails.\"\n  errorMessage: String\n  id: ID!\n  \"name is the friendly name or workflow type for this run.\"\n  name: String!\n  \"parentID is populated when this workflow run is a child of another workflow run.\"\n  parentID: ID\n  \"status is the current status of the workflow run.\"\n  status: WorkflowStatus!\n  \"tasks are the ordered history of tasks for the workflow run.\"\n  tasks: [WorkflowTask!]!\n}\n\"A WorkflowRun is a workflow execution instance.\"\ntype WorkflowRunInfo implements Node {\n  completionTime: String!\n  \"createdBy is the user that created this workflow run.\"\n  createdBy: User\n  \"creationTime is the date and time when this workflow run was created.\"\n  creationTime: String!\n  \"errorMessage is populated when this workflow run fails.\"\n  errorMessage: String\n  id: ID!\n  \"Name of workflow.\"\n  name: String\n  \"status is the current status of the workflow run.\"\n  status: WorkflowStatus!\n  \"Workflow type\"\n  type: String!\n}\ntype WorkflowRunInfoConnection implements Connection {\n  \"Count of workflow runs in this page\"\n  count: Int!\n  edges: [WorkflowRunInfoEdge!]\n  pageInfo: PageInfo!\n  \"Total count of matching workflow runs\"\n  totalCount: Int\n  \"List of workflow runs in this page\"\n  workflowRuns: [WorkflowRunInfo!]\n}\ntype WorkflowRunInfoEdge implements ConnectionEdge {\n  cursor: String!\n  node: WorkflowRunInfo!\n}\ntype WorkflowRunQuery {\n  \"\"\"\n  Find a workflow run from its ID.\n  ### API Permissions:\n  - `entity:*:read`\n  \"\"\"\n  queryWorkflowRunDetails(id: ID!): WorkflowRun\n  \"\"\"\n  Query workflow runs with provided search input.\n  This query has a hard limit of returning a maximum of a 1000 records across all pages.\n  Please tweak the search criteria in the input to keep your response to a maximum of 1000 workflow runs.\n  ### API Permissions:\n  - `entity:*:read`\n  \"\"\"\n  queryWorkflowRuns(input: WorkflowSearchInput!): WorkflowRunInfoConnection\n}\ntype WorkflowTask {\n  completionTime: String!\n  creationTime: String!\n  \"errorMessage is populated when this workflow task fails.\"\n  errorMessage: String\n  name: String!\n  \"status is the current status of the workflow task.\"\n  status: WorkflowTaskStatus!\n  \"workflowID is populated when this task is a child workflow run.\"\n  workflowID: ID\n}\n\"\"\"\nAn analysis done on an artifact is an assessment.\nAn assessment is an operational data that captures user/project visibility information.\nDomain specific implementation may add to this as appropriate.\n\"\"\"\ninterface ArtifactAssessment implements Node {\n  \"Domain-specific artifact assessment instance identifier\"\n  artifactAssessmentId: String!\n  \"artifactMetadataVersion with which this assessment is associated\"\n  artifactMetadataVersions(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Optionally filter by artifactMetadataId\"\n    artifactMetadataId: [String!],\n    \"Optionally filter by artifactMetadata name, will support wildcard *\"\n    artifactMetadataName: [String!],\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Input filters to filter Vulnerabilities\"\n    filter: QueryFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10\n  ): ArtifactMetadataVersionConnection!\n  \"Recommendations for this assessment\"\n  assessmentRecommendations(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10\n  ): ArtifactAssessmentRecommendationConnection!\n  \"CSP user who created Assessment\"\n  createdBy: User!\n  \"Timestamp at which Assessment is created. Expressed in UTC ISO-8601 format\"\n  creationTime: DateTime!\n  \"csp project entity to which this assessment will be visible\"\n  cspProjectEntity: Entity\n  \"Global opaque identifier to meet Node contract\"\n  id: ID!\n  \"Name of the assessment.\"\n  name: String\n}\ninterface ArtifactAssessmentConnection implements Connection {\n  assessments: [ArtifactAssessment!]\n  \"Count of elements in the current page\"\n  count: Int!\n  \"Edges to nodes available through the connection\"\n  edges: [ArtifactAssessmentEdge!]\n  \"Paging support\"\n  pageInfo: PageInfo!\n  \"Optional total elements count across all pages when available\"\n  totalCount: Int\n}\ninterface ArtifactAssessmentEdge implements ConnectionEdge {\n  \"Optional cursor to refer to this node\"\n  cursor: String\n  \"Node element available through this edge\"\n  node: ArtifactAssessment!\n}\n\"An assessment may lead to one or more recommendations contributing to other tanzu hub products upsell.\"\ninterface ArtifactAssessmentRecommendation implements Node {\n  \"Domain-specific artifact assessment recommendation instance identifier\"\n  artifactAssessmentRecommendationId: String!\n  \"Assessment for which this recommendation exists\"\n  assessment: ArtifactAssessment!\n  \"\"\"\n  Description of Recommendation.\n  This will be represented as HTML element as we may need to showcase specific words as hyperlinks in recommendation description,\n  offering users the ability to access Tanzu product subscription link by clicking on those designated words.\n  \"\"\"\n  description: LocalizedString\n  \"Global opaque identifier to meet Node contract\"\n  id: ID!\n  \"Name of recommendation\"\n  name: LocalizedString!\n}\ninterface ArtifactAssessmentRecommendationConnection implements Connection {\n  \"Count of elements in the current page\"\n  count: Int!\n  \"Edges to nodes available through the connection\"\n  edges: [ArtifactAssessmentRecommendationEdge!]\n  \"Paging support\"\n  pageInfo: PageInfo!\n  \"List of ArtifactAssessmentRecommendation\"\n  recommendations: [ArtifactAssessmentRecommendation!]\n  \"Optional total elements count across all pages when available\"\n  totalCount: Int\n}\ninterface ArtifactAssessmentRecommendationEdge implements ConnectionEdge {\n  \"Optional cursor to refer to this node\"\n  cursor: String\n  \"Node element available through this edge\"\n  node: ArtifactAssessmentRecommendation!\n}\n\"\"\"\nArtifactMetadata is a container for additional information about an artifact.\nAn artifact represents the files/images used to deploy a runnable resource whether that be an application, container or VM, not the actual running resource.\nAs of now we support ArtifactSBOMInfo as metadata. Domain specific implementation may add more metadata as appropriate\n\"\"\"\ninterface ArtifactMetadata implements Node {\n  \"Domain-specific artifact metadata instance identifier\"\n  artifactMetadataId: String!\n  \"metadata versions for this ArtifactMetadata\"\n  artifactMetadataVersions(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Optionally filter by artifactMetadata version ids, this should support wildcards Eg. 2.*\"\n    artifactMetadataVersionId: [String!],\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,filter: QueryFilter, \n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Sort by one or more attributes, default SORT order: creationTime descending\"\n    sort: [QuerySort!]\n  ): ArtifactMetadataVersionConnection!\n  \"Global opaque identifier to meet Node contract\"\n  id: ID!\n  \"Artifact name\"\n  name: String!\n}\ninterface ArtifactMetadataConnection implements Connection {\n  \"list of artifact metadata\"\n  artifactMetadata: [ArtifactMetadata!]\n  \"Count of elements in the current page\"\n  count: Int!\n  \"Edges to nodes available through the connection\"\n  edges: [ArtifactMetadataEdge!]\n  \"Paging support\"\n  pageInfo: PageInfo!\n  \"Optional total elements count across all pages when available\"\n  totalCount: Int\n}\ninterface ArtifactMetadataEdge implements ConnectionEdge {\n  \"Optional cursor to refer to this node\"\n  cursor: String\n  \"Node element available through this edge\"\n  node: ArtifactMetadata!\n}\n\"query entrypoint for artifact metadata provider\"\ninterface ArtifactMetadataQueries {\n  \"Query available artifact assessments\"\n  queryArtifactAssessments(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Optionally filter by artifactMetadataId\"\n    artifactMetadataId: [String!],\n    \"Optionally filter by artifactMetadata name\"\n    artifactMetadataName: [String!],\n    \"Optionally filter by artifactMetadata version ids\"\n    artifactMetadataVersionId: [String!],\n    \"Optionally filter by  ids\"\n    assessmentId: [String!],\n    \"Optionally filter by  ids\"\n    assessmentName: [String!],\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,filter: QueryFilter, \n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Sort by one or more attributes, default sort : Sort by creationTime descending\"\n    sort: [QuerySort!]\n  ): ArtifactAssessmentConnection!\n  \"Query available artifact metadata\"\n  queryArtifactMetadata(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Optionally filter by artifactMetadataId\"\n    artifactMetadataId: [String!],\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,filter: QueryFilter, \n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Optionally filter by artifactMetadata name\"\n    name: [String!],\n    \"Sort by one or more attributes, default sort : Sort by name ascending\"\n    sort: [QuerySort!]\n  ): ArtifactMetadataConnection!\n}\ninterface ArtifactMetadataQueryProvider implements ArtifactMetadataQueries {\n  \"Provider name, expected to be the same as the field name used to access this provider, possibly with case differences\"\n  name: String!\n  \"Information about this provider\"\n  providerInfo: ArtifactMetadataProviderInfo!\n  \"Query available artifact assessments\"\n  queryArtifactAssessments(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Optionally filter by artifactMetadataId\"\n    artifactMetadataId: [String!],\n    \"Optionally filter by artifactMetadata name\"\n    artifactMetadataName: [String!],\n    \"Optionally filter by artifactMetadata version ids\"\n    artifactMetadataVersionId: [String!],\n    \"Optionally filter by  ids\"\n    assessmentId: [String!],\n    \"Optionally filter by  ids\"\n    assessmentName: [String!],\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,filter: QueryFilter, \n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Sort by one or more attributes, default sort : Sort by creationTime descending\"\n    sort: [QuerySort!]\n  ): ArtifactAssessmentConnection!\n  \"Query available artifact metadata\"\n  queryArtifactMetadata(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Optionally filter by artifactMetadataId\"\n    artifactMetadataId: [String!],\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,filter: QueryFilter, \n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Optionally filter by artifactMetadata name\"\n    name: [String!],\n    \"Sort by one or more attributes, default sort : Sort by name ascending\"\n    sort: [QuerySort!]\n  ): ArtifactMetadataConnection!\n}\n\"Represents version of an artifact metadata. Each version of metadata may have different SBOM (Or any other future metadata) information.\"\ninterface ArtifactMetadataVersion implements Node {\n  \"Artifact metadata with which this version is associated\"\n  artifactMetadata: ArtifactMetadata!\n  \"Domain-specific artifact metadata version identifier\"\n  artifactMetadataVersionId: String!\n  \"List of SBOMs associated with this artifact metadata version\"\n  artifactSBOM(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,filter: QueryFilter, \n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10\n  ): ArtifactSBOMConnection!\n  \"Timestamp at which this version is created. Expressed in UTC ISO-8601 format\"\n  creationTime: DateTime!\n  \"external version identifier, this may represent a RepositoryVersion or a CatalogItem identifier\"\n  externalVersionId: String!\n  \"Global opaque identifier to meet Node contract\"\n  id: ID!\n}\ninterface ArtifactMetadataVersionConnection implements Connection {\n  \"List of ArtifactMetadataVersion's\"\n  artifactMetadataVersions: [ArtifactMetadataVersion!]\n  \"Count of elements in the current page\"\n  count: Int!\n  \"Edges to nodes available through the connection\"\n  edges: [ArtifactMetadataVersionEdge!]\n  \"Paging support\"\n  pageInfo: PageInfo!\n  \"Optional total elements count across all pages when available\"\n  totalCount: Int\n}\ninterface ArtifactMetadataVersionEdge implements ConnectionEdge {\n  \"Optional cursor to refer to this node\"\n  cursor: String\n  \"Node element available through this edge\"\n  node: ArtifactMetadataVersion!\n}\n\"Represents a software bundle or unit. This is a hierarchical structure where one package may have other packages as dependencies.\"\ninterface ArtifactSBOM implements Node {\n  \"\"\"\n  Domain-specific artifact sbom identifier\n  unique identifier for a package, may be hash value or checksum generated from the package's content\n  \"\"\"\n  artifactSBOMId: String!\n  \"Connection packages used by this Package (transitive dependecies)\"\n  dependencies(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Input filters to filter Package Dependencies\"\n    filter: QueryFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10\n  ): ArtifactSBOMConnection!\n  \"Global opaque identifier to meet Node contract\"\n  id: ID!\n  \"\"\"\n  license is determined by the SPDX document creator (which is often an SBOM tool or the document creator in the case of disjunctive licenses)\n  refer : https://fossa.com/blog/understanding-using-spdx-license-identifiers-license-expressions\n  \"\"\"\n  licenseConcluded: String\n  \"\"\"\n  license is stated by the component (e.g. package or file) author\n  refer : https://fossa.com/blog/understanding-using-spdx-license-identifiers-license-expressions\n  \"\"\"\n  licenseDeclared: String\n  \"Name of the package\"\n  name: String!\n  \"\"\"\n  Package URL - standardized format for representing package metadata.\n  Eg. pkg:rpm/fedora/curl@7.50.3-1.fc25?arch=i386&distro=fedora-25 , pkg:pypi/django@1.11.1\n  Refer : https://github.com/package-url/purl-spec , https://github.com/package-url/purl-spec/blob/master/PURL-SPECIFICATION.rst\n  \"\"\"\n  packageUrl: String\n  \"Version of the package\"\n  version: String\n  \"\"\"\n  Connection of potential vulnerabilities detected for a Package.\n  The vulnerabilities will be aggregated from dependent packages to this package\n  \"\"\"\n  vulnerabilities(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Input filters to filter Vulnerabilities\"\n    filter: QueryFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10\n  ): ArtifactVulnerabilityConnection\n}\ninterface ArtifactSBOMConnection implements Connection {\n  \"List artifact SBOM(s).\"\n  artifactSBOMs: [ArtifactSBOM!]\n  \"Count of elements in the current page\"\n  count: Int!\n  \"Edges to nodes available through the connection\"\n  edges: [ArtifactSBOMEdge!]\n  \"Paging support\"\n  pageInfo: PageInfo!\n  \"Optional total elements count across all pages when available\"\n  totalCount: Int\n}\ninterface ArtifactSBOMEdge implements ConnectionEdge {\n  \"Optional cursor to refer to this node\"\n  cursor: String\n  \"Node element available through this edge\"\n  node: ArtifactSBOM!\n}\n\"Represents a software vulnerability that can potentially be exploited\"\ninterface ArtifactVulnerability implements Node {\n  \"Details of Packages affected by this vulnerability\"\n  affectedPackages: [ArtifactVulnerabilityDetectionInfo!]\n  \"Domain-specific artifact vulnerability instance identifier - CVE_ID\"\n  artifactVulnerabilityId: String!\n  \"CVE Numbering Authority\"\n  cna: String\n  \"CVE description\"\n  description: String!\n  \"Global opaque identifier to meet Node contract\"\n  id: ID!\n  \"CVE name\"\n  name: String!\n  \"\"\"\n  Date on which vulnerability is published, e.g. Expressed in UTC ISO-8601 format \"2022-11-22T02:15:00Z\"\n  \"\"\"\n  publishedDate: DateTime!\n  \"CVSS score\"\n  scores: [ArtifactVulnerabilityScore!]\n  \"Threat level of vulnerability\"\n  severity: String\n  \"\"\"\n  Optional Date on which the vulnerability was reassessed/updated, e.g. Expressed in UTC ISO-8601 format \"2022-11-22T02:15:00Z\"\n  \"\"\"\n  updatedDate: DateTime\n}\ninterface ArtifactVulnerabilityConnection implements Connection {\n  \"List of vulnerabilities assocaited with this Artifact\"\n  artifactVulnerabilities: [ArtifactVulnerability!]\n  \"Count of elements in the current page\"\n  count: Int!\n  \"Edges to nodes available through the connection\"\n  edges: [ArtifactVulnerabilityEdge!]\n  \"Paging support\"\n  pageInfo: PageInfo!\n  \"Optional total elements count across all pages when available\"\n  totalCount: Int\n}\n\"Relationship between a vulnerability and its detected package\"\ninterface ArtifactVulnerabilityDetectionInfo {\n  \"Version of package where the issue is fixed\"\n  fixVersion: [String!]\n  \"Package on which the vulnerability is detected\"\n  package: ArtifactSBOM!\n  \"Fixed , affected, will_not_fix or any other status \"\n  status: String\n}\ninterface ArtifactVulnerabilityEdge implements ConnectionEdge {\n  \"Optional cursor to refer to this node\"\n  cursor: String\n  \"Node element available through this edge\"\n  node: ArtifactVulnerability!\n}\ninterface CapacityAZConfig implements Node {\n  \"Unique identifier of the AZ Config.\"\n  id: ID!\n}\n\"\"\"\nRepresents a generic action that can be taken as part of a capacity recommendation.\nImplemented by:\n- `CapacityExpandAction`\n- `CapacityOptimizeAction`\n- `CapacityBalanceAction`\n\"\"\"\ninterface CapacityAction {\n  \"Unique identifier for the action.\"\n  id: ID!\n}\n\"\"\"\nRepresents a capacity IAAS Info for a specific entity.\nImplemented by:\n- `CapacityVcenterInfo`\n\"\"\"\ninterface CapacityIAASInfo implements Node {\n  \"AZ Configuration information of the Entity.\"\n  azConfig: [CapacityAZConfig!]!\n  \"The target entity for which the capacity IAAS Info is associated to.\"\n  entity: Entity!\n  \"The unique identifier of the info.\"\n  id: ID!\n}\n\"\"\"\nRepresents a capacity recommendation for a specific entity.\nIncludes the entity being analyzed and optional recommendation config.\nImplemented by:\n- `CapacityDiegoRecommendation`\n\"\"\"\ninterface CapacityRecommendation implements Node {\n  \"The target entity for which the capacity recommendation applies.\"\n  entity: Entity!\n  \"The unique identifier of the recommendation.\"\n  id: ID!\n}\n\"\"\"\nInterface representing resource grouping information used in capacity balancing.\nImplemented by:\n- `CapacityFoundationGroupResourceInfo`\n- `CapacityDeploymentResourceInfo`\n- `CapacityLabelsResourceInfo`\n\"\"\"\ninterface CapacityResourceInfo {\n  \"List of associated entities relevant to the resource group.\"\n  resourceEntities: [Entity!]\n}\n\"Instances of aggregation for a given field\"\ninterface CommonAggregationItem {\n  count: Long!\n  subAggregations: [CommonAggregationItems!]\n  value: String!\n}\n\"Aggregations for a given field\"\ninterface CommonAggregationItems {\n  \"Number of distinct buckets\"\n  bucketCount: Long!\n  buckets: [CommonAggregationItem!]\n  \"Field key for which values are being aggregated.\"\n  field: String!\n}\n\"Interface defining common aggregation API pattern\"\ninterface CommonAggregations {\n  aggregations: [CommonAggregationItems!]\n  totalCount: Long!\n}\n\"\"\"\nRelay-compatible Connection interface.  Please see: [GraphQL Cursor Connections Specification](https://relay.dev/graphql/connections.htm)\n\nVery often the implementing type will extend this to include a type-specific field providing direct access to a list of elements of the implementing node type.\n\"\"\"\ninterface Connection {\n  \"Count of elements in the current page\"\n  count: Int!\n  \"Edges to nodes available through the connection\"\n  edges: [ConnectionEdge!]\n  \"Paging support\"\n  pageInfo: PageInfo!\n  \"Optional total elements count across all pages when available\"\n  totalCount: Int\n}\n\"Relay-compatible Edge interface.  Please see: [GraphQL Cursor Connections Specification](https://relay.dev/graphql/connections.htm)\"\ninterface ConnectionEdge {\n  \"Optional cursor to refer to this node\"\n  cursor: String\n  \"Node element available through this edge\"\n  node: Node!\n}\n\"Core interface of an Entity instance with its tags, properties and namespaces, without any fields to access other entities or types\"\ninterface EntityNodeInterface implements Node& NodeVersion {\n  \"\"\"\n  The cloud account ID. This is a synonym for the `managementEndpointId` field\n  of the `managementEndpoint` of this entity, exposed for quick filtering for public cloud accounts.\n  \"\"\"\n  cloudAccountId: String\n  \"This optional property represents an unique ID of the source collector\"\n  collectionSource: String\n  \"Time this Entity was created. Note: Expressed in UTC ISO-8601 timestamp\"\n  creationTime: DateTime\n  \"Unique identifier for an entity in a canonical form. Uniqueness applies at the scope of the entire organization\"\n  entityId: EntityId!\n  \"Optional. EntityName of the entity\"\n  entityName: String\n  \"EntityType of the entity. e.g. `ec2`, `security-group` etc. Required but not enforced because of federation constraints.\"\n  entityType: String\n  \"entityType as an enum constant\"\n  entityTypeConst: EntityTypeConst\n  \"Opaque global ID\"\n  id: ID!\n  \"Last time this entity was updated. Note: Expressed in UTC ISO-8601 timestamp\"\n  lastUpdateTime: DateTime\n  \"namespaces for this entity, filtered by namespace\"\n  namespaces(namespace: [String!]): [EntityNamespace!]\n  \"Versioning ID\"\n  nodeVersion: ID!\n  \"Properties for this entity, optionally filtered by name\"\n  properties(name: [String!]): [EntityProperty!]\n  \"provider component of the entityType\"\n  provider: String\n  \"For cloud resources, this property contains the entity region\"\n  region: String\n  \"service component of the entityType\"\n  service: String\n  \"Key/Value entityTags for this entity, optionally filtered by key\"\n  tags(key: [String!]): [Tag!]\n}\n\"\"\"\nEntityTraversalInput is defined in commons_entity\nEntityTraversalDirection is defined in commons_entity\n\"\"\"\ninterface EntityRelationshipNodeInterface implements Node& NodeVersion {\n  \"Time this Relationship was created. Note: Expressed in UTC ISO-8601 format\"\n  creationTime: DateTime!\n  \"dest entityId\"\n  destEntityId: EntityId\n  \"dest entity provider if available\"\n  destEntityProvider: String\n  \"dest entityType if available\"\n  destEntityType: String\n  \"dest entityType projected as an enum value, if available\"\n  destEntityTypeConst: EntityTypeConst\n  \"Opaque global ID\"\n  id: ID!\n  \"Last time this Relationship was updated. Note: Expressed in UTC ISO-8601 format\"\n  lastUpdateTime: DateTime!\n  \"Versioning ID\"\n  nodeVersion: ID!\n  properties: [EntityProperty!]\n  \"entity relationship id\"\n  relationshipId: String!\n  \"Type of the relationship. e.g. RelatesTo etc\"\n  relationshipType: String!\n  \"source entityId\"\n  sourceEntityId: EntityId\n  \"source entity provider if available\"\n  sourceEntityProvider: String\n  \"source entityType if available\"\n  sourceEntityType: String\n  \"source entityType projected as an enum value, if available\"\n  sourceEntityTypeConst: EntityTypeConst\n  \"Scope of relationship's traversal\"\n  traversalScope: EntityTraversalScope\n}\ninterface EntityTopologyProviderInterface {\n  \"Information about this provider\"\n  providerInfo: [EntityTopologyPerspectives!]\n  \"Entity topology query interface that must be implemented by a provider\"\n  queryEntityTopology(\n    \"\"\"\n    An optional field which specifies the topology that has been computed so far.\n    This field can be used in order to make subsequent calls to the API faster,\n    so that the providers don't have to re-compute all the information from scratch.\n    \"\"\"\n    currentTopology: EntityTopologyGraphInput,\n    \"Query parameters\"\n    entityTopologyInput: EntityTopologyInput!\n  ): EntityTopologyGraph\n}\ninterface EntityTypedInterface implements Node& NodeVersion {\n  \"reference to the generic Entity representation of this entity\"\n  entity: Entity!\n  \"Globally unique identifier for an entity in a canonical form.\"\n  entityId: EntityId!\n  \"User-friendly name of the Entity\"\n  entityName: String\n  \"Entity Type as <provider>.<service>.<type>\"\n  entityType: String\n  \"Opaque global node ID\"\n  id: ID!\n  \"Opaque version string for this graph node instance\"\n  nodeVersion: ID!\n  \"Key/Value tags for this entity, optionally filtered by key\"\n  tags(key: [String!]): [Tag!]\n}\n\"Hub policy\"\ninterface HubPolicy implements Node& NodeVersion {\n  \"CSP user who created hub policy\"\n  createdBy: User!\n  \"Timestamp at which hub policy is created. Expressed in UTC ISO-8601 format\"\n  creationTime: DateTime!\n  \"Policy description\"\n  description: LocalizedString\n  \"\"\"\n  If the policy is enabled or not\n  If disabled, timer based policy evaluation will stop. But user will still be able to evaluate the policy using API.\n  \"\"\"\n  enabled: Boolean!\n  \"Opaque global ID\"\n  id: ID!\n  \"Timestamp at which hub policy is updated. Expressed in UTC ISO-8601 format\"\n  lastUpdateTime: DateTime\n  \"Versioning ID\"\n  nodeVersion: ID!\n  \"Policy id\"\n  policyId: String!\n  \"Policy name\"\n  policyName: LocalizedString!\n  \"Policy Providers like Cost, Spring, Aria/Tanzu\"\n  policyProvider: String!\n  \"CSP user who updated hub policy\"\n  updatedBy: User\n}\n\"Policy connection\"\ninterface HubPolicyConnection implements Connection {\n  \"count of polices on this page\"\n  count: Int!\n  \"Hub Policy edge\"\n  edges: [HubPolicyEdge!]\n  \"Represents pagination information in Relay about the edges.\"\n  pageInfo: PageInfo!\n  \"Policies\"\n  policies: [HubPolicy!]\n  \"Total count of polices\"\n  totalCount: Int\n}\n\"Policy edge\"\ninterface HubPolicyEdge implements ConnectionEdge {\n  \"Cursor is an opaque string, you can use it to request subsequent or preceding items in the list\"\n  cursor: String!\n  \"Policy node\"\n  node: HubPolicy!\n}\n\"Mutation aspect/flavor of Hub Policy Provider contract, which compliments the Hub Policy Provider interface.\"\ninterface HubPolicyMutationProvider {\n  \"name of provider\"\n  name: String!\n}\n\"query entrypoint for hub policy provider\"\ninterface HubPolicyQueries {\n  \"Get policy details based on filter criteria\"\n  queryHubPolicies(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Optional filters to filter policies that are fetched\"\n    filter: QueryFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Results are sorted as per fields and order specified. Supported fields are policyName, createdBy and updatedBy\"\n    sort: [QuerySort!]\n  ): HubPolicyConnection\n  \"\"\"\n  Get policy run details.\n  All providers may not have run details and in that case 'Not implemented' exception should be thrown.\n  \"\"\"\n  queryHubPolicyRuns(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Optional filters to filter policy runs that are fetched.\"\n    filter: QueryFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Results are sorted as per fields and order specified. Supported fields are name, status. Default Sort will be on LastUpdateTime\"\n    sort: [QuerySort!]\n  ): HubPolicyRunConnection\n}\ninterface HubPolicyQueriesProvider implements HubPolicyQueries {\n  \"Provider name, expected to be the same as the field name used to access this provider, possibly with case differences\"\n  name: String!\n  \"Information about this provider\"\n  providerInfo: HubPolicyProviderInfo!\n  \"Get policy details based on filter criteria\"\n  queryHubPolicies(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Optional filters to filter policies that are fetched\"\n    filter: QueryFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Results are sorted as per fields and order specified. Supported fields are policyName, createdBy and updatedBy\"\n    sort: [QuerySort!]\n  ): HubPolicyConnection\n  \"Get policy run details\"\n  queryHubPolicyRuns(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"Optional filters to filter policy runs that are fetched.\"\n    filter: QueryFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Results are sorted as per fields and order specified. Supported fields are name, status. Default Sort will be on LastUpdateTime\"\n    sort: [QuerySort!]\n  ): HubPolicyRunConnection\n}\n\"Policy run created after policy evaluation\"\ninterface HubPolicyRun implements Node {\n  \"Timestamp at which hub policy is executed. Expressed in UTC ISO-8601 format\"\n  creationTime: DateTime!\n  \"Opaque global ID\"\n  id: ID!\n  \"Associated policy\"\n  policy: HubPolicy!\n  \"Policy run status\"\n  status: HubPolicyRunStatus\n}\n\"Policy run details- Connection object\"\ninterface HubPolicyRunConnection implements Connection {\n  \"count of policy runs on this page\"\n  count: Int!\n  \"Hub Policy run edge\"\n  edges: [HubPolicyRunEdge!]\n  \"Represents pagination information in Relay about the edges.\"\n  pageInfo: PageInfo!\n  \"policy runs\"\n  policyRuns: [HubPolicyRun!]\n  \"Total count of policy runs\"\n  totalCount: Int\n}\n\"Policy run details\"\ninterface HubPolicyRunEdge implements ConnectionEdge {\n  \"Cursor is an opaque string, you can use it to request subsequent or preceding items in the list\"\n  cursor: String!\n  \"Policy node\"\n  node: HubPolicyRun!\n}\n\"\"\"\nTop level interface to be implemented by all GraphQL types\nthat support providing navigation hyperlinks within the response.\n\"\"\"\ninterface HyperLinked {\n  hyperlinks: [HyperLink!]\n}\n\"Base Interface for insight rules\"\ninterface InsightRule implements Node {\n  \"Status of the Rule\"\n  active: Boolean!\n  \"The user who created the Rule\"\n  createdBy: User!\n  \"Time at which the Rule was created in UTC ISO-8601 format\"\n  creationTime: DateTime!\n  \"Description of the Rule\"\n  description: LocalizedString!\n  \"opaque unique id of a rule\"\n  id: ID!\n  \"Time at which the Rule was last updated in UTC ISO-8601 format\"\n  lastUpdateTime: DateTime\n  \"The user who last updated the Rule\"\n  lastUpdatedBy: User\n  \"Name of the rule\"\n  name: LocalizedString!\n}\n\"\"\"\nRelay-compatible interface implemented by all graph nodes that are expected to be cached / re-fetched by their globally unique ID\nNon-volatile graph nodes are expected to implement the Node interface.\nNote that not all types implement the Node interface - types such as Connections and Edges,\nand volatile query response types are typically not expected to be cached on the client side and thus do not implement\nthe Node interface.\n\nPlease see: [Global Object Identification](https://graphql.org/learn/global-object-identification)\n\"\"\"\ninterface Node {\n  \"Opaque global node ID\"\n  id: ID!\n}\n\"\"\"\nAn interface indicating that the given type is versioned, and providing an opaque version identifier.\n\nOptimistic locking on mutations on the given type can be performed by providing the `nodeVersion` field in the input type.\n\nIf the `nodeVersion` field passed in the mutation input does not match the current node's `nodeVersion` field then the\nmutation should be rejected, since there has been a version change on the server since the last time that the\nmutation client read the node.\n\nNote that implementing `NodeVersion` does not require the `Node` interface to be implemented.\n\"\"\"\ninterface NodeVersion {\n  \"Opaque version string for this graph node instance\"\n  nodeVersion: ID!\n}\ninterface NotificationRule implements Node& NodeVersion {\n  \"User who created the notification rule\"\n  createdBy: User\n  \"Creation time of the notification rule\"\n  creationTime: DateTime!\n  \"List of email addresses the notifications of this rule needs to be delivered to. Should be provided when notification target type is EMAIL\"\n  emailAddresses: [String!]\n  \"Enabled turns the notification rule on/off\"\n  enabled: Boolean!\n  \"Opaque global ID\"\n  id: ID!\n  \"Last update time of the notification rule\"\n  lastUpdateTime: DateTime!\n  \"Name of the notification rule\"\n  name: String!\n  \"Versioning ID\"\n  nodeVersion: ID!\n  \"ID of the notification rule\"\n  notificationRuleId: String!\n  \"List of notification targets that this notification needs to be delivered\"\n  notificationTargets: [NotificationTarget!]\n  \"Provider name of the notification rule\"\n  provider: String!\n}\ninterface NotificationRuleConnection implements Connection {\n  \"Count of elements in the current page\"\n  count: Int!\n  \"Edges to nodes available through the connection\"\n  edges: [NotificationRuleConnectionEdge!]\n  \"List of notificationRules in this page\"\n  notificationRules: [NotificationRule!]\n  \"Paging support\"\n  pageInfo: PageInfo!\n  \"Optional total elements count across all pages when available\"\n  totalCount: Int\n}\ninterface NotificationRuleConnectionEdge implements ConnectionEdge {\n  \"Optional cursor to refer to this node\"\n  cursor: String\n  \"Node element available through this edge\"\n  node: NotificationRule!\n}\n\"This is just a marker interface as we would not have common mutations across providers\"\ninterface NotificationRulesMutationProvider {\n  name: String\n}\n\"Interface that all notification rules providers must implement\"\ninterface NotificationRulesProvider {\n  \"Information about this provider\"\n  providerInfo: NotificationRulesProviderInfo!\n  \"Notification rules query interface that must be implemented by a provider\"\n  queryNotificationRules(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Input query filter to help filtering output of the query\"\n    filter: QueryFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Sort order for results in the connection\"\n    sort: [QuerySort!]\n  ): NotificationRuleConnection\n}\ninterface NotificationTarget implements Node& NodeVersion {\n  \"The time this notification target was created\"\n  creationTime: DateTime!\n  \"Name of this notification target\"\n  displayName: String!\n  \"Enabled turns the notification target on/off\"\n  enabled: Boolean!\n  \"Node-compatible opaque global identifier\"\n  id: ID!\n  \"The last time this notification target was successfully updated\"\n  lastUpdateTime: DateTime!\n  \"Opaque version string for this graph node instance\"\n  nodeVersion: ID!\n  notificationTargetId: String!\n  \"Name for this notification target provider.\"\n  providerName: String!\n  \"Scoping entities that are included\"\n  scopingEntities: [Entity!]\n  \"Status holds details about the healthiness of the notification target\"\n  status: NotificationTargetStatus!\n  \"Notification target type\"\n  type: NotificationTargetType!\n}\ninterface NotificationTargetConnection implements Connection {\n  \"Count of notification targets in current page\"\n  count: Int!\n  \"Relay-compatible connection edge\"\n  edges: [NotificationTargetEdge!]\n  \"List of notification targets in current page\"\n  notificationTargets: [NotificationTarget!]\n  \"Relay-compatible paging information\"\n  pageInfo: PageInfo!\n  \"Total count of notification targets\"\n  totalCount: Int\n}\ninterface NotificationTargetEdge implements ConnectionEdge {\n  cursor: String!\n  node: NotificationTarget!\n}\n\"Describes a notification target type\"\ninterface NotificationTargetType implements Node {\n  \"Node-compatible opaque global identifier\"\n  id: ID!\n  \"\"\"\n  RequiresAddress shows whether notification targets of this type need an address to be passed in order to work.\n  Examples of address are email address, Slack channel, etc.\n  \"\"\"\n  requiresAddress: Boolean!\n  \"Notification target type\"\n  type: String!\n}\ninterface NotificationTargetTypeConnection implements Connection {\n  \"Count of notification target types in current page\"\n  count: Int!\n  \"Relay-compatible connection edge\"\n  edges: [NotificationTargetTypeEdge!]\n  \"List of notification target types in current page\"\n  notificationTargetTypes: [NotificationTargetType!]\n  \"Relay-compatible paging information\"\n  pageInfo: PageInfo!\n  \"Total count of notification target types\"\n  totalCount: Int\n}\ninterface NotificationTargetTypeEdge implements ConnectionEdge {\n  cursor: String!\n  node: NotificationTargetType!\n}\n\"interface to implement by Notification Target providers and stitch with NotificationTargetsMutation\"\ninterface NotificationTargetsMutationProvider {\n  \"Name of the provider\"\n  name: String\n}\ninterface NotificationTargetsProvider {\n  \"Information about this provider\"\n  providerInfo: NotificationTargetsProviderInfo!\n  queryNotificationTargetTypes(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Input query filter to help filtering output of the query\"\n    filter: QueryFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10\n  ): NotificationTargetTypeConnection\n  queryNotificationTargets(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Input query filter to help filtering output of the query\"\n    filter: QueryFilter,\n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Sort order for results in the connection\"\n    sort: [QuerySort!]\n  ): NotificationTargetConnection\n}\n\"Observability Alert to trigger Alerts on metrics/logs\"\ninterface ObservabilityAlert implements HubPolicy& Node& NodeVersion {\n  \"Alert evaluation status\"\n  alertStatus: ObservabilityAlertStatus!\n  \"Type of the Observability Alert\"\n  alertType: ObservabilityAlertType!\n  \"CSP user who created hub policy\"\n  createdBy: User!\n  \"Timestamp at which hub policy is created. Expressed in UTC ISO-8601 format\"\n  creationTime: DateTime!\n  \"CSP project id associated with policy\"\n  cspProjects: [Entity!] @deprecated(reason: \"No longer supported\")\n  \"Dashboard ID of the observability alert custom runbook\"\n  dashboardId: String\n  \"Policy description\"\n  description: LocalizedString\n  \"schedule is enabled for this policy\"\n  enabled: Boolean!\n  \"ID of entity on which observability alert is triggered\"\n  entityId: String @deprecated(reason: \"Use `entityInfo` instead\")\n  \"Entity from which the observation alert is triggered\"\n  entityInfo: Entity\n  \"Type of entity on which observability alert is triggered\"\n  entityType: String! @deprecated(reason: \"Use `entityInfo` instead\")\n  \"Opaque identifier for a policy, to be used to identify a policy uniquely in hub graph\"\n  id: ID!\n  \"Flag defining if observability alert is custom\"\n  isCustomAlert: Boolean!\n  \"Last evaluation run time\"\n  lastRunTime: DateTime\n  \"Timestamp at which hub policy is updated. Expressed in UTC ISO-8601 format\"\n  lastUpdateTime: DateTime\n  \"Opaque version string for this graph node instance\"\n  nodeVersion: ID!\n  \"Notification Rule\"\n  notificationRule: ObservabilityAlertNotificationRule\n  \"unique policy identifier\"\n  policyId: String!\n  \"Policy name\"\n  policyName: LocalizedString!\n  \"provider name for this policy\"\n  policyProvider: String!\n  \"Template ID of the observability alert runbook\"\n  runbookTemplateId: String\n  \"Source for alerts\"\n  source: String!\n  \"CSP user who updated hub policy\"\n  updatedBy: User\n}\n\" Represents a repository available for a given repository endpoint Eg. cmbu/guardrails-service\"\ninterface Repository implements Node {\n  \"Timestamp at which Assessment is created. Expressed in UTC ISO-8601 format\"\n  creationTime: DateTime!\n  \"Repository endpoint for this repository\"\n  endpoint: RepositoryEndpoint!\n  \"Global opaque identifier to meet Node contract\"\n  id: ID!\n  \"\"\"\n  Name of repository\n  Eg. for https://gitlab.eng.vmware.com/cmbu/guardrails-service , We can have name as guardrails-service\n  \"\"\"\n  name: String!\n  \"\"\"\n  Path of repository\n  Eg. for https://gitlab.eng.vmware.com/cmbu/guardrails-service , path will be cmbu/guardrails-service\n  \"\"\"\n  path: String!\n  \"Domain-specific repository instance identifier\"\n  repositoryId: String!\n  \"repositoryVersions associated with this repository\"\n  repositoryVersions(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,filter: QueryFilter, \n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Sort by one or more attributes, default sort : Sort by creationTime descending\"\n    sort: [QuerySort!]\n  ): RepositoryVersionConnection!\n}\ninterface RepositoryConnection implements Connection {\n  \"Count of elements in the current page\"\n  count: Int!\n  \"Edges to nodes available through the connection\"\n  edges: [RepositoryEdge!]\n  \"Paging support\"\n  pageInfo: PageInfo!\n  \"List of Repository\"\n  repositories: [Repository!]\n  \"Optional total elements count across all pages when available\"\n  totalCount: Int\n}\ninterface RepositoryEdge implements ConnectionEdge {\n  \"Optional cursor to refer to this node\"\n  cursor: String\n  \"Node element available through this edge\"\n  node: Repository!\n}\n\"\"\"\nRepresents an endpoint that can be used access one or more repositories. Eg. gitlab.eng.vmware.com\nExample providers (gitlab, github). Concrete implementation would also add other details like credentials to this as applicable.\n\"\"\"\ninterface RepositoryEndpoint implements Node {\n  \"CSP user who created Assessment\"\n  createdBy: User!\n  \"Timestamp at which Assessment is created. Expressed in UTC ISO-8601 format\"\n  creationTime: DateTime!\n  \"Project scoping for this endpoint\"\n  cspProjectEntity: [Entity!]\n  \"Global opaque identifier to meet Node contract\"\n  id: ID!\n  \"Repository endpoint name\"\n  name: String!\n  \"Repositories associated with this repository endpoint\"\n  queryRepositories(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,filter: QueryFilter, \n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Optionally filter by repository ids\"\n    repositoryId: [String!],\n    \"Optionally filter by repository name, this shall support wildcards\"\n    repositoryName: [String!],\n    \"Sort by one or more attributes, default sort : Sort by creationTime descending\"\n    sort: [QuerySort!]\n  ): RepositoryConnection!\n  \"Domain-specific repository endpoint instance identifier\"\n  repositoryEndpointId: String!\n  \"Repository endpoint url\"\n  repositoryEndpointUrl: String!\n}\ninterface RepositoryEndpointConnection implements Connection {\n  \"Count of elements in the current page\"\n  count: Int!\n  \"Edges to nodes available through the connection\"\n  edges: [RepositoryEndpointEdge!]\n  \"Paging support\"\n  pageInfo: PageInfo!\n  \"List of RepositoryEndpoint\"\n  repositoryEndpoints: [RepositoryEndpoint!]\n  \"Optional total elements count across all pages when available\"\n  totalCount: Int\n}\ninterface RepositoryEndpointEdge implements ConnectionEdge {\n  \"Optional cursor to refer to this node\"\n  cursor: String\n  \"Node element available through this edge\"\n  node: RepositoryEndpoint!\n}\n\"query entrypoint for Repository provider\"\ninterface RepositoryQueries {\n  \"Query available repository endpoints\"\n  queryRepositoryEndpoints(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"filter by project ids\"\n    cspProjectEntityId: [EntityId!],filter: QueryFilter, \n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Optionally filter by repositoryEndpointId\"\n    repositoryEndpointId: [String!],\n    \"Optionally filter by name, this shall support wildcards\"\n    repositoryEndpointName: [String!],\n    \"Optionally filter by repositoryEndpointUrl\"\n    repositoryEndpointUrl: [String!],\n    \"Sort by one or more attributes, default sort : Sort by creationTime descending\"\n    sort: [QuerySort!]\n  ): RepositoryEndpointConnection!\n}\ninterface RepositoryQueryProvider implements RepositoryQueries {\n  \"Provider name, expected to be the same as the field name used to access this provider, possibly with case differences\"\n  name: String!\n  \"Information about this provider\"\n  providerInfo: RepositoryProviderInfo!\n  \"Query available repository endpoints\"\n  queryRepositoryEndpoints(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,\n    \"filter by project ids\"\n    cspProjectEntityId: [EntityId!],filter: QueryFilter, \n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10,\n    \"Optionally filter by repositoryEndpointId\"\n    repositoryEndpointId: [String!],\n    \"Optionally filter by name, this shall support wildcards\"\n    repositoryEndpointName: [String!],\n    \"Optionally filter by repositoryEndpointUrl\"\n    repositoryEndpointUrl: [String!],\n    \"Sort by one or more attributes, default sort : Sort by creationTime descending\"\n    sort: [QuerySort!]\n  ): RepositoryEndpointConnection!\n}\n\"Represents commit information for a repository. For a git repository this would be commit id\"\ninterface RepositoryVersion implements Node {\n  \"Timestamp at which this version is created. Expressed in UTC ISO-8601 format\"\n  creationTime: DateTime!\n  \"Global opaque identifier to meet Node contract\"\n  id: ID!\n  \"Optional Entities with which this RepositoryVersion is associated\"\n  relatedEntities(\n    \"Return records after the given cursor, as per GraphQL Relay spec\"\n    after: String,\n    \"Return records before the given cursor, as per GraphQL Relay spec\"\n    before: String,filter: QueryFilter, \n    \"Return first N records in a paged response, as per GraphQL Relay spec\"\n    first: Int = 10\n  ): EntityConnection!\n  \"Repository that has this version\"\n  repository: Repository!\n  \"\"\"\n  Domain-specific repository version identifier.\n  For git this will be commit id\n  \"\"\"\n  repositoryVersionId: String!\n}\ninterface RepositoryVersionConnection implements Connection {\n  \"Count of elements in the current page\"\n  count: Int!\n  \"Edges to nodes available through the connection\"\n  edges: [RepositoryVersionEdge!]\n  \"Paging support\"\n  pageInfo: PageInfo!\n  \"List of RepositoryVersion\"\n  repositoryVersions: [RepositoryVersion!]\n  \"Optional total elements count across all pages when available\"\n  totalCount: Int\n}\ninterface RepositoryVersionEdge implements ConnectionEdge {\n  \"Optional cursor to refer to this node\"\n  cursor: String\n  \"Node element available through this edge\"\n  node: RepositoryVersion!\n}\n\"Interface that all stats providers must implement\"\ninterface StatsProviderInterface {\n  \"Information about this provider\"\n  providerInfo: StatsProviderInfo!\n  \"Stats query interface that must be implemented by a provider\"\n  queryStats(\n    \"\"\"\n    Optional list of entityIds to query for stats.\n    If no entityIds are specified, the stats are queried based on the input\n    Note that entity stats queries with the registered namesapce will be redirected to this query interface\n    via the EntityStatsDataLoader and so will submit batches of queries typically with 1000 entityIds in each batch\n    and if with a list of EntityIds in each batch, it's the responsibility of the implementor to subdivide\n    if a smaller batch size is required (e.g. vRNI requires individual stats queries).\n    \"\"\"\n    entityId: [EntityId!],\n    \"Query parameters\"\n    input: StatsInput\n  ): [Stats!]\n}\nenum ArtifactAssessmentAggregationField {\n  VULNERABILITY_SEVERITY\n  UPGRADE_EFFORT\n  OSS_SUPPORT\n  TSR_SUPPORT\n  NO_SUPPORT\n  SPRING_ENTERPRISE\n}\nenum ArtifactAssessmentAggregationIntervalDuration {\n  MONTH\n}\nenum ArtifactAssessmentAggregationType {\n  TERMS\n  DATE_HISTOGRAM\n}\nenum ArtifactEntityCategory {\n  APPLICATION\n  COMPONENT\n}\nenum ArtifactSbomContentType {\n  \"sbom content is of json format\"\n  JSON\n  \"collection of sboms for a component\"\n  ZIP\n}\n\"Bucket ordering options for aggregation results\"\nenum ArtifactVulnerabilityBucketOrder {\n  \"Alphabetical order (A-Z)\"\n  ALPHABETICAL\n  \"Order by count descending\"\n  COUNT_DESC\n  \"Order by count ascending\"\n  COUNT_ASC\n  \"Predefined order for the field (only works for entityType and severity)\"\n  PREDEFINED\n}\n\"Types of aggregation supported\"\nenum ArtifactVulnerabilityEntityAggregationType {\n  \"Only terms aggregation\"\n  TERMS\n}\nenum ArtifactVulnerabilityLatestPatchVersionStatus {\n  FIX_AVAILABLE\n  FIX_ON_NEXT_RELEASE\n  CODE_NOT_PRESENT\n  CODE_NOT_REACHABLE\n  REQUIRES_CONFIGURATION\n  REQUIRES_DEPENDENCY\n  REQUIRES_ENVIRONMENT\n  PROTECTED_BY_COMPILER\n  PROTECTED_AT_RUNTIME\n  PROTECTED_AT_PERIMETER\n  PROTECTED_BY_MITIGATING_CONTROL\n  CAN_NOT_FIX\n  WILL_NOT_FIX\n  NO_FIX_YET\n  UNKNOWN\n}\nenum ArtifactVulnerabilityOvertimePrecision {\n  DAILY\n}\n\"CVSS version\"\nenum ArtifactVulnerabilityScoreType {\n  \"CVSS Version 3, refer: https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator\"\n  CVSS_V3\n  \"CVSS Version 2, refer: https://nvd.nist.gov/vuln-metrics/cvss/v2-calculator\"\n  CVSS_V2\n}\n\"Represents Vulnerability Severity of artifact\"\nenum ArtifactVulnerabilitySeverity {\n  CRITICAL\n  HIGH\n  MODERATE\n  LOW\n  NONE\n}\nenum ArtifactVulnerabilityTriageStatus {\n  RESOLVED\n  RESOLVED_WITH_PEDIGREE\n  EXPLOITABLE\n  IN_TRIAGE\n  FALSE_POSITIVE\n  NOT_AFFECTED\n}\n\"Event type enum for system events\"\nenum AssessmentEventName {\n  \"TVS data collection event\"\n  TVS_DATA_TASK\n  \"SBOM processing event\"\n  COMPONENT_MAPPING\n  \"Vulnerability data collection from TVS\"\n  VULNERABILITY_DATA_COLLECTION\n  \"Value returned for other event names\"\n  UNSUPPORTED\n}\n\"Event status enum\"\nenum AssessmentEventStatus {\n  \"Event completed successfully\"\n  SUCCESS\n  \"Event failed\"\n  FAILURE\n}\nenum AssessmentRuleMatchType {\n  REGEX\n  XPATH\n  YAMLPATH\n  SIMPLE_TEXT\n  SIMPLE_TEXT_CI\n  STARTS_WITH\n  STARTS_WITH_CI\n  ENDS_WITH\n  ENDS_WITH_CI\n  CONTAINS\n  CONTAINS_CI\n}\nenum AssessmentRuleResponseErrorType {\n  MAX_RULES_IN_ASSESSMENT_EXCEEDED\n  MAX_ASSESSMENT_RULES_IN_SINGLE_REQUEST\n  INVALID_REPOSITORY\n  INVALID_REPOSITORY_GROUP\n  VALIDATION_ERROR\n  UNKNOWN\n}\nenum AssessmentRuleSourceType {\n  SYSTEM_PROVIDED\n  USER_PROVIDED\n}\nenum AssessmentRuleTargetType {\n  FILE\n  LINE\n  CONTENTS\n}\nenum AssessmentRuleType {\n  STANDARD\n  FIRE_ONCE_PER_APPLICATION\n  FIRE_ONCE_PER_FILE\n}\n\"Enum describing rbac scope types that can be assigned to roles\"\nenum AuthRbacAssignableScopeType {\n  \"Represents global visibility\"\n  GLOBAL\n  \"Represents all foundation groups that user has visibility to\"\n  FOUNDATION_GROUP\n  \"Represents all cloud foundry organization that user has visibility to\"\n  ORGANIZATION_GROUP\n  \"Represents all cloud foundry space group that user has visibility to\"\n  SPACE_GROUP\n  \"Represents all portfolio repository groups that user has visibility to\"\n  PORTFOLIO_REPOSITORY_GROUP\n}\n\"Enum indicating the provider of the role binding.\"\nenum AuthRoleBindingProviderEnum {\n  \"Indicates the role binding is synced from CloudFoundry.\"\n  TP4CF\n  \"Indicates the role binding is created by users in Tanzu Platform.\"\n  PLATFORM\n}\nenum AuthRoleBindingScopeType {\n  GLOBAL\n  PROJECT_HIERARCHY\n  MANAGEMENT_ENDPOINT\n  FOUNDATION_GROUP\n  CLOUD_FOUNDRY_FOUNDATION\n  CLOUD_FOUNDRY_ORGANIZATION\n  ORGANIZATION_GROUP\n  CLOUD_FOUNDRY_SPACE\n  SPACE_GROUP\n  PORTFOLIO_REPOSITORY_GROUP\n}\nenum AuthRoleBindingStatusEnum {\n  SUCCESS\n  ERROR\n}\n\"Enum describing the subject types on which role bindings can be created\"\nenum AuthRoleBindingSubjectType {\n  \"Represents an User\"\n  USER\n  \"Represents an User group\"\n  GROUP\n  \"\"\"\n  Represents an OAuth App\n  \n  **NOTE:** This API/functionality is in Beta, this functionality is a candidate for a stable API but we reserve the right to fix issues including modifying the schema if required.\n  \"\"\"\n  OAUTH_APP\n}\nenum BusinessAppUpsertResponseErrorType {\n  MAX_SPACES_IN_BA_EXCEEDED\n  MAX_NUMBER_MEMBERS_EXCEEDED\n  MAX_MEMBERS_IN_SPACE_EXCEEDED\n  MALFORMED_ENTITY\n  MAX_BA_IN_SINGLE_REQUEST\n}\nenum CapacityActionType {\n  EXPAND\n  OPTIMIZE\n  BALANCE\n}\nenum CapacityAggregationScope {\n  APPLICATION\n  SPACE\n  ORGANIZATION\n  FOUNDATION\n}\nenum CapacityAggregationType {\n  SUM\n  COUNT\n}\nenum CapacityClassification {\n  UNDERUTILIZED\n  OVERUTILIZED\n  NORMAL\n}\nenum CapacityDimension {\n  MEMORY\n  STORAGE\n  CPU\n  ALL\n}\nenum CapacityDimensionUnit {\n  PERCENTAGE\n  GB\n  COUNT\n}\nenum CapacityQueryScope {\n  APPLICATION\n  DIEGO\n  ISOLATION_SEGMENT\n}\n\"Available task types for TVS operations\"\nenum ComponentTaskType {\n  \"Execute Pgloader task to load TVS data into PostgreSQL\"\n  LOAD_TVS_DATA\n  \"Execute Component Mapping task to fetch and map components\"\n  COMPONENT_MAPPING\n}\n\"Severity enum for component vulnerabilities\"\nenum ComponentVulnerabilitySeverity {\n  HIGH\n  CRITICAL\n}\n\"\"\"\nDefines the timeline for fetching conversational history session, prompts, streams and events:\n\nALL: It is by default which fetches all the available data\nLAST_N : It fetches N latest sessions, prompts, streams or events\nBY_ID: It allows to fetch the sessions or prompts by unique ids (list of sessionId and promptId). Not available on Stream and Event\n\"\"\"\nenum ConversationalFilterType {\n  ALL\n  LAST_N\n  BY_ID\n}\nenum ConversationalPromptStatus {\n  ACTIVE\n  INTERRUPTED\n}\n\"Default configuration of the dashboard. This can either be either USER_DEFAULT, ORG_DEFAULT, or SCOPED_DEFAULT\"\nenum DashboardDefaultType {\n  \"Dashboard is default dashboard for the user\"\n  USER_DEFAULT\n  \"Dashboard is default dashboard for the organization\"\n  ORG_DEFAULT\n}\nenum DashboardScopeType {\n  FOUNDATION_GROUP\n  CLOUD_FOUNDRY_FOUNDATION\n  ORGANIZATION_GROUP\n  CLOUD_FOUNDRY_ORGANIZATION\n  SPACE_GROUP\n  CLOUD_FOUNDRY_SPACE\n}\n\"Visibility of a dashboard, this can either be USER for dashboards visible to users, ORGANIZATION if a dashboard is visible to all users in an organization, or SCOPED if a dashboard is visible to users with access to specific scope entities\"\nenum DashboardVisibility {\n  \"Dashboard is visible to user who created it\"\n  USER\n  \"dashboard is visible to entire organization\"\n  ORG\n  \"Dashboard is visible to users with access to specific scope entities\"\n  SCOPED\n}\nenum DerivedDataDocType {\n  CSV\n  JSON\n}\nenum DocumentCategory {\n  DERIVED_DATA_EXPORT\n  SOURCE_CODE\n  BUILD_ARTIFACTS\n  CONSUMPTION\n  OPEN_API_SPEC\n  SBOM\n  SECURITY_METADATA\n  SUPPORT_BUNDLE\n  APP_PORTFOLIO_CUSTOM_REPORT\n  APP_PORTFOLIO_REPOSITORY_INPUT\n  APP_PORTFOLIO_ASSESSMENT_EVIDENCE\n  INSTALLER\n  CONFIGURATION\n}\nenum DocumentProcessingState {\n  INITIALIZING\n  UPLOADING\n  UPLOADED\n  UPLOADING_FAILED\n  QUEUED_FOR_PROCESSING\n  PROCESSING\n  PROCESSING_COMPLETE\n  PROCESSING_FAILED\n}\nenum DocumentType {\n  CSV\n  JSON\n  TGZ\n  HTML\n  ZIP\n  PIVOTAL\n  YAML\n  OVF\n  VMDK\n}\nenum EntityAggregationFieldType {\n  INT\n  LONG\n  DOUBLE\n}\nenum EntityAggregationType {\n  TERMS\n  PROPERTY\n  MIN\n  MAX\n  SUM\n  PERCENTILES\n  STATS\n}\nenum EntityChangeLogChangeType {\n  ADD\n  DELETE\n  UPDATE\n}\n\"\"\"\nEnum defining the names of graph partitions with constant names.\n\nNote that this enum does not define all partition names. Public cloud\naccounts will have their managementEndpointId as the partition\nname.\n\"\"\"\nenum EntityGraphPartitionNames {\n  \"Resources from a VMware management product, typically entityType will start with vmw.ens, vmw.vra, vmw.vrops, vmw.vrni, ...\"\n  VMW_MANAGEMENT_PLANE\n  \"Resources from a VMware managed environment (on-prem or cloud) e.g. vmw.vc, vmw.nsx, ...\"\n  VMW_MANAGED_RESOURCES\n}\nenum EntityPropertyType {\n  STRING\n  BLOB\n  INT\n  LONG\n  DOUBLE\n  BOOL\n  DATETIME\n  STRING_SET\n  INT_SET\n  LONG_SET\n  DOUBLE_SET\n  BOOL_SET\n  DATETIME_SET\n  JSON\n  NULL\n}\nenum EntityTraversalDirection {\n  IN\n  OUT\n  BOTH\n}\nenum EntityTraversalLogicalOperator {\n  \"logical AND operator for nestedFilters\"\n  AND\n  \"logical OR operator for nestedFilters\"\n  OR\n  \"logical NOT operator for single entityTraversal\"\n  NOT\n}\n\"\"\"\nEntityTraversalScope indicates the scope of a relationship traversal in the data model\n\nThis is required when a graph traversal may cross the partitioning boundary of the graph data model.\n\nEach customer has multiple graph partitions. There is one partition\nfor the management plane entities, one for the VMware managed\nresources, and one partition per public cloud account. When navigating\nrelationships between partitions, a query must specify a suitable\nTraversalScope in the traversal.\n\nCross-partition traversals in a graph query have a performance impact\non the query but are required when data is in different partitions.\n\nThe most common requirement to specify a traversal scope are when\ntraversing between a management-plane entity which is constructed by\nthe management layer and an entity from a managed environment in a\npublic or private cloud.\n\nOne simple way of telling if there a cross-partition traversal is\nrequired is to consider the entityType prefixes to determine in which\npartition the relevant entities are stored:\n\n`VMW_MANAGEMENT_PLANE`: entityType prefix indicates resources from a VMware management product: vmw.ens, vmw.vra, vmw.vrops, vmw.vrni, ...\n`VMW_MANAGED_RESOURCES`: entityType prefix indicates managed resources from a VMware managed environment e.g. vmw.vc, vmw.nsx\n`<managementEndpointId>`: entityType prefix indicates a public cloud resource: AWS, Azure, GCP - resources for each public cloud account are stored in separate partitions identified by the managementEndpointId.\n\"\"\"\nenum EntityTraversalScope {\n  \"Optimized traversal scope - relationships are to entities in the same partition (typically same cloudAccountId). Most performant.\"\n  SAME_PARTITION\n  \"Remote traversal scope - relationships are to entities in a different partition\"\n  CROSS_PARTITION\n  \"Default traversal scope - relationships are to entities which may be in the same or a different partition\"\n  ANY_PARTITION\n}\nenum EntityTreeNodeType {\n  ENTITY\n  RELATIONSHIP\n}\n\"Enumeration of names of all defined entity types, with dots replaced with underscores\"\nenum EntityTypeConst {\n  Tanzu_Hub_Application\n  Tanzu_Hub_BusinessApplication\n  Tanzu_Hub_Service\n  Tanzu_Platform_FoundationGroup\n  Tanzu_Platform_OrganizationGroup\n  Tanzu_Platform_SpaceGroup\n  Tanzu_Spring_Application\n  Tanzu_Spring_Definition\n  Tanzu_Spring_Instance\n  Tanzu_Spring_Service\n  Tanzu_TAS_Application\n  Tanzu_TAS_AvailabilityZone\n  Tanzu_TAS_AvailabilityZoneCluster\n  Tanzu_TAS_BoshDirector\n  Tanzu_TAS_BoshVM\n  Tanzu_TAS_Buildpack\n  Tanzu_TAS_Certificate\n  Tanzu_TAS_Deployment\n  Tanzu_TAS_Domain\n  Tanzu_TAS_Droplet\n  Tanzu_TAS_Foundation\n  Tanzu_TAS_IsolationSegment\n  Tanzu_TAS_OpsManager\n  Tanzu_TAS_Organization\n  Tanzu_TAS_OrganizationQuota\n  Tanzu_TAS_ProcessInstance\n  Tanzu_TAS_Resource\n  Tanzu_TAS_Revision\n  Tanzu_TAS_ServiceInstance\n  Tanzu_TAS_ServiceOffering\n  Tanzu_TAS_ServicePlan\n  Tanzu_TAS_Space\n  Tanzu_TAS_Stemcell\n  Tanzu_TAS_Tile\n  Tanzu_TAS_VcenterConfig\n  Tanzu_TAS_VMType\n  VMW_AVI_Certificate\n  VMW_AVI_Controller\n  VMW_AVI_Policy\n  VMW_AVI_Pool\n  VMW_AVI_ServiceEngine\n  VMW_AVI_ServiceEngineGroup\n  VMW_AVI_VirtualService\n  VMW_VC_Cluster\n  VMW_VC_Datacenter\n  VMW_VC_DataStore\n  VMW_VC_DatastoreCluster\n  VMW_VC_DistributedVirtualPortGroup\n  VMW_VC_Folder\n  VMW_VC_GuestCluster\n  VMW_VC_HostSystem\n  VMW_VC_Namespace\n  VMW_VC_Network\n  VMW_VC_Pod\n  VMW_VC_ResourcePool\n  VMW_VC_VCenter\n  VMW_VC_VM\n  VMW_VC_VMwareDistributedVirtualSwitch\n  VMW_VMC_SDDC\n}\nenum EventGroupSortBy {\n  OCCURRENCES\n  RECENT_OCCURRENCE\n}\n\"The set of possible event types available to subscribe to\"\nenum EventsEventType {\n  \"\"\"\n  Fired when an entity is created, updated or deleted. The ENTITY_DELTA payload has two components: entityUpdates (see EntityDelta), and relationshipUpdates (see EntityRelationshipDelta)\n  The entire schema of deltas can be explored starting from EntityInventoryDelta in GraphQL schema.\n  \"\"\"\n  ENTITY_DELTA\n  \"Fired when an observation is created. The payload is an array of Observation (see Observation for payload details). Example observations can be found executing a ObservationQuery.queryObservations query\"\n  OBSERVATION\n}\nenum ExceptionAggregationType {\n  COUNT\n}\nenum ExceptionGroupSortBy {\n  OCCURRENCES\n  RECENT_OCCURRENCE\n}\n\"The status of the installation.\"\nenum FleetManagementInstallationStatus {\n  \"The installation is in progress.\"\n  IN_PROGRESS\n  \"The installation was successful.\"\n  SUCCESSFUL\n  \"The installation failed.\"\n  FAILED\n}\n\"Enum representing the possible outcomes of a fleet template mutation.\"\nenum FleetManagementMutationResultStatusEnum {\n  \"Indicates that the mutation completed successfully.\"\n  SUCCESS\n  \"Indicates that the mutation failed.\"\n  ERROR\n}\nenum FleetTemplateExecutionStatusEnum {\n  PENDING\n  PROCESSING\n  COMPLETED\n  FAILED\n}\nenum GroupFoundationGroupMutationResultStatusEnum {\n  SUCCESS\n  ERROR\n}\nenum GroupOrganizationGroupMutationResultStatusEnum {\n  SUCCESS\n  ERROR\n}\nenum GroupSpaceGroupMutationResultStatusEnum {\n  SUCCESS\n  ERROR\n}\n\"Policy execution status\"\nenum HubPolicyRunStatus {\n  \"Policy evaluation is in progress\"\n  EVALUATING\n  \"Policy evaluation is completed\"\n  COMPLETED @deprecated(reason: \"No longer supported\")\n  \"Policy evaluation is completed no non-compliant resources found/no action taken\"\n  COMPLETED_COMPLIANT\n  \"Policy evaluation is completed non-compliant resources found action taken\"\n  COMPLETED_NON_COMPLIANT\n  \"Evaluation completed, non-compliant resources found, action not executed as defined by policy\"\n  COMPLETED_PENDING_ACTION\n  \"Policy evaluation failed with errors\"\n  ERROR\n  \"Policy evaluation timed out\"\n  TIMED_OUT\n}\nenum HubQueryAutocompletionCategoryName {\n  SYMBOLS\n  ENTITY_TYPES\n  ENTITY_FIELDS\n  PROPERTY_NAMES\n  TAG_KEYS\n  PROPERTY_VALUES\n  TAG_VALUES\n  OTHER\n}\nenum HubQueryType {\n  GRAPH\n  LIST\n  AGGREGATION\n}\n\"The HTTP request method to be used in the hyperlink invocation\"\nenum HyperLinkHttpRequestMethod {\n  GET\n  POST\n}\n\"Insight change log type\"\nenum InsightChangeLogChangeType {\n  COMMENT\n  ASSIGN_USER\n  ADD_OBSERVATION\n  REMOVE_OBSERVATION\n  UPDATE_TITLE\n  UPDATE_DESCRIPTION\n  UPDATE_STATUS\n  UPDATE_SEVERITY\n  UPDATE_IMPACT\n  UPSERT_TAGS\n  DROP_TAGS\n  UPDATE_KEYWORDS\n  MERGE_INSIGHTS\n}\n\"Insight change log update mode\"\nenum InsightChangeLogUpdateMode {\n  SYSTEM\n  USER\n}\n\"Correaltion Rule Type\"\nenum InsightCorrelationRuleType {\n  \"These rules have curated handling for impacts\"\n  CURATED\n  \"These rules have no specific handling\"\n  DEFAULT\n}\n\"Window type for correlation\"\nenum InsightCorrelationRuleWindowType {\n  SLIDING\n  FIXED\n}\nenum InsightImpactDimension {\n  PERFORMANCE\n  CAPACITY\n  COST\n  CONFIGURATION\n  SECURITY\n  AVAILABILITY\n  CONNECTIVITY\n  GENERAL\n}\nenum InsightImpactMeasure {\n  VERY_NEGATIVE\n  NEGATIVE\n  SLIGHTLY_NEGATIVE\n  NEUTRAL\n  SLIGHTLY_POSITIVE\n  POSITIVE\n  VERY_POSITIVE\n}\n\"Insight Priorities P0 being highest\"\nenum InsightPriority {\n  P0\n  P1\n  P2\n  P3\n  P4\n}\n\"Type of correlation applied to derive insight\"\nenum InsightProviderType {\n  \"Insight provided by machine learning engine\"\n  MACHINE_LEARNING\n  \"Insight provided by rule engine\"\n  RULE\n  \"Insight provided by business intelligence engine\"\n  BUSINESS_INTELLIGENCE\n  \"Insight aggregating Governance findings\"\n  GOVERNANCE_FINDINGS\n}\n\"Operator used in constraints\"\nenum InsightRuleOperator {\n  OR\n  AND\n  EQ\n  NEQ\n  IN\n  NIN\n  REGEX\n  CONTAINS\n}\n\"Severity of an insight\"\nenum InsightSeverity {\n  UNKNOWN\n  NONE\n  INFORMATION\n  WARNING\n  IMMEDIATE\n  CRITICAL\n}\nenum InsightStatus {\n  CREATED\n  UPDATED\n  ACTIVE\n  DELETED\n  RESOLVED\n  SNOOZED\n}\nenum InsightTriggerType {\n  \"Unexpected insight e.g. host failure\"\n  ANOMALOUS\n  \"Insight initiated by a user action\"\n  USER_INITIATED\n  \"Insight initiated by the system e.g. scaling or rebalancing\"\n  AUTOMATIC\n  \"Unidentified cause of insight\"\n  UNKNOWN\n}\nenum LicenseApplicationWorkflowStatus {\n  ALREADY_APPLIED\n  WORKFLOW_STARTED\n  WORKFLOW_PENDING\n  ERROR\n}\nenum LicenseVerificationFailure {\n  \" The license key provided dit not match any known licenses \"\n  NO_MATCHING_LICENSE\n  \" The license matched to the provided key has expired \"\n  LICENSE_EXPIRED\n  \" The license key provided is not a validly constructed license key \"\n  LICENSE_KEY_ERROR\n  \" An unexpected failure of license data extraction \"\n  DLF_EXCEPTION\n}\nenum LogAggregationType {\n  SUM\n  COUNT\n}\nenum LogPatternSortBy {\n  \"Sort by TREND\"\n  TREND\n  \"Sort by COUNT of log patterns in current window\"\n  COUNT\n}\n\"Status of the discover accounts request\"\nenum ManagementEndpointAccountDiscoveryStatus {\n  \"Member accounts and hierarchy is being discovered and still in progress\"\n  IN_PROGRESS\n  \"Account discovery request completed successfully\"\n  SUCCESS\n  \"Account discovery request failed\"\n  FAILED\n}\nenum ManagementEndpointAggregationType {\n  TERMS\n  PROPERTY\n}\nenum ManagementEndpointCollectorCollectionStatus {\n  HEALTHY\n  UNHEALTHY\n}\nenum ManagementEndpointCollectorCollectionType {\n  METRICS\n  LOGS\n  INVENTORY\n  ALERTS\n}\n\" Management Endpoint Collector Health Status \"\nenum ManagementEndpointCollectorHealthStatus {\n  NA\n  Offline\n  Online\n}\n\" Management Endpoint Collector Status \"\nenum ManagementEndpointCollectorStatus {\n  Discovered\n  Pending\n  Ready\n}\n\" Supported Management Endpoint Collectors \"\nenum ManagementEndpointCollectorType {\n  Kubernetes\n  TAS\n  VCF\n}\n\"\"\"\n Management Endpoint Credential broker Health Status  unknown when broker status is pending\nonline when we get updates and offline indicates heartbeat was not received\n\"\"\"\nenum ManagementEndpointCredentialBrokerHealthStatus {\n  UNKNOWN\n  OFFLINE\n  ONLINE\n}\n\" Management Endpoint Credential broker Status, PENDING represents broker not yet performed registration, REGISTERED indicates performed registration \"\nenum ManagementEndpointCredentialBrokerRegistrationStatus {\n  PENDING\n  REGISTERED\n}\nenum ManagementEndpointCredentialPermissionType {\n  COLLECTION\n  ADMINISTRATION\n}\nenum ManagementEndpointCredentialScope {\n  \"Credential used by Guardrails for interactions with managed environment\"\n  GUARDRAILS_ADMIN\n  \"Credential used by Application Engine for kubernetes cluster lifecycle management\"\n  TAP_CLUSTER_LCM\n  \"Credential used by Data services to configure data protection\"\n  TAP_DATA_PROTECTION\n  \"Credential used by CloudHealth for interactions with managed environment\"\n  TANZU_CLOUDHEALTH\n  \"Credential used to configure global server load balancing\"\n  TAP_GSLB\n  \"Credential used for Tanzu Intelligent Assist\"\n  TANZU_INTELLIGENT_ASSIST\n}\nenum ManagementEndpointCredentialStatus {\n  CREATED\n  \"The credential's capabilities are being validated by the intended service. Credentials can be used even if they have not been validated - this status is set by the intended service if it validates credentials.\"\n  VALIDATING\n  \"The credential satisfies the intended service's requirements.\"\n  VALID\n  \"The credential does not satisfy the intended service's requirements. Invalid credentials might require user action to fix their permissions- this information is provided by the intended service.\"\n  INVALID\n  \"The credential satisfies the intended service's requirements and required permissions are present, but some additional/optional permissions are missing.\"\n  NEEDS_UPDATE\n  \"An error occurred while the credential was being created or validated.\"\n  ERROR\n  \"The credential clean up has begun.\"\n  DELETING\n}\nenum ManagementEndpointCredentialType {\n  \"Credential that contains userName and password\"\n  USER_CREDENTIAL\n  \"vCenter credential that contains userName and password\"\n  VC_USER_CREDENTIAL\n  \"vROPS credential that contains userName and password\"\n  VROPS_USER_CREDENTIAL\n  \"Foundation credential that contains userName and password\"\n  FOUNDATION_USER_CREDENTIAL\n  \"AWS IAM Role\"\n  AWS_IAM_ROLE\n  \"Azure app key\"\n  AZURE_APP_KEY\n  \"\"\"\n  \"Azure certificate key\n  \"\"\"\n  AZURE_CERT_KEY\n  \"\"\"\n  \"Azure AD app key\n  \"\"\"\n  AZUREAD_APP_KEY\n  \"GCP service account key\"\n  GCP_SERVICE_ACC_KEY\n  \"AWS ACCESS KEY\"\n  AWS_ACCESS_KEY\n  \"API key for Gemini endpoint\"\n  GEMINI_API_KEY\n  \"Tanzu Intelligent Assist Server API key\"\n  TIA_SERVER_API_KEY\n  \"API_KEY for Git\"\n  GIT_API_KEY\n  \"userName and password for Git\"\n  GIT_USER_CREDENTIAL\n  \"Foundation credential that contains passcode\"\n  FOUNDATION_TOKEN_CREDENTIAL\n  \"Warehouse credential\"\n  WAREHOUSE_TOKEN_CREDENTIAL\n  \"userName and password for Clickhouse\"\n  CLICKHOUSE_CREDENTIAL\n}\n\"Credential usage error types\"\nenum ManagementEndpointCredentialUsageErrorType {\n  \"Generic error while generating/fetching credential. Credential could not be shared with the source service requesting it.\"\n  CREDENTIAL_REQUEST_ERROR\n  \"Credential could not be used because credential does not have required permissions.\"\n  AUTHORIZATION_ERROR\n  \"Credential could not be used because of authentication error.\"\n  AUTHENTICATION_ERROR\n  \"Generic error while using credential by source service.\"\n  CREDENTIAL_USAGE_ERROR\n}\n\"Current status of the credential usage\"\nenum ManagementEndpointCredentialUsageStatus {\n  \"Credential was shared successfully with the source service\"\n  CREDENTIAL_REQUEST_SUCCESS\n  \"Credential is being used by the source service\"\n  CREDENTIAL_USAGE_INPROGRESS\n  \"Credential was used successfully by the source service\"\n  CREDENTIAL_USAGE_SUCCESS\n  \"Error while generating/fetching the credential\"\n  CREDENTIAL_REQUEST_ERROR\n  \"Error while using credential\"\n  CREDENTIAL_USAGE_ERROR\n}\nenum ManagementEndpointCredentialValidationErrorType {\n  \"Error when validating credentials\"\n  CREDENTIAL_VALIDATION_ERROR\n  \"Credential could not be used because of authentication error.\"\n  AUTHENTICATION_ERROR\n}\n\"Services for management endpoint and credential definition queries\"\nenum ManagementEndpointDefinitionServiceName {\n  VRNI\n  COST\n  GUARDRAILS\n  HUB\n}\n\"Status of a management endpoint as used in a given deployed service\"\nenum ManagementEndpointDeploymentStatus {\n  ACTIVE\n  DRAFT\n  VALIDATION_FAILED\n  DENY_ACCESS\n  DISCOVERED\n  CONNECTED\n  DISCONNECTED\n  ERROR\n  HEALTHY\n  REVIEW\n  CONNECTION_ISSUE\n  CERTIFICATE_ISSUE\n}\n\" Response format for discovered accounts. Discovered accounts can be requested in one of the following formats: TREE, FLATTENED_TREE, LIST. \"\nenum ManagementEndpointDiscoveredAccountResponseFormat {\n  \"TREE response would contain a hierarchical nested response structure. The top-level discoveredNodeConnection field would only contain the 'base' nodes and the nesting would be found inside childConnection field of individual nodes.\"\n  TREE\n  \"FLATTENED_TREE would contain all the nodes in the top-level discoveredNodeConnection connection. The parent and childConnection fields of individual nodes would only cont  ain 'id' field to establish the relationship among nodes.\"\n  FLATTENED_TREE\n  \"LIST would return only discovered accounts. Organisation structure (account groupings like OrganisationalUnit in case of AWS) will not be part of the response. All the discovered accounts will be present in top-level discoveredNodeConnection field. The parent and childConnection fields of individual nodes will not be populated in this case.\"\n  LIST\n}\n\"Entitlement specific onboarding status for a management endpoint\"\nenum ManagementEndpointEntitlementOnboardingStatus {\n  SUCCESSFUL\n  FAILED\n  REMOVED\n  INPROGRESS\n}\nenum ManagementEndpointPropertySemantic {\n  \"Field must be a fully-qualified domain name or an IP address\"\n  SERVER_ADDRESS\n}\nenum ManagementEndpointPropertyType {\n  BLOB\n  BOOL_SET\n  BOOL\n  DOUBLE_SET\n  DOUBLE\n  INT_SET\n  INT\n  LONG_SET\n  LONG\n  STRING_SET\n  STRING\n  DATETIME\n  DATETIME_SET\n}\n\"Management endpoint request status\"\nenum ManagementEndpointRequestStatus {\n  SUCCESSFUL\n  FAILED\n}\n\" Type of action \"\nenum ManagementEndpointResourceAction {\n  \" To create the resource \"\n  CREATE\n  \"\"\"\n   To update the existing resource.\n  This works like PUT operation, the entire resource should be added. \n  \"\"\"\n  UPDATE\n  \" To delete the existing resource \"\n  DELETE\n}\nenum ManagementEndpointServiceType {\n  NETWORK_OPERATIONS\n}\n\" The reason phrase of the status. This can be used to better diagnose the status. \"\nenum ManagementEndpointStatusCause {\n  ACCESS_DENIED\n  HOST_UNREACHABLE\n  AUTHENTICATION_FAILED\n  INTERNAL_ERROR\n  EVENT_STREAM_NOT_CONNECTED\n  CERTIFICATE_ISSUE\n}\n\" Status of the Management Endpoint \"\nenum ManagementEndpointStatusEnum {\n  OK\n  FAILED\n  PARTIAL_OK\n  DISABLED\n}\n\"Status Type of a management endpoint as used in a given deployed service\"\nenum ManagementEndpointStatusType {\n  EVENT_STREAM_STATUS\n  ACCOUNT_STATUS\n  ROLLUP_STATUS\n}\n\"Type of the Management Endpoint\"\nenum ManagementEndpointType {\n  VC\n  VROPS\n  AWS\n  AZURE\n  AZUREAD\n  GCP\n  DATACENTER\n  FOUNDATION\n  GEMINI\n  TIA_SERVER\n  SAA\n  TANZU_HUB\n}\n\"Management endpoint upsert error types\"\nenum ManagementEndpointUpsertErrorType {\n  ENDPOINT_CREATION_FAILED\n  CREDENTIAL_CREATION_FAILED\n  ENDPOINT_CREDENTIAL_MAPPING_FAILED\n  DEPLOY_ENDPOINT_TO_CLOUD_PROXY_FAILED\n}\nenum NotificationPropertyValueDataType {\n  String\n  Password\n  Integer\n  Float\n  Boolean\n  JSON\n  JSON_ARRAY\n}\nenum NotificationTargetDeleteStatusValue {\n  SUCCESS\n  FAILURE\n}\nenum NotificationTargetStatusValue {\n  CREATED\n  HEALTHY\n  ERROR\n}\nenum NotificationTargetTestStatus {\n  SUCCESS\n  FAILURE\n}\nenum OAuthAppGrantType {\n  CLIENT_CREDENTIALS\n}\nenum OAuthAppMutationStatusEnum {\n  SUCCESS\n  ERROR\n}\n\"Operator used in Observability Alert threshold\"\nenum ObservabilityAggregationFunction {\n  COUNT\n}\nenum ObservabilityAlertConfigUpdateStatus {\n  SUCCESS\n  ERROR\n}\nenum ObservabilityAlertDynamicThresholdDirection {\n  LOWER\n  UPPER\n  BOTH\n}\nenum ObservabilityAlertEntityType {\n  FOUNDATION\n  APP\n  SERVICE\n  SYSTEM_HEALTH\n  AUTO\n}\n\"Observability Alert severity\"\nenum ObservabilityAlertSeverity {\n  CRITICAL\n  HIGH\n  MEDIUM\n  LOW\n  INFO\n}\nenum ObservabilityAlertSilenceState {\n  ACTIVE\n  PENDING\n  EXPIRED\n}\nenum ObservabilityAlertStatus {\n  \"Alerts are firing and observations are created\"\n  FIRING\n  \"Alerts are waiting for defined period of time to pass. Post that alerts get triggered\"\n  PENDING\n  \"Error during alert evaluation\"\n  ERROR\n  \"Alert condition is not being met\"\n  INACTIVE\n  \"Alert is disabled\"\n  DISABLED\n}\n\"Operator used in Observability Alert threshold\"\nenum ObservabilityAlertThresholdOperator {\n  GT\n  LT\n  LT_EQ\n  GT_EQ\n}\nenum ObservabilityAlertThresholdType {\n  STATIC\n  DYNAMIC\n}\nenum ObservabilityAlertType {\n  METRIC\n  LOG\n}\nenum ObservabilityMatchersOperator {\n  EQUAL\n  NOT_EQUAL\n  CONTAINS\n  DOES_NOT_CONTAIN\n}\n\"Metric chart type\"\nenum ObservabilityMetricChartType {\n  LINE\n  COLUMN\n  AREASPLINE\n}\nenum ObservabilityNotificationTemplateType {\n  CUSTOM\n}\n\"Data type to identify observability entities\"\nenum ObservabilityResourceType {\n  \"Metric alert policies\"\n  METRIC_ALERT_DEFINITION\n  \"Log alert policies\"\n  LOG_ALERT_DEFINITION\n}\nenum ObservationAggregationType {\n  TERMS\n}\n\"Spec schema version\"\nenum ObservationMappingRuleSchemaVersion {\n  VERSION_1_0\n}\nenum ObservationQueryType {\n  OBSERVATIONS_WITH_INSIGHTS\n  OBSERVATIONS_WITHOUT_INSIGHTS\n  ALL_OBSERVATIONS\n}\nenum ObservationSource {\n  VROPS\n  VMC\n  VRLIC\n  WF\n  VRNI\n  ENS\n  AWS\n  AZURE\n  K8S\n  GOVERNANCE\n  HEALTHWATCH\n  APP_METRICS\n  VROPS_ONPREM\n  DYNATRACE\n  DATADOG\n}\nenum ObservationStatus {\n  CREATED\n  UPDATED\n  RESOLVED\n  OBSOLETE\n}\n\"Type of tagging rule\"\nenum ObservationTaggingRuleType {\n  STATIC\n  COMPOSITION\n  EXTRACTION\n}\nenum PlatformProfileType {\n  CURRENT\n  RECOMMENDED\n}\n\"Operators to help in the filtering\"\nenum QueryFilterOperator {\n  EQ\n  NEQ\n  LT\n  LTE\n  GT\n  GTE\n  \"The CONTAINS operator does a case sensitive check for the passed string being part of the value. Example 'foo' passed and value being 'foobar' will match\"\n  CONTAINS\n  \"The DOESNOTCONTAIN operator does a case sensitive check for the passed string that should not be part of the value. Example 'foo' passed and value will consist of strings without 'foo' word.\"\n  DOESNOTCONTAIN\n  \"The STARTSWITH operator does a case sensitive check for the passed string being start of the value. Example 'foo' passed and value being 'foobar' will match\"\n  STARTSWITH\n  \"The ENDSWITH operator does a case sensitive check for the passed string being end of the value. Example 'bar' passed and value being 'foobar' will match\"\n  ENDSWITH\n  \"The ISNULL operator does not require the value to be set.\"\n  ISNULL\n  \"The ISNULL operator does not require the value to be set.\"\n  ISNOTNULL\n}\n\"Sorting order for a field\"\nenum QuerySortOrder {\n  ASC\n  DESC\n}\nenum RepositoryOnboardingStatus {\n  NONE\n  CANDIDATE\n  ONBOARDED\n}\n\"Supported Source Code Management (SCM) providers\"\nenum RepositorySCMType {\n  \"GitHub SCM provider\"\n  GITHUB\n  \"GitLab SCM provider\"\n  GITLAB\n  \"Bitbucket SCM provider\"\n  BITBUCKET\n}\n\" Service Plan Visibility Management Types\"\nenum ServicePlanVisibilityType {\n  \"Make the service plan publicly visible\"\n  _public\n  \"Make the service plan visible to admins only\"\n  admin\n  \"Make the service plan visible to specific organization groups\"\n  organization\n}\nenum ServiceType {\n  managed\n  \" should map to user_provided on the CF GraphQL Provider API\"\n  self_managed\n}\nenum SpringArtifactAssessmentType {\n  SPRING_HEALTH\n  SPRING_GIT_REPO\n}\nenum SpringArtifactRecommendationType {\n  FINDING\n  RECOMMENDATION\n}\n\"repository endpoint access type \"\nenum SpringArtifactRepositoryEndpointAccessType {\n  \"repository is accessible publicly\"\n  PUBLIC\n  \"repository is only accessible within customer network\"\n  PRIVATE\n}\nenum SpringArtifactRepositoryEndpointType {\n  GITHUB\n  GITLAB\n}\nenum SpringArtifactRepositoryStatus {\n  NOT_APPLICABLE\n  APPLICABLE\n  CONTINUES_ENABLED\n}\nenum SpringArtifactSBOMSupportStatus {\n  \"OSS support does not exists either for open source or commercial\"\n  UNSUPPORTED\n  \"OSS support end date has been reached, but commercial support is still available\"\n  UNSUPPORTING\n  \"OSS support exists\"\n  SUPPORTED\n}\n\"Represents effort needed to upgrade a spring artifact version\"\nenum SpringArtifactUpgradeEffort {\n  HIGH\n  MEDIUM\n  LOW\n  NONE\n}\n\"Represents Vulnerability Severity of spring artifact\"\nenum SpringArtifactVulnerabilitySeverity {\n  CRITICAL\n  HIGH\n  MODERATE\n  LOW\n  NONE\n}\n\"Enumeration of stat data modes.\"\nenum StatDataMode {\n  \"Finite number\"\n  NUM\n  \"Not a number\"\n  NAN\n  \"Positive infinity\"\n  POS_INF\n  \"Negative infinity\"\n  NEG_INF\n}\nenum StatsAggregationType {\n  SUM\n  MIN\n  MAX\n  AVG\n  COUNT\n}\nenum StatsQuerySeriesDataAnalysisStatus {\n  SUCCESS\n  WARNING\n  ERROR\n}\nenum StatsRollupType {\n  SUM\n  AVG\n  MIN\n  MAX\n  NONE\n  LATEST\n  COUNT\n}\n\"TanzuHubPolicyAlertCategory\"\nenum TanzuHubPolicyAlertCategory {\n  METRIC\n  LOG\n}\n\"TanzuHubPolicyAlertType\"\nenum TanzuHubPolicyAlertType {\n  THRESHOLD\n  ANOMALY\n}\nenum TanzuHubPolicyDaysOfWeek {\n  MONDAY\n  TUESDAY\n  WEDNESDAY\n  THURSDAY\n  FRIDAY\n  SATURDAY\n  SUNDAY\n}\n\"TanzuHubPolicyFindingSeverity\"\nenum TanzuHubPolicyFindingSeverity {\n  CRITICAL\n  HIGH\n  MEDIUM\n  LOW\n  INFO\n}\nenum TanzuHubPolicyIntervalType {\n  MINUTE\n  HOURLY\n  DAILY\n  WEEKLY\n  MONTHLY\n}\nenum TanzuHubPolicyRuleEvaluationStatus {\n  \"Rule conditions evaluate to find no non-compliant resources\"\n  COMPLIANT\n  \"Rule conditions evaluate to find non-compliant resources\"\n  NON_COMPLIANT\n  \"Error while evaluating rule\"\n  ERROR\n  \"Rule not evaluated\"\n  NOT_EVALUATED\n  \"Rule condition hints finding non-compliant resources \"\n  PENDING\n}\n\"Limit status which helps in determining if limit is breached\"\nenum UsageLimitStatus {\n  \"Limit is still not being breached\"\n  LIMIT_AVAILABLE\n  \"Limit has been breached\"\n  LIMIT_BREACHED\n}\nenum UserInterestLevel {\n  LOW\n  MEDIUM\n  HIGH\n}\nenum UserPrefScope {\n  \"Preference is specific to the user who created it\"\n  USER\n  \"Preference is visible to all users in the organization but can be set by only Global Admins\"\n  GLOBAL\n}\n\"\"\"\nSpecifies the type of content to be re-indexed in the warehouse system.\nEach type represents a distinct category of artifacts that can be processed\nindependently during indexing operations.\n\"\"\"\nenum WarehouseIndexingType {\n  \"\"\"\n  Indexes binary artifacts including:\n  - Tiles (platform components)\n  - OVAs\n  - Stemcells (OS images)\n  - Buildpacks (runtime environments)\n  - Other related binary dependencies\n  \n  Use this type when you need to refresh or update the binary artifact catalog.\n  \"\"\"\n  BINARY\n  \"\"\"\n  Indexes security-related metadata including:\n  - Vulnerability reports\n  - Software Bill of Materials (SBOMs)\n  \n  Use this type when you need to update security information without\n  re-indexing the entire binary catalog.\n  \"\"\"\n  SECURITY_METADATA\n  \"Indexes all artifacts\"\n  FULL\n}\n\"Types of products to be found in the Warehouse\"\nenum WarehouseProductType {\n  \"Tiles offering specific services or platform capabilities\"\n  TILE\n  \"Operating system base images for BOSH\"\n  STEMCELL\n  \"Buildpack packages containing frameworks and runtime support for applications\"\n  BUILDPACK\n  \"Vulnerability reports and security metadata\"\n  VULNERABILITIES_REPORT\n  \"Software Bill of Materials (SBOM) containing a list of components and their dependencies\"\n  SBOM\n  \"Any other uncategorized product\"\n  OTHER\n}\nenum WorkflowStatus {\n  UNSPECIFIED\n  \"RUNNING means the workflow run is either actively progressing or is waiting on something.\"\n  RUNNING\n  \"COMPLETED means the workflow run completed successfully.\"\n  COMPLETED\n  \"FAILED means the workflow run returned an error and failed.\"\n  FAILED\n  \"CANCELED means the workflow run was canceled by request. Canceling allows the workflow code to end gracefully and potentially perform any cleanup.\"\n  CANCELED\n  \"TERMINATED means the workflow run was terminated by request. Terminating causes a workflow to stop processing immediately.\"\n  TERMINATED\n  \"CONTINUED_AS_NEW means the workflow run was checkpointed and replaced with a new workflow run. This only applies to workflows with large numbers of activities or due to workflow versioning transitions.\"\n  CONTINUED_AS_NEW\n  \"TIMED_OUT means the workflow run ended because it exceeded a timeout limit.\"\n  TIMED_OUT\n}\nenum WorkflowTaskStatus {\n  \"Workflow Task was scheduled\"\n  TASK_SCHEDULED\n  \"Workflow Task has started executing\"\n  TASK_STARTED\n  \"Workflow Task has finished unsuccessfully\"\n  TASK_FAILED\n  \"Workflow Task has finished successfully\"\n  TASK_COMPLETED\n  \"Activity did not complete within the timeout settings\"\n  TASK_TIMED_OUT\n  \"Child Workflow execution has initiated\"\n  CHILD_WORKFLOW_EXECUTION_INITIATED\n  \"Child Workflow execution has successfully started/ triggered\"\n  CHILD_WORKFLOW_EXECUTION_STARTED\n  \"Child Workflow execution has unsuccessfully completed\"\n  CHILD_WORKFLOW_EXECUTION_FAILED\n  \"Child Workflow execution has successfully completed\"\n  CHILD_WORKFLOW_EXECUTION_COMPLETED\n}\ninput AriaNotificationTargetPropertyInput {\n  \"name of the property\"\n  name: String!\n  \"value of the property\"\n  value: Object\n}\ninput AriaNotificationUpsertTargetInput {\n  \"Name of this notification target\"\n  displayName: String!\n  \"Enabled turns the notification target on/off\"\n  enabled: Boolean!\n  \"Opaque version string for this instance\"\n  nodeVersion: ID\n  \"Unique identifier of the notification target instance\"\n  notificationTargetId: String\n  \"The list of properties specific for the selected notification target type\"\n  properties: [AriaNotificationTargetPropertyInput!]!\n  \"Scoping Entity id(s) that are included\"\n  scopingEntityIds: [String!]\n  \"Notification target type\"\n  type: String!\n}\ninput AriaTestNotificationTargetInput {\n  \"Notification notification target ID to test existing target\"\n  notificationTargetId: String\n  \"The list of properties specific for the selected notification target type\"\n  properties: [AriaNotificationTargetPropertyInput!]\n  \"notification target type required for new target\"\n  type: String\n}\ninput ArtifactAssessmentAggregationFilterInput {\n  \"Filter by a given assessment id\"\n  assessmentId: String\n  \"Filter by lastUpdateTime date and time\"\n  lastUpdateTime: QueryTimeRangeFilter\n}\ninput ArtifactAssessmentAggregationInput {\n  \"Aggregation type\"\n  aggregationType: ArtifactAssessmentAggregationType = TERMS\n  \"Field on which to aggregate\"\n  fieldName: ArtifactAssessmentAggregationField!\n  \"\"\"\n  Interval for DATE_HISTOGRAM aggregation\n  For other type, it will be ignored\n  \"\"\"\n  interval: ArtifactAssessmentAggregationIntervalInput\n}\ninput ArtifactAssessmentAggregationIntervalInput {\n  duration: ArtifactAssessmentAggregationIntervalDuration\n}\ninput ArtifactAssessmentStatsFilterInput {\n  \"filter by assessment type\"\n  assessmentType: [SpringArtifactAssessmentType!]!\n}\n\"\"\"\nFields on which aggregation is needed\nFor nested aggregation subAggregations needs to be populated\n\"\"\"\ninput ArtifactVulnerabilityAggregationFieldInput {\n  \"Type of aggregations\"\n  aggregationType: ArtifactVulnerabilityEntityAggregationType! = TERMS\n  \"\"\"\n  Name of field on which aggregation is to be performed\n  Supported fields for category:\n  - APPLICATION: severity, packageName, packageVersion\n  - COMPONENT: severity, entityId, entityType, remediation\n  \"\"\"\n  field: String!\n  \"Include empty buckets for predefined values (only supported for entityType and severity)\"\n  includeEmptyBuckets: Boolean\n  \"Ordering option for aggregation buckets\"\n  orderBy: ArtifactVulnerabilityBucketOrder\n  \"Nested aggregations\"\n  subAggregations: ArtifactVulnerabilityAggregationFieldInput\n}\n\"Vulnerability aggregation input\"\ninput ArtifactVulnerabilityEntityAggregationInput {\n  \"aggregation fields\"\n  aggregationFields: ArtifactVulnerabilityAggregationFieldInput!\n  \"Filter vulnerabilities before applying aggregation\"\n  filter: ArtifactVulnerabilityEntityFilterInput\n}\n\"Filter vulnerability entity mapping\"\ninput ArtifactVulnerabilityEntityFilterInput {\n  \"Combine filters with a logical AND\"\n  and: [ArtifactVulnerabilityEntityFilterInput!]\n  \"Filter vulnerabilities by artifact names\"\n  artifactNames: [String]\n  \"Filter vulnerabilities by CVE IDS\"\n  cveId: [String!]\n  \"Filter vulnerabilities by entityIds of affected entities\"\n  entityId: [EntityId!]\n  \"\"\"\n  Filter vulnerabilities by entityNames of affected entities. Supports wildcard searches using *\n  Eg. spring* , *metal, *spring*\n  \"\"\"\n  entityName: [String!]\n  \"Filter vulnerabilities by entityTypes of affected entities\"\n  entityType: [String!]\n  \"Combine filters with a logical OR\"\n  or: [ArtifactVulnerabilityEntityFilterInput!]\n  \"Filter vulnerabilities by package names, Supports 'contains' search\"\n  packageName: [String!]\n  \"Filter vulnerabilities by vulnerability cvss v3 score\"\n  score: ArtifactVulnerabilityScoreRangeInput\n  \"Filter vulnerabilities by vulnerability severity\"\n  severity: [ArtifactVulnerabilitySeverity!]\n  \"Filter vulnerabilities by triage status\"\n  triage: [ArtifactVulnerabilityTriageStatus]\n}\n\"\"\"\nFilter vulnerability overtime by cveId or entityId ( supported entity types Tanzu.Hub.Application )\nNote: Combination of cveId and entityId is not supported, at any time we can query by either cveId or entityId.\nif neither is passed all vulnerabilities over time will be reported\n\"\"\"\ninput ArtifactVulnerabilityEntityOvertimeFilterInput {\n  \"CVE_ID of vulnerability for which vulnerability overtime is requested\"\n  cveId: [String!]\n  \"if specified only vulnerabilities reported till endDate  will be reported.\"\n  endDate: Date\n  \"Entity id for application for which vulnerability overtime is requested, only supported entityType : Tanzu.Hub.Application\"\n  entityId: [EntityId!]\n  \"minimum time interval, this defaults to DAILY\"\n  precision: ArtifactVulnerabilityOvertimePrecision = DAILY\n  \"if specified only vulnerabilities reported after startDate  will be reported.\"\n  startDate: Date\n}\n\"Filter Vulnerabilities by cvss v3 score, vulnerabilities with CVSS v3 score greater than equal to specified min and less than equal to specified max will be returned\"\ninput ArtifactVulnerabilityScoreRangeInput {\n  max: Float\n  min: Float\n}\n\"Input filter for events\"\ninput AssessmentEventFilterInput {\n  \"Filter by event names\"\n  eventName: [AssessmentEventName!]\n  \"Filter by event status\"\n  status: [AssessmentEventStatus!]\n}\ninput AssessmentRuleInput {\n  \"Rule advice\"\n  advice: String\n  \"Pattern to be used for matching\"\n  defaultPattern: String\n  \"Migration effort required\"\n  effort: Int!\n  \"Whether the rule is enabled\"\n  enabled: Boolean\n  \"Entity ID of the rule, if left empty new rule will be created\"\n  entityId: EntityId\n  excludePatterns: [AssessmentRulePatternInput!]\n  \"Pattern of the name of the file to apply rule to\"\n  fileNamePattern: String\n  \"Type of file to apply rule to\"\n  fileType: String!\n  name: String!\n  patterns: [AssessmentRulePatternInput!]\n  ruleType: AssessmentRuleType!\n  tags: [TagInput!]\n  \"Rule application target e.g. line\"\n  target: AssessmentRuleTargetType!\n  \"Type of matching to be used e.g. regex\"\n  type: AssessmentRuleMatchType!\n}\ninput AssessmentRulePatternInput {\n  advice: String\n  effort: Int\n  tag: TagInput\n  value: String!\n}\ninput AssessmentRuleWithScopeInput {\n  \"Rule to be upserted\"\n  rule: AssessmentRuleInput!\n  \"EntityId of an existing repository/assessment, should be empty when scope is Global\"\n  scope: EntityId\n}\ninput AuthRoleCreateBindingInput {\n  \"Reference to role by name\"\n  roleName: String!\n  \"Optional scope boundary for the role binding. If no value is specified, the user will have global access.\"\n  scopingEntityId: EntityId\n  \"\"\"\n  Subject identifier.\n  For USER this must be the email Id of the user\n  For GROUP this must be the group name contained in OIDC identity token\"\n  \"\"\"\n  subjectId: String!\n  \"\"\"\n  The type of subject. Should be USER when a role binding for user is being created. Should be GROUP when a role binding for group is being created.\n  Should be OAUTH_APP when a role binding for oAuthApp is being created.\n  If no value is specified, the role binding will be created with USER subject type.\n  \"\"\"\n  subjectType: AuthRoleBindingSubjectType = USER\n}\ninput BusinessAppDefinitionInput {\n  \"\"\"\n  Optional EntityId of this element (group or group member).\n  \n  If this is populated then the definition must refer to an existing entity.\n  \n  If this is left empty then a new BusinessApplication will be created with the provided entityName.\n  \"\"\"\n  entityId: EntityId\n  \"The name of the entity\"\n  entityName: String!\n  \"Optional list of app members.\"\n  members: [EntityId!]\n  \"Optional list of potential business applications, that this BA is curated from.\"\n  potentialBusinessApps: [EntityId!]\n}\ninput CapacityAggregationInput {\n  \"fieldName dictates columns/member-variables on which to aggregate.\"\n  fieldName: String!\n  \"Scope of the aggregation, i.e should Applications capacity be aggregated\"\n  queryScope: CapacityQueryScope = APPLICATION\n  \"Optional sub-aggregations\"\n  subAggregations: [CapacityAggregationInput!]\n}\ninput CapacityInfoFilter {\n  \"Scope for aggregating capacity info - APPLICATION, ORGANIZATION, or FOUNDATION\"\n  aggregationScope: CapacityAggregationScope\n  \"Category of classification\"\n  classification: CapacityClassification!\n  \"Dimension to apply filter on\"\n  dimension: CapacityDimension!\n  \"Filter entities based on properties.CloudProvider\"\n  entityEnvironment: [String!]\n  \"Filter CapacityInfo by entities. Keep empty to fetch capacity info for all entities in scope\"\n  entityId: [EntityId!]\n  \"Filter entities based on labels\"\n  entityLabels: [String!]\n  \"Scope for querying capacity info - APPLICATION, DIEGO, or SELF\"\n  queryScope: CapacityQueryScope\n}\n\"Input filter for application vulnerabilities\"\ninput ComponentApplicationFilterInput {\n  \"Filter by component entity ID\"\n  componentEntityId: [String!]\n  \"Filter by entity EDS type\"\n  entityEdsType: [String!]\n  \"Filter by application entity ID\"\n  entityId: [String!]\n  \"Filter by entity name (contains match)\"\n  entityName: [String!]\n  \"Filter by entity TVS type\"\n  entityTvsType: [String!]\n}\n\"Input filter for component vulnerabilities\"\ninput ComponentFilterInput {\n  \"Filter by entity EDS type\"\n  entityEdsType: [String!]\n  \"Filter by entity name (contains match)\"\n  entityName: [String!]\n  \"Filter by entity TVS type\"\n  entityTvsType: [String!]\n  \"Filter by foundation group ID\"\n  foundationGroupId: [String!]\n  \"Filter by foundation group name (contains match)\"\n  foundationGroupName: [String!]\n  \"Filter by foundation ID\"\n  foundationId: [String!]\n  \"Filter by foundation name (contains match)\"\n  foundationName: [String!]\n  \"Filter by severity (HIGH, CRITICAL, or both)\"\n  severity: [ComponentVulnerabilitySeverity!]\n}\ninput ConversationalEventInput {\n  \"Return records after the given cursor, as per GraphQL Relay spec\"\n  after: String\n  \"Return records before the given cursor, as per GraphQL Relay spec\"\n  before: String\n  \"Only accepts ALL and LAST_N. BY_ID type not supported\"\n  filterType: ConversationalFilterType!\n  \"Return first N records in a paged response, as per GraphQL Relay spec\"\n  first: Int = 10\n  \"Defines the count for LAST_N conversational history type. If absent, lastN will default to 1 and fetch the LATEST event info\"\n  lastN: Int = 1\n  \"by default, all the stream events are fetched\"\n  onlyEndOfStreamEvents: Boolean = false\n}\n\"\"\"\nThis is how it works:\nThere are 4 levels : Sessions, Prompts, Streams and Events in the same order respectively.\nIn order to request for a certain level, input should be passed for that level and all the levels above it\nfor instance in order to request for streams; session, prompt and stream inputs should be passed\ntherefore session input should always be present to use this api\n\"\"\"\ninput ConversationalHistoryInput {\n  event: ConversationalEventInput\n  prompt: ConversationalPromptInput\n  session: ConversationalSessionInput!\n  stream: ConversationalStreamInput\n}\ninput ConversationalPromptFeedbackInput {\n  feedback: String\n  isPositive: Boolean!\n  promptId: Int!\n  sessionId: Int!\n}\ninput ConversationalPromptInput {\n  \"Return records after the given cursor, as per GraphQL Relay spec\"\n  after: String\n  \"Return records before the given cursor, as per GraphQL Relay spec\"\n  before: String\n  filterType: ConversationalFilterType!\n  \"Return first N records in a paged response, as per GraphQL Relay spec\"\n  first: Int = 10\n  \"Defines the count for LAST_N conversational history type. If absent, lastN will default to 1 and fetch the LATEST prompt info\"\n  lastN: Int = 1\n  \"Optional list of promptIds to filter a user's history. This is mandatory if ConversationalHistoryType = BY_ID\"\n  promptId: [Int!]\n}\n\"This input is to interrupt/stop an ongoing prompt in a user's conversation session\"\ninput ConversationalPromptInterruptInput {\n  promptId: Int!\n  sessionId: Int!\n}\ninput ConversationalSessionInput {\n  filterType: ConversationalFilterType!\n  \"Defines the count for LAST_N conversational history type. If absent, lastN will default to 1 and fetch the LATEST session info\"\n  lastN: Int = 1\n  \"Optional list of sessionIds to filter a user's history. This is mandatory if ConversationalHistoryType = BY_ID\"\n  sessionId: [Int!]\n}\n\"This input is to update existing conversationName for a user's session with the service\"\ninput ConversationalSessionUpdateInput {\n  conversationName: String!\n  sessionId: Int!\n}\ninput ConversationalStreamInput {\n  \"Return records after the given cursor, as per GraphQL Relay spec\"\n  after: String\n  \"Return records before the given cursor, as per GraphQL Relay spec\"\n  before: String\n  \"Only accepts ALL and LAST_N. BY_ID type not supported\"\n  filterType: ConversationalFilterType!\n  \"Return first N records in a paged response, as per GraphQL Relay spec\"\n  first: Int = 10\n  \"Boolean to fetch only streams which have ended. Not supported with LAST_N filter type\"\n  isEnded: Boolean\n  \"Defines the count for LAST_N conversational history type. If absent, lastN will default to 1 and fetch the LATEST stream info\"\n  lastN: Int = 1\n  \"Optionally filter the streams for prompts by payloadTypes\"\n  payloadType: [String!]\n  \"Optionally filter the streams for prompts by unique stream names\"\n  streamName: [String!]\n}\ninput DashboardBulkDeleteInput {\n  dashboardId: String!\n  nodeVersion: ID\n}\n\"\"\"\nInput filter parameters for filtering dashboards.\nIf multiple filter objects are specified they are treated as an and.\n\"\"\"\ninput DashboardFilter {\n  \"filter dashboard by category(s)\"\n  category: [String!]\n  dashboardId: [ID!]\n  \"filter dashboard by tags\"\n  tags: [DashboardTagFilter!]\n}\ninput DashboardInput {\n  \"category/subsystem to which the dashboard belongs\"\n  category: String!\n  \"unique identifier for dashboard, to be used for update operation\"\n  dashboardId: String\n  \"indicates if dashboard is visible at an org level or for a user\"\n  dashboardVisibility: DashboardVisibility\n  \"dashboard version, used for optimistic locking on updates.\"\n  nodeVersion: ID\n  \"Represents JSON payload containing all the dashboard widgets, max supported size : 2MB\"\n  payload: String!\n  \"\"\"\n  Array of entity IDs for SCOPED visibility dashboards.\n  Cannot be used together with scopingTypes\"\n  \"\"\"\n  scopingEntityIds: [EntityId!]\n  \"\"\"\n  scope types for SCOPED visibility dashboards.\n  dashboards scoped to a scope type will allow users having any permission of the scope type\n  Cannot be used together with scopingEntityIds\"\n  \"\"\"\n  scopingTypes: [DashboardScopeType!]\n  \"tags associated with the dashboard\"\n  tags: [DashboardTagInput!]\n}\ninput DashboardTagFilter {\n  \"tag key to filter by\"\n  key: String!\n  \"tag value to filter by (optional)\"\n  value: String\n}\ninput DashboardTagInput {\n  \"tag key input\"\n  key: String!\n  \"tag value input\"\n  value: String\n}\ninput DerivedDataCachingHintsInput {\n  \"Set to true to Avoid expensive recomputation of query results when exploring same data with different filters/aggregators\"\n  cacheAndReuseQueryResponse: Boolean = false\n}\ninput DerivedDataDocConfigInput {\n  \"Document name of the output file\"\n  documentName: String!\n  \"Document type of the output file\"\n  documentType: DerivedDataDocType!\n}\ninput DerivedDataPaginationInput {\n  \"Name of the query variable that configures the value of the `after` parameter for paging\"\n  afterVariableName: String!\n  \"Maximum number of paged elements to include in the output\"\n  maxRowCount: Int!\n  \"\"\"\n  JSON path to field that contains the list of elements to accumulate for the output.\n  \n  For example, in an entity query it might be `entityQuery.queryEntities.entities`\n  \"\"\"\n  pathToListOfRowElements: String!\n  \"\"\"\n  JSON path to pageInfo field in the result. Ex: entityQuery.queryEntities.pageInfo\n  It is mandatory to include hasNextPage` and `endCursor` fields in the query response. Query will fail to fetch\n  response in absence of these fields.\n  \"\"\"\n  pathToPageInfo: String!\n}\n\"\"\"\nDerived Data Processing Rules\nOnly one type of rules can be defined at once\n\"\"\"\ninput DerivedDataProcessingRulesInput {\n  \"\"\"\n  Processing rules may be expressed in [jmespath syntax](https://jmespath.org/)\n  \n  Note that rules can be daisy-chained in multiple steps which can make rule-writing simpler.\n  \n  This is only in an initial version of derived data query support and may be replaced with\n  strongly typed processing rules expressed in GraphQL.\n  \n  Recommendation to create your derived data processing rules in jmsepath:\n  1. Run the query with an empty jmesPathRules field\n  2. Copy the response into the [jmsepath tutorial as input](https://jmespath.org/tutorial.html)\n  3. Form your processing rules\n  4. Copy and paste these processing rules into your query's jmesPathRules field\n  \"\"\"\n  jmesPathRules: [String!]\n  \"\"\"\n  Processing rules may be expressed in [jsonata syntax](https://docs.jsonata.org/overview.html)\n  \n  Note that rules can be daisy-chained in multiple steps which can make rule-writing simpler.\n  \n  This is only in an initial version of derived data query support and may be replaced with\n  strongly typed processing rules expressed in GraphQL.\n  \n  Recommendation to create your derived data processing rules in jsonata:\n  1. Run the query with an empty jsonataRules field\n  2. Copy the response into the [jsonata query playground](https://try.jsonata.org/)\n  3. Form your processing rules\n  4. Copy and paste these processing rules into your query's jsonataRules field\n  \"\"\"\n  jsonataRules: [String!]\n}\n\"Manages document creation and attachment.\"\ninput DocumentOptions {\n  \"Identifies the entity that the subsequent Document will be attached to in the graph, defaults to the FileRelease entity if none supplied\"\n  attachToEntityId: EntityId\n  createDocument: Boolean!\n  \"Specifies the category of document to create\"\n  documentCategory: DocumentCategory\n}\ninput EntityAggregationInput {\n  \"Optional user-defined name for the aggregation\"\n  aggregationName: String\n  \"Aggregation type\"\n  aggregationType: EntityAggregationType = TERMS\n  \"\"\"\n  Field on which to aggregate\n  \n  The following format are supported for Entities:\n  \n  - `<topLevelFieldName>`\n  - `tag[s].key`\n  - `tag[s].value`\n  - `property.<propertyName>`\n  \n  To refer to fields from a namespace the above forms can all be prefixed with `namespace.<namespaceName>.`\n  \"\"\"\n  fieldName: String!\n  \"The type of the field, used for metric aggregations\"\n  fieldType: EntityAggregationFieldType\n  \"Limit number of buckets, if specified, top N buckets will be returned\"\n  maxBucketCount: Int\n  \"Optional sub-aggregations\"\n  subAggregations: [EntityAggregationInput!]\n}\ninput EntityQueryFilter {\n  \"Optionally filter by creation time range\"\n  creationTimeRange: EntityTimeRangeFilter\n  \"Optionally filter by entityIds\"\n  entityId: [EntityId!]\n  \"Optionally filter by this field\"\n  entityName: [String!]\n  \"Optionally filter by this field\"\n  entityType: [String!]\n  \"Optionally filter by entityTypes corresponding to the values from the enum (this can be used for its autocomplete functionality)\"\n  entityTypeConst: [EntityTypeConst!]\n  \"\"\"\n  Optional additional field filters.\n  \n  The field format is `[[namespaces.<namespace>.](properties.|tags.)]<fieldname>`\n  \"\"\"\n  filter: QueryFilter\n  \"Optionally filter by lastUpdate time range\"\n  lastUpdateTimeRange: EntityTimeRangeFilter\n  \"Optionally filter by cloud account endpoint(s)\"\n  managementEndpointId: [String]\n  \"Optionally filter by named partition(s)\"\n  partitionId: [EntityGraphPartitionNames]\n  \"Optionally filter by this field\"\n  provider: [String!]\n  \"Optionally filter by this field\"\n  region: [String!]\n  \"Optionally filter by this field\"\n  service: [String!]\n  \"Optionally filter by tags. AND is applied across different entries in the list\"\n  tags: [TagFilterInput!]\n}\ninput EntityRelationshipQueryFilter {\n  \"Optionally filter by creation time range\"\n  creationTimeRange: EntityTimeRangeFilter\n  \"Optionally filter by field\"\n  destEntityId: [EntityId!]\n  \"Optionally filter by field\"\n  destEntityType: [String!]\n  \"Optionally filter by entityTypes corresponding to the values from the enum (this can be used for its autocomplete functionality)\"\n  destEntityTypeConst: [EntityTypeConst!]\n  \"Optionally filter by lastUpdate time range\"\n  lastUpdateTimeRange: EntityTimeRangeFilter\n  \"Optionally filter by field\"\n  relationshipId: [String!]\n  \"Optionally filter by field\"\n  relationshipType: [String!]\n  \"Optionally filter by field\"\n  sourceEntityId: [EntityId!]\n  \"Optionally filter by field\"\n  sourceEntityType: [String!]\n  \"Optionally filter by entityTypes corresponding to the values from the enum (this can be used for its autocomplete functionality)\"\n  sourceEntityTypeConst: [EntityTypeConst!]\n  \"Filter by traversal scope\"\n  traversalScope: EntityTraversalScope = ANY_PARTITION\n}\ninput EntitySearchFilter {\n  creationTime: EntitySearchTimeFilter\n  \"Optionally filter by entityIds\"\n  entityId: [EntityId!]\n  entityName: [String!]\n  entityType: [String!]\n  \"Optionally filter by entityTypes corresponding to the values from the enum (this can be used for its autocomplete functionality)\"\n  entityTypeConst: [EntityTypeConst!]\n  lastUpdateTime: EntitySearchTimeFilter\n  managementEndpointId: [String!]\n  provider: [String!]\n  region: [String!]\n  searchInfo: EntitySearchInfo\n  service: [String!]\n  \"\"\"\n  Tags of entities. OR is used among values for the same key,\n  AND is used across multiple different keys.\n  \"\"\"\n  tags: [EntitySearchTag!]\n}\ninput EntitySearchInfo {\n  \"\"\"\n  case sensitivity of search. Note that certain top-level targetFields such as entityId will always be compared with case sensitivity,\n  ignoring this value.\n  \"\"\"\n  caseSensitive: Boolean = false @deprecated(reason: \"Case sensitivity is defined by field type. EntityIds are case-sensitive, other fields are case-insensitive\")\n  \"\"\"\n  The string to search for. A trailing '*' can be used for autocomplete matching.\n  If targetFields is not specified this performs a global search.\n  \"\"\"\n  search: String!\n  \"targetFields consists of top-level field names, 'entityTags' or 'properties.[name]' which can include wildcard '*'\"\n  targetFields: [String!]\n}\n\"Specify search parameters\"\ninput EntitySearchInput {\n  searchFilter: EntitySearchFilter!\n  sort: QuerySort\n  timeoutMillis: Int = 60000\n}\n\"Tags filter. OR is used among values for the same key, AND is used among multiple keys\"\ninput EntitySearchTag {\n  key: String!\n  values: [String!]\n}\n\"Allows callers to filter entities that were created or updated in a specific time range\"\ninput EntitySearchTimeFilter {\n  endTime: DateTime\n  startTime: DateTime\n}\ninput EntityTimeRangeFilter {\n  endTime: DateTime\n  startTime: DateTime\n}\ninput EntityTopologyGraphEdgeInput {\n  destinationNodeId: String!\n  edgeType: String\n  sourceNodeId: String!\n}\n\" The input versions of the above objects, since GraphQL doesn't allow the same type to be used as outputs and inputs.\"\ninput EntityTopologyGraphInput {\n  edges: [EntityTopologyGraphEdgeInput!]\n  nodes: [EntityTopologyGraphNodeInput!]\n}\ninput EntityTopologyGraphNodeInput {\n  entities: [EntityId!]\n  id: String!\n  layer: String\n  nodeType: String!\n  \" This field is to be used when the returned data types for this node are not entities. This will be unused in most cases.\"\n  totalCount: Int\n  values: [String!]\n}\ninput EntityTopologyInput {\n  \"\"\"\n  The entity ID of the anchor entity for which the topology is being computed. This field cannot be used in\n  conjunction with the graphQLQueries field below, as the graphQLQueries will implicit declare all the\n  entity IDs within it.\n  \"\"\"\n  entityId: EntityId\n  \"\"\"\n  The entity type of the anchor entity for which the topology is being computed. This field cannot be used in\n  conjunction with the graphQLQueries field below, as the graphQLQueries will implicit declare all the\n  entities within it.\n  \"\"\"\n  entityType: String\n  \"\"\"\n  A list of queries which will be processed for determine the output topology. Entities emitted as part of these\n  queries will be aggregated based on their entity types based on the entity type into nodes. Any entities which\n  share even a single edge between themselves will be aggregated to the node level. Nodes which share a single common\n  entity ID across these graphQLQueries will be collapsed into a single node.\n  This field cannot be used in conjunction with the above input parameters.\n  \"\"\"\n  graphQLQueries: [String!]\n  \"\"\"\n  The list of expanded layers of the topology within the above perspective. Examples of this include\n  Runtime, Infrastructure etc. The values provided here must be from the supported layers that are\n  present in the providerInfo response. This field cannot be used in conjunction with the graphQLQueries field.\n  \"\"\"\n  layers: [String!]\n  \"\"\"\n  The perspective that would you like to see for the above requested entity ID. Examples of this include\n  Logical, Platform, FullStack etc. The value provided here must be one of the supported perspectives\n  that are present in the providerInfo response. This field cannot be used in conjunction with the graphQLQueries\n  field.\n  \"\"\"\n  perspective: String\n  \"\"\"\n  Optional key/value tags for additional inputs. If the same tag key is repeated, the behavior is like an 'or'.\n  This field can be used to provide additional filters for the above combinations of inputs.\n  This field cannot be used in conjunction with the graphQLQueries field.\n  \"\"\"\n  tags: [TagInput!]\n}\n\"Entity Traversal Filter definition\"\ninput EntityTraversalFilterInput {\n  \"\"\"\n  Traversal to use for the filter.\n  The filter matches if a traversal is found, unless the NOT logicalOperator is used.\n  Only one of nestedFilters or entitiesTraversal must be specified.\n  \"\"\"\n  entitiesTraversal: [EntityTraversalInput!]\n  \"boolean operator to apply to the filter. Defaults to AND. Use NOT only when there is a single entitiesTraversal.\"\n  logicalOperator: EntityTraversalLogicalOperator = AND\n  \"\"\"\n  Optionally allows for more complex recursive filters such as\n  \"vm in cluster C1 AND in application A1\"\n  Only one of nestedFilters or entitiesTraversal must be specified.\n  \"\"\"\n  nestedFilters: [EntityTraversalFilterInput!]\n  \"\"\"\n  Deprecated equivalent to permitting logicalOperator NOT for a single filter.\n  Will override logicalOperator for entitiesTraversal if provided.\n  If set to true, filter passes if there is a matching traversal.\n  If set to false, filter passes if there are no matching traversals.\n  \"\"\"\n  retainIfMatch: Boolean\n}\n\"Input defining an entity graph traversal step\"\ninput EntityTraversalInput {\n  \"Optionally deduplicate the entities after this traversal\"\n  dedup: Boolean = true\n  \"Traversal direction\"\n  direction: EntityTraversalDirection!\n  \"Optionally filter by entityIds\"\n  entityId: [EntityId!]\n  \"Optionally filter by this field, support leading '!' (not) and trailing '*' (starts with)\"\n  entityName: [String!]\n  \"Optionally filter by this field, support leading '!' (not) and trailing '*' (starts with)\"\n  entityType: [String!]\n  \"Optional additional field filters\"\n  filter: QueryFilter\n  \"Optionally filter by this field, support leading '!' (not) and trailing '*' (starts with)\"\n  provider: [String!]\n  \"Optionally filter by this field, support leading '!' (not) and trailing '*' (starts with)\"\n  region: [String!]\n  \"Optionally filter traversal by one of the given relationship types, requires an exact match\"\n  relationshipType: [String!]\n  \"Optionally filter by this field, support leading '!' (not) and trailing '*' (starts with)\"\n  service: [String!]\n  \"Optionally specify whether the traversals should be constrained to same partition (cloud account id), can be used for optimizing some queries\"\n  traversalScope: EntityTraversalScope = ANY_PARTITION\n}\n\"\"\"\nSpecify optional recursion information for a traversal\n\nAn example usage is to recurse down to a maximum depth from a parent group to all its leaf-node members,\nwhere a group can contain other groups or other resources.\n\"\"\"\ninput EntityTraversalRecursionInfo {\n  \"Emit intermediate entities during traversal. If false, will traverse as far as possible and only emit 'leaf' nodes\"\n  emitIntermediateEntities: Boolean = true\n  \"Optional matching clause. If specified, the traversal will only return entities matching this filter in the recursion, otherwise it will emit all entities found while recursing\"\n  matching: EntityTraversalRecursionUntilInput\n  \"Maximum recursion depth. Currently limited to a max value of 5.\"\n  maxDepth: Int = 3\n}\n\"Input defining conditions to match to exit traversal recursion\"\ninput EntityTraversalRecursionUntilInput {\n  \"Optionally filter by entityIds\"\n  entityId: [EntityId!]\n  \"Optionally filter by this field, support leading '!' (not) and trailing '*' (starts with)\"\n  entityName: [String!]\n  \"Optionally filter by this field, support leading '!' (not) and trailing '*' (starts with)\"\n  entityType: [String!]\n  \"Optionally filter by entityTypes corresponding to the values from the enum (this can be used for its autocomplete functionality)\"\n  entityTypeConst: [EntityTypeConst!]\n  \"\"\"\n  Optional additional field filters to match for exiting traversal recursion\n  \n  The field format is `[[namespaces.<namespace>.](properties.|tags.)]<fieldname>`\n  \"\"\"\n  filter: QueryFilter\n  \"Optionally filter by this field, support leading '!' (not) and trailing '*' (starts with)\"\n  provider: [String!]\n  \"Optionally filter by this field, support leading '!' (not) and trailing '*' (starts with)\"\n  service: [String!]\n}\ninput EventGroupInput {\n  \"Namespace from which event groups needs to be returned\"\n  namespace: String!\n  \"Query logs by selecting fields via logical operators \"\n  queryFilter: QueryFilter\n  \"Event groups search window\"\n  queryTime: QueryTimeRangeFilter!\n  \"Specify sort by category\"\n  sortBy: EventGroupSortBy!\n  \"Optionally specify sort order\"\n  sortOrder: QuerySortOrder = DESC\n}\ninput EventInput {\n  \"Optionally aggregate logs using the specified function and field.\"\n  aggregation: LogAggregation\n  \"Optionally specify fields to be returned in event\"\n  fields: [String]\n  \"Optionally specify group by fields\"\n  groupBy: [String]\n  \"Optionally specify time interval of each bucket\"\n  groupByPeriodMillis: Long\n  \"Namespace from which events needs to be returned\"\n  namespace: String!\n  \"Query logs by selecting fields via logical operators \"\n  queryFilter: QueryFilter\n  \"Events search window\"\n  queryTime: QueryTimeRangeFilter!\n  \"Optionally specify sort order\"\n  sortOrder: QuerySortOrder = DESC\n}\ninput EventStatsInput {\n  \"Optionally specify time interval of each bucket\"\n  bucketIntervalInSeconds: Long!\n  \"Namespace from which event groups needs to be returned\"\n  namespace: String!\n  \"Query logs by selecting fields via logical operators \"\n  queryFilter: QueryFilter\n  \"Event stats search window\"\n  queryTime: QueryTimeRangeFilter!\n  \"Specify sort by category\"\n  sortBy: EventGroupSortBy!\n  \"Optionally specify sort order\"\n  sortOrder: QuerySortOrder = DESC\n}\n\"Input specifying changes or create to a notification rule\"\ninput EventsNotificationRuleInput {\n  \"Status of the Notification Rule\"\n  enabled: Boolean\n  \"The type of the event\"\n  eventType: EventsEventType!\n  \"\"\"\n  A [jsonata](https://docs.jsonata.org/overview.html) predicate to filter events based on their payload. The event is only sent to\n  the subscriber if this expression evaluates to `true`, otherwise it is skipped\n  \"\"\"\n  jsonataExpression: String\n  \"Name of the Notification Rule\"\n  name: String\n  \"Optional Unique identifier of the notification rule instance. Required when updating an existing notification rule\"\n  notificationRuleId: String\n  \"notification target list. Currently we only support one configured target per notification rule\"\n  notificationTargets: [String!]\n}\ninput ExceptionAggregation {\n  \"Field on which aggregation needs to be performed\"\n  field: String\n  type: ExceptionAggregationType!\n}\ninput ExceptionGroupInput {\n  namespace: String!\n  queryTime: QueryTimeRangeFilter!\n  sortBy: ExceptionGroupSortBy!\n  sortOrder: QuerySortOrder = DESC\n}\n\"Filters for querying exceptions\"\ninput ExceptionInput {\n  \"Optionally aggregate exceptions using the specified function and field.\"\n  aggregation: ExceptionAggregation\n  \"Optionally specify group by fields\"\n  groupBy: [String]\n  \"Time interval of each bucket\"\n  groupByPeriodMillis: Long\n  \"Namespace from which exceptions needs to be returned\"\n  namespace: String!\n  \"Query exceptions by selecting fields via logical operators \"\n  queryFilter: QueryFilter\n  \"Start and end time\"\n  queryTime: QueryTimeRangeFilter!\n  \"Optionally specify sort order\"\n  sortOrder: QuerySortOrder = DESC\n}\ninput ExceptionStatsInput {\n  namespace: String!\n  queryTime: QueryTimeRangeFilter!\n  sortBy: ExceptionGroupSortBy!\n  sortOrder: QuerySortOrder = DESC\n}\ninput ExceptionTrendInput {\n  base: QueryTimeRangeFilter!\n  current: QueryTimeRangeFilter!\n  namespace: String!\n}\n\"Input for validating component values.\"\ninput FleetComponentValueValidationInput {\n  \"The type of the component to validate.\"\n  componentType: String!\n  \"Additional context information for validation.\"\n  context: JsonNodeScalar\n  \"The version of the component (optional).\"\n  version: String\n}\n\"Input for creating a new fleet template execution.\"\ninput FleetTemplateExecutionCreateInput {\n  \"The JSON resources required for this execution.\"\n  components: FleetManagementJsonScalar!\n  \"An optional description for this execution.\"\n  description: String\n  \"The unique identifier of the fleet template to execute.\"\n  templateId: String!\n}\n\"Input for updating an existing fleet template.\"\ninput FleetTemplateUpdateInput {\n  \"The new JSON resources for the fleet template.\"\n  components: FleetManagementJsonScalar\n  \"The new description for the fleet template.\"\n  description: String\n  \"The new name for the fleet template.\"\n  name: String\n  \"The unique identifier of the fleet template to update.\"\n  templateId: String!\n  \"The new UI schema content for the fleet template.\"\n  uiSchema: FleetManagementJsonScalar\n}\n\"\"\"\nInput for assigning a foundation to a foundation group.\nContains the management endpoint details and the target scoping entity.\n\"\"\"\ninput GroupAssignFoundationToGroupInput {\n  \"Name of the foundation management endpoint.\"\n  endpointName: String!\n  \"\"\"\n  Management endpoint ID of the foundation to be assigned.\n  This corresponds to the foundation management endpoint identifier.\n  \"\"\"\n  managementEndpointId: String!\n  \"\"\"\n  Scoping entity ID that represents the foundation group.\n  This should be the entity ID of the foundation group to which the foundation will be assigned.\n  Optional: If not provided, the foundation will be unassigned from any current foundation group.\n  \"\"\"\n  scopingEntityId: EntityId\n}\ninput GroupFoundationGroupCreateInput {\n  \"Optional description of the Foundation Group to be created\"\n  description: String\n  \"Name of the Foundation Group to be created. The name needs to be unique.\"\n  name: String!\n}\ninput GroupFoundationGroupUpdateInput {\n  \"Optionally update the description of Foundation Group\"\n  description: String\n  \"Entity Id of the FoundationGroup entity\"\n  foundationGroupId: EntityId!\n  \"Optionally update the name of Foundation Group\"\n  name: String\n}\ninput GroupOrganizationGroupCreateInput {\n  \"Optional description of the Organization Group to be created\"\n  description: String\n  \"Entity Ids of the FoundationGroups with which the Org Group is associated\"\n  foundationGroupIds: [EntityId!]!\n  \"Name of the Organization Group to be created. Needs to be unique\"\n  name: String!\n}\ninput GroupSpaceGroupCreateInput {\n  \"Optional description of the Space Group to be created\"\n  description: String\n  \"Optional list of foundation names to associate with the Space Group\"\n  foundations: [String!]\n  \"Name of the Space Group to be created. The name needs to be unique.\"\n  name: String!\n  \"Entity Id of the OrgGroup entity\"\n  orgGroupEntityId: EntityId!\n}\ninput HubArtifactSBOMFilterInput {\n  \"Name of the package\"\n  name: [String!]\n  \"Version of the package\"\n  version: [String!]\n}\ninput HubArtifactScoreRangeInput {\n  \"filter vulnerabilities with cvssScoreV3 less than or equal to max, valid values : 0.0 to 10.0\"\n  max: Float\n  \"filter vulnerabilities with cvssScoreV3 greater than or equal to min, valid values : 0.0 to 10.0\"\n  min: Float\n}\ninput HubArtifactVulnerabilityFilterInput {\n  \"filter vulnerability by CVE ID\"\n  cveId: [String!]\n  \"filter vulnerability by CVSS score\"\n  score: HubArtifactScoreRangeInput\n  \"filter vulnerability by severity. Will accept values CRITICAL, HIGH, MEDIUM, LOW, NONE\"\n  severity: [String!]\n}\n\"Input details to delete/disable/enable the policy\"\ninput HubPolicyIdInput {\n  \"Version\"\n  nodeVersion: ID!\n  \"Policy id\"\n  policyId: String!\n}\n\"Input parameter for insights query\"\ninput InsightFilter {\n  \"Query Insight based on the title of insights\"\n  descriptionContains: String\n  \"Filter by insights active before the given endTime. Note: Expressed in UTC ISO-8601 timestamp\"\n  endTime: DateTime @deprecated(reason: \"Use QueryFilter for time based filtering\")\n  \"Filter insights by entities\"\n  entityId: [EntityId!]\n  \"Query Insight based on the entity type\"\n  entityType: [String!]\n  \"Include insights from findings, default: false\"\n  findingInsights: Boolean! = false\n  \"Query Insight based on the observation count range e.g [0, 5], [5, 10]\"\n  observationCountRange: [Int!] @deprecated(reason: \"Use QueryFilter with field 'totalObservationCount' instead.\")\n  \"If set to true only return insights with with faulty observation\"\n  observationIsFault: Boolean! = false\n  \"Query Insight based on the name of the observation\"\n  observationNameContains: String @deprecated(reason: \"Only insight name/describtion filtering supported\")\n  \"Query Insight based on the observation resource types\"\n  observationResourceKinds: [String!] @deprecated(reason: \"Use resourceKinds instead.\")\n  \"\"\"\n  If set to true returns insights originating at the entity, otherwise returns insights impacting entity.\n  entityId field is used for filtering with this flag\n  \"\"\"\n  originating: Boolean! = false\n  \"Query Insight based on the resource types\"\n  resourceKinds: [String!]\n  \"Query Insight based on the source of the observation\"\n  source: [ObservationSource!]\n  \"Filter by insights active after the given startTime. Note: Expressed in UTC ISO-8601 timestamp\"\n  startTime: DateTime @deprecated(reason: \"Use QueryFilter for time based filtering\")\n  \"Include insights with matching tag search criteria\"\n  tagSearch: InsightTagSearchCriteria\n}\ninput InsightNotificationCriteriaInput {\n  \"Impacted Service / Application\"\n  impactedServices: [String]\n  \"This is the originatingEntity of the Insight\"\n  resource: String\n  \"based on the severity of the insight\"\n  severities: [InsightSeverity]\n  \"can be a list of source from AWS/Azure etc\"\n  sources: [ObservationSource]\n  \"based on the status of the Insight\"\n  statuses: [InsightStatus]\n}\n\"Input parameter for insights notification rules query\"\ninput InsightNotificationRuleFilter {\n  \"Query Notification Rules if notification criteria has impacted app names specified\"\n  impactedServiceAsCriteria: [String!]\n  \"Query Notification Rules based on the Notification Target Type (email/slack..)\"\n  notificationTargetIdContains: String\n  \"Query Notification Rules if notification criteria has insight severity specified\"\n  severityAsCriteria: [InsightSeverity!]\n  \"Query Notification Rules if notification criteria has one or more source specified\"\n  sourceAsCriteria: [ObservationSource!]\n  \"Query Notification Rules if notification criteria has insight status specified\"\n  statusAsCriteria: [InsightStatus!]\n}\n\"Input specifying changes or create to a notification rule\"\ninput InsightNotificationRuleInput {\n  \"Filter criteria for notification\"\n  criteria: InsightNotificationCriteriaInput\n  \"Emails to be notified in case of email target\"\n  emailAddresses: [String!]\n  \"Status of the Notification Rule\"\n  enabled: Boolean\n  \"Name of the Notification Rule\"\n  name: String\n  \"Optional Unique identifier of the notification rule instance. Required when updating an existing notification rule\"\n  notificationRuleId: String\n  \"notification target list. Currently we only support one configured target per notification rule\"\n  notificationTargets: [String!]\n  \"Optional Slack channel in case of slack target\"\n  slackChannel: String\n}\n\"Find Insight has specified tag key and optionally with specified values\"\ninput InsightTagSearchCriteria {\n  tagKey: String!\n  tagValues: [String!]\n}\ninput LicenseApplyToFoundationsInput {\n  \" List of foundation Ids \"\n  foundationIds: [String]!\n  \" The license id \"\n  licenseId: String!\n}\ninput LogAggregation {\n  \"Field on which aggregation needs to be performed\"\n  field: String\n  type: LogAggregationType!\n}\n\"Filters for querying logs\"\ninput LogInput {\n  \"Optionally aggregate logs using the specified function and field.\"\n  aggregation: LogAggregation\n  \"End time\"\n  endTime: DateTime\n  \"Fields to be returned in log message\"\n  fields: [String]\n  \"Optionally specify group by fields\"\n  groupBy: [String]\n  \"Time interval of each bucket\"\n  groupByPeriodMillis: Long\n  \"Namespace from which logs needs to be returned\"\n  namespace: String!\n  \"Query logs by selecting fields via logical operators \"\n  queryFilter: QueryFilter\n  \"Log search window\"\n  queryTime: QueryTimeRangeFilter\n  \"Optionally specify sort order\"\n  sortOrder: QuerySortOrder = DESC\n  \"Start time\"\n  startTime: DateTime\n}\n\"Filters for querying log patterns\"\ninput LogPatternInput {\n  \"Base log search window\"\n  base: QueryTimeRangeFilter\n  \"Current log search window\"\n  current: QueryTimeRangeFilter\n  \"Time interval of each bucket returned in stats\"\n  groupByPeriodMillis: Long\n  \"Namespace from which logs needs to be returned\"\n  namespace: String!\n  \"Query logs by selecting fields via logical operators \"\n  queryFilter: QueryFilter\n  \"Sort by TREND or COUNT\"\n  sortBy: LogPatternSortBy = TREND\n  \"Optionally specify sort order\"\n  sortOrder: QuerySortOrder = DESC\n}\n\"Account Owner Information - Name and Email ID\"\ninput ManagementEndpointAccountOwnerInfoInput {\n  \"Email ID of the account owner\"\n  email: String!\n  \"Name of the account owner\"\n  name: String\n}\ninput ManagementEndpointAggregationInput {\n  \"Aggregation type\"\n  aggregationType: ManagementEndpointAggregationType = TERMS\n  \"Field on which to aggregate\"\n  fieldName: String!\n  \"Limit number of buckets, if specified, top N buckets will be returned\"\n  maxBucketCount: Int\n  \"Optional sub-aggregations\"\n  subAggregations: [ManagementEndpointAggregationInput!]\n}\ninput ManagementEndpointCollectorDeploymentPropertyInput {\n  name: String!\n  value: Object!\n}\n\"\"\"\n A Management endpoint collector is associated to a given management endpoint\nand Management endpoint collector can attach either self or managed by managed boolean flag.\n\"\"\"\ninput ManagementEndpointCollectorInput {\n  \" Type of the collector \"\n  collectorType: ManagementEndpointCollectorType\n  \" Location of the collector \"\n  location: String!\n  \" Boolean value indicates managed in case of true and self otherwise \"\n  managed: Boolean!\n  \" Management endpoint AWS/Azure/etc for which this collector should be attached to.\"\n  managementEndpointId: String!\n  \" Management endpoint type \"\n  managementEndpointType: ManagementEndpointType!\n  \" Display name of the collector \"\n  name: String!\n  \" Kubernetes version \"\n  version: String!\n}\ninput ManagementEndpointCollectorQueryFilter {\n  \" filter by management endpoint collector status Online/Offline/NA \"\n  managementEndpointCollectorHealthStatus: [ManagementEndpointCollectorHealthStatus!]\n  \" filter by management endpoint collector status Discovered/Ready/Pending \"\n  managementEndpointCollectorStatus: [ManagementEndpointCollectorStatus!]\n  \" filter by management endpoint ID(s) \"\n  managementEndpointId: [ID!]\n  \" filter by management endpoint collector names \"\n  name: [String!]\n}\n\"\"\"\n A credential broker creation request, which would provide yaml, script, brokerId and access key\nfor deployment of broker \n\"\"\"\ninput ManagementEndpointCredentialBrokerInput {\n  \" Short description of Credential broker \"\n  description: String\n  \" Display name of Credential broker \"\n  name: String!\n}\ninput ManagementEndpointCredentialMappingInput {\n  \"Management Endpoint Credential ID.\"\n  managementEndpointCredentialId: ID!\n  \"Management Endpoint ID.\"\n  managementEndpointId: ID!\n}\n\" Management Endpoint Credential Mapping Request \"\ninput ManagementEndpointCredentialMappingRequest {\n  \" Action to be performed on the management endpoint credential mapping \"\n  action: ManagementEndpointResourceAction!\n  \" Management Endpoint Credential Mapping Input \"\n  managementEndpointCredentialMapping: ManagementEndpointCredentialMappingInput!\n}\n\" Management Endpoint Credential Request \"\ninput ManagementEndpointCredentialRequest {\n  \" Action to be performed on the management endpoint credential \"\n  action: ManagementEndpointResourceAction!\n  \" In case of CREATE and UPDATE, provide ManagementEndpointCredentialsInput \"\n  managementEndpointCredential: ManagementEndpointCredentialsInput\n  \" In case of DELETE, provide managementEndpointCredentialId \"\n  managementEndpointCredentialId: String\n}\n\"Filters for fetching credential usages for a given management endpoint\"\ninput ManagementEndpointCredentialUsageFilter {\n  \"Use category parameter to fetch credential usages only for given categories, otherwise usages for all categories would be fetched\"\n  category: [String!]\n  \"Use permissionType parameter to fetch credential usages for credentials of given permission types, otherwise usages for all permission types would be fetched\"\n  permissionType: [ManagementEndpointCredentialPermissionType!]\n  \"Use source parameter to fetch credential usages only for provided sources, otherwise usages for all sources would be fetched\"\n  source: [String!]\n  \"Use time range parameter to fetch credential usages during provided time range, otherwise only latest usages for each source-category-sub-category combination would be fetched\"\n  timeRange: ManagementEndpointTimeRangeFilter\n  \"Use usageStatus parameter to fetch credential usages only in provided statuses, otherwise usages in all statuses would be fetched\"\n  usageStatus: [ManagementEndpointCredentialUsageStatus!]\n}\n\"Credential - holds credential information that can be used to access one or more cloud accounts.\"\ninput ManagementEndpointCredentialsInput {\n  \"User specified name for the credential\"\n  credentialName: String!\n  \"Credential Type could be user credential/Auth token/Certificate.\"\n  credentialType: ManagementEndpointCredentialType!\n  \"\"\"\n  Opaque global identifier of endpoint credentials. In case of an existing record, the ID will be used to identify\n  the credentials otherwise the record will be created with a generated opaque ID\n  \"\"\"\n  id: ID @deprecated(reason: \"'id' is being renamed as 'managementEndpointCredentialId'. The value of 'id' will be replaced with the NodeId of the credential.\")\n  \"Public identifier of this management endpoint credential\"\n  managementEndpointCredentialId: ID\n  \"\"\"\n  This defines the permission type of the credential.\n  Permissions are set based on the usage of the credential.\n  \"\"\"\n  permissionType: ManagementEndpointCredentialPermissionType = COLLECTION\n  \"\"\"\n  List of properties supported for the credential.\n  User Credential has properties userName and password\n  \"\"\"\n  properties: [ManagementEndpointPropertyInput!]!\n  \"This defines the permission scopes of the credential.\"\n  scopes: [ManagementEndpointCredentialScope!]\n  \"Tags associated with the credential.\"\n  tags: [TagInput!]\n}\n\"Query filter for management endpoint and credential definition queries\"\ninput ManagementEndpointDefinitionQueryFilter {\n  \"Property definition filter\"\n  propertyDefinition: ManagementEndpointPropertyDefinitionFilter\n}\ninput ManagementEndpointDeployToCloudProxyAgentInput {\n  \"Cloud proxy agent entity ID\"\n  cloudProxyAgentEntityId: EntityId!\n  \"List of management endpoint credential IDs\"\n  managementEndpointCredentialId: [ID!]\n  \"Management endpoint ID\"\n  managementEndpointId: ID!\n  \"Management endpoint type\"\n  managementEndpointType: String\n}\ninput ManagementEndpointDiscoveredAccountInput {\n  \"Management endpoint used to administer the organisation\"\n  administrativeEndpointId: String\n  \"Return records after the given cursor.\"\n  after: String\n  \"\"\"\n  Query accounts that are members of one or more account groups.\n  For a tree query, this can be used to expand one or more tree nodes. Leave null to start at the accounts' root\n  \"\"\"\n  baseAccountTreeNodeId: [String!]\n  \"Return records before the given cursor. Applicable only for LIST response format.\"\n  before: String\n  \"Credential to fetch the Azure or GCP account(s) hierarchy.\"\n  credential: ManagementEndpointCredentialsInput\n  \"Credential ID to fetch the Azure or GCP account(s) hierarchy.\"\n  credentialId: String\n  \"Returns tree only up to given depth. Applicable only to TREE and FLATTENED_TREE response formats. Currently depth cannot be more than 5\"\n  depth: Int = 1\n  \"Management endpoint type\"\n  endpointType: ManagementEndpointType!\n  \"Limit the number of entries in response to the first N.  For tree responses, this will return the first N from each level.\"\n  first: Int = 10\n  \"Response format\"\n  responseFormat: ManagementEndpointDiscoveredAccountResponseFormat!\n}\n\"\"\"\nA management endpoint is an abstraction of the place to which to connect to monitor/manage a system.\n\nIn the public cloud world this can be considered as an \"account\" (AWS), \"subscription\" (Azure), or \"project\" (GCP).\n\nIn the on-prem vCenter / VMX world a management endpoint can refer to a vCenter or NSX-Manager instance and its URL.\n\nIn order to support other management endpoints in the future, the management endpoint is considered a point through\nwhich a system, with its discovered entities, can be monitored and/or managed.\n\"\"\"\ninput ManagementEndpointInput {\n  \"Account Owner Information - Name and Email ID\"\n  accountOwnerInfo: ManagementEndpointAccountOwnerInfoInput\n  \"Credential ID to be mapped to this endpoint\"\n  credentialId: ID\n  \"User specified name for the endpoint\"\n  endpointName: String!\n  \"Endpoint Type can be vCenter/NSX-T etc.\"\n  endpointType: ManagementEndpointType!\n  \"Environment in which cloud account is onboarded\"\n  environment: String\n  \"Identifier of management endpoints\"\n  id: ID\n  \"\"\"\n  Management Endpoint ID,\n  For updating an existing record, the correct ID needs to be provided.\n  \"\"\"\n  managementEndpointId: String\n  \"List of properties supported for the endpoint\"\n  properties: [ManagementEndpointPropertyInput!]!\n  \" Regenerate Lemans access key\"\n  regenerateAccessKey: Boolean = false\n  \"Scoped Entity Ids to be associated with the endpoint \"\n  scopingEntityIds: [EntityId!]\n  \"\"\"\n  Tags associated with the endpoint.\n  For adding a new tag to the existing tags or updating the value of an existing tag, please provide the new tag along with the existing tags.\n  For removing all the existing tags, please set the tags to [].\n  \"\"\"\n  tags: [TagInput!]\n}\ninput ManagementEndpointOnboardingInfoInput {\n  \" List of Management Endpoint IDs that are configured \"\n  managementEndpointIds: [String!]!\n  \" Version of script \"\n  scriptVersion: String!\n  \" List of services that are configured \"\n  services: [ManagementEndpointDefinitionServiceName!]\n}\n\"Query filter for management endpoint and credential property definitions\"\ninput ManagementEndpointPropertyDefinitionFilter {\n  \"List of services for which property definitions should be returned\"\n  service: [ManagementEndpointDefinitionServiceName!]\n}\ninput ManagementEndpointPropertyInput {\n  \"Name of the property.\"\n  name: String!\n  \"Value of the property.\"\n  value: Object\n}\n\" TODO extend filter with other fields, also add and implement for queryManagementEndpoints\"\ninput ManagementEndpointQueryFilter {\n  \"filter by creationTime\"\n  creationTime: ManagementEndpointTimeRangeFilter\n  \"filter by endpoint name(s)\"\n  endpointName: [String!]\n  \"filter by Management Endpoint Type\"\n  endpointType: ManagementEndpointType\n  \"filter by endpoint ID(s)\"\n  id: [ID!]\n  \"filter by lastUpdateTime\"\n  lastUpdateTime: ManagementEndpointTimeRangeFilter\n  \"filter by Management Endpoint Types\"\n  managementEndpointType: [ManagementEndpointType!]\n  \"filter by providers\"\n  providers: [String!]\n  \"filter by root account Ids\"\n  rootAccountIds: [String!]\n}\n\" Management Endpoint Request \"\ninput ManagementEndpointRequest {\n  \" Action to be performed on the management endpoint \"\n  action: ManagementEndpointResourceAction!\n  \" In case of CREATE and UPDATE, provide ManagementEndpointInput \"\n  managementEndpoint: ManagementEndpointInput\n  \" In case of DELETE, provide managementEndpointId \"\n  managementEndpointId: String\n}\n\" A self managed Management endpoint collector is associated to a given management endpoint.\"\ninput ManagementEndpointSelfManagedCollectorInput {\n  collectorConfigProperties: [ManagementEndpointPropertyInput!]\n  \" Display name of the collector \"\n  collectorName: String!\n  \" Type of the collector \"\n  collectorType: ManagementEndpointCollectorType\n  deploymentProperties: [ManagementEndpointCollectorDeploymentPropertyInput!]\n  \" Regenerate Lemans access key\"\n  regenerateAccessKey: Boolean = false\n}\ninput ManagementEndpointTimeRangeFilter {\n  endTime: DateTime!\n  startTime: DateTime!\n}\n\" Cloud account onboarding request. It will create/update the cloud account with provided account and credential details \"\ninput ManagementEndpointUpsertWithCredentialInput {\n  \" Cloud credential details \"\n  credential: ManagementEndpointCredentialsInput!\n  \" Cloud account details \"\n  endpoint: ManagementEndpointInput!\n}\n\" vCenter/vROps credential input \"\ninput ManagementEndpointValidateCredentialInput {\n  \"List of properties supported for the credential\"\n  credentialProperties: [ManagementEndpointPropertyInput!]!\n  \"Credential Type could be user credential/Auth token/Certificate\"\n  credentialType: ManagementEndpointCredentialType!\n  \"List of properties supported for the endpoint\"\n  endpointProperties: [ManagementEndpointPropertyInput!]!\n}\ninput OAuthAppCreateInput {\n  \"Time in seconds to access token expiration after it is issued\"\n  accessTokenTTLSecs: Int = 1800\n  \"Optional Description for the OAuth App\"\n  description: String\n  \"List of grant types that can be used to obtain a token with this OAuth App. Defaults to CLIENT_CREDENTIALS\"\n  grantTypes: [OAuthAppGrantType] = [CLIENT_CREDENTIALS]\n  \"The name of the OAuth App\"\n  name: String!\n  \"Optional scope boundary for the OAuth App. If no value is specified, the OAuth App will have global access.\"\n  scopingEntityId: EntityId\n}\ninput OAuthAppRotateSecretInput {\n  \"OAuth App id whose secret needs to be changed\"\n  oauthAppId: String!\n  \"\"\"\n  The time in seconds after which the rotated secret expires.\n  After this period, the old secret will no longer be valid for authentication.\n  If the value is less than 60, the old secret will be removed immediately\n  Default value: 172800 seconds (48 hours).\n  \"\"\"\n  secretRotationExpirationInSeconds: Int = 172800\n}\ninput OAuthAppTokenInput {\n  \"Id of the OAuth App for which the client credential token is requested\"\n  oauthAppId: String!\n  \"Secret of the OAuth App for which the client credential token is requested\"\n  oauthAppSecret: String!\n}\ninput OAuthAppUpdateInput {\n  \"Time in seconds to access token expiration after it is issued\"\n  accessTokenTTLSecs: Int\n  \"Optional Description for the OAuth App\"\n  description: String\n  \"The name of the OAuth App\"\n  name: String\n  oauthAppId: String!\n}\n\"Observability Alert provider filer input\"\ninput ObservabilityAlertFilterInput {\n  \"Alert evaluation status\"\n  alertStatus: ObservabilityAlertStatus\n  \"Observability Alert type, ex: METRIC, LOG\"\n  alertType: ObservabilityAlertType\n  \"Filter Alerts by createdBy\"\n  createdBy: String\n  \"Filter Alerts based on whether schedule is enabled or not\"\n  enabled: Boolean\n  \"Filter alerts based on entity ID\"\n  entityId: [String!]\n  \"Filter alerts based on entity type\"\n  entityType: [String!]\n  \"Filter Alerts by name\"\n  name: [String!]\n  \"Filter Alerts by Id(use policyId)\"\n  policyId: [String!]\n  \"Template ID of the observability alert runbook\"\n  runbookTemplateId: String\n  \"Filter Alerts Source of the alert\"\n  source: String\n  \"Observability Alert Threshold type, ex: STATIC, DYNAMIC\"\n  thresholdType: ObservabilityAlertThresholdType\n  \"Filter Alerts by updatedBy\"\n  updatedBy: String\n}\n\"Input for basic authentication\"\ninput ObservabilityAlertManagerBasicAuthInput {\n  \"Password\"\n  password: String!\n  \"Username or identity\"\n  username: String!\n}\n\"Input for email notification configuration\"\ninput ObservabilityAlertManagerEmailConfigInput {\n  \"Authentication password secret\"\n  authPassword: ObservabilityAlertManagerSecretInput\n  \"Authentication secret\"\n  authSecret: ObservabilityAlertManagerSecretInput\n  \"Email configuration as YAML string\"\n  receiverConfig: String!\n  \"Name of the receiver\"\n  receiverName: String!\n  \"TLS configuration\"\n  tlsConfig: ObservabilityAlertManagerTlsConfigInput\n}\n\"Input for HTTP configuration\"\ninput ObservabilityAlertManagerHttpConfigInput {\n  \"Basic authentication configuration\"\n  basicAuth: ObservabilityAlertManagerBasicAuthInput\n  \"Bearer token secret\"\n  bearerToken: ObservabilityAlertManagerSecretInput\n  \"TLS configuration\"\n  tlsConfig: ObservabilityAlertManagerTlsConfigInput\n}\n\"Input for PagerDuty notification configuration\"\ninput ObservabilityAlertManagerPagerDutyConfigInput {\n  \"HTTP configuration\"\n  httpConfig: ObservabilityAlertManagerHttpConfigInput\n  \"PagerDuty configuration as YAML string\"\n  receiverConfig: String!\n  \"Name of the receiver\"\n  receiverName: String!\n  \"PagerDuty routing key secret\"\n  routingKey: ObservabilityAlertManagerSecretInput\n  \"PagerDuty service key secret\"\n  serviceKey: ObservabilityAlertManagerSecretInput\n}\n\"Input for receivers configuration\"\ninput ObservabilityAlertManagerReceiversConfigInput {\n  \"Email notification configurations\"\n  emailConfigs: [ObservabilityAlertManagerEmailConfigInput!]\n  \"PagerDuty notification configurations\"\n  pagerdutyConfigs: [ObservabilityAlertManagerPagerDutyConfigInput!]\n  \"Slack notification configurations\"\n  slackConfigs: [ObservabilityAlertManagerSlackConfigInput!]\n  \"Webhook notification configurations\"\n  webhookConfigs: [ObservabilityAlertManagerWebhookConfigInput!]\n}\n\"Input for secret configuration\"\ninput ObservabilityAlertManagerSecretInput {\n  \"The secret value\"\n  secret: String!\n}\n\"Input for Slack notification configuration\"\ninput ObservabilityAlertManagerSlackConfigInput {\n  \"HTTP configuration\"\n  httpConfig: ObservabilityAlertManagerHttpConfigInput\n  \"Slack configuration as YAML string\"\n  receiverConfig: String!\n  \"Name of the receiver\"\n  receiverName: String!\n  \"Slack API URL secret\"\n  slackApiUrl: ObservabilityAlertManagerSecretInput\n}\n\"Input for time interval configuration\"\ninput ObservabilityAlertManagerTimeIntervalInput {\n  \"Configuration as YAML string\"\n  timeIntervalConfig: String!\n  \"Name of the time interval\"\n  timeIntervalName: String!\n}\n\"Input for TLS certificates\"\ninput ObservabilityAlertManagerTlsCertificatesInput {\n  \"Certificate in PEM format\"\n  certPem: String!\n  \"Private key in PEM format\"\n  privateKeyPem: String!\n}\n\"Input for TLS configuration\"\ninput ObservabilityAlertManagerTlsConfigInput {\n  \"Certificate Authority certificate\"\n  ca: String\n  \"Skip certificate verification\"\n  insecureSkipVerify: Boolean\n  \"Server name for verification\"\n  serverName: String\n  \"TLS certificates configuration\"\n  tlsCertificates: ObservabilityAlertManagerTlsCertificatesInput\n}\n\"Input for webhook notification configuration\"\ninput ObservabilityAlertManagerWebhookConfigInput {\n  \"HTTP configuration\"\n  httpConfig: ObservabilityAlertManagerHttpConfigInput\n  \"Webhook configuration as YAML string\"\n  receiverConfig: String!\n  \"Name of the receiver\"\n  receiverName: String!\n}\ninput ObservabilityAlertNotificationCriteriaInput {\n  \"based on the name of the Observability Alert\"\n  name: String\n  \"This is the originatingEntity of the Observability Alert\"\n  resource: String\n  \"based on the severity of the Observability Alert\"\n  severities: [InsightSeverity]\n  \"can be a list of source from AWS/Azure etc\"\n  sources: [ObservationSource]\n  \"based on the status of the Observability Alert\"\n  statuses: [ObservationStatus]\n}\n\"Input parameter for observability alerts notification rules query\"\ninput ObservabilityAlertNotificationRuleFilter {\n  \"Query Notification Rules if notification criteria has observability alert name specified\"\n  nameAsCriteria: String\n  \"Query Notification Rules based on the Notification Target Type (email/slack..)\"\n  notificationTargetIdContains: String\n  \"Query Notification Rules if notification criteria has observability alert  originating resource name specified\"\n  resourceAsCriteria: String\n  \"Query Notification Rules if notification criteria has observability alert severity specified\"\n  severityAsCriteria: [InsightSeverity!]\n  \"Query Notification Rules if notification criteria has one or more source specified\"\n  sourceAsCriteria: [ObservationSource!]\n  \"Query Notification Rules if notification criteria has observability alert status specified\"\n  statusAsCriteria: [ObservationStatus!]\n}\n\"Input specifying changes or create to a notification rule\"\ninput ObservabilityAlertNotificationRuleInput {\n  \"Filter criteria for notification\"\n  criteria: ObservabilityAlertNotificationCriteriaInput\n  \"Emails to be notified in case of email target\"\n  emailAddresses: [String!]\n  \"Status of the Notification Rule\"\n  enabled: Boolean\n  \"Name of the Notification Rule\"\n  name: String\n  \"Optional Unique identifier of the notification rule instance. Required when updating an existing notification rule\"\n  notificationRuleId: String\n  \"notification target list. Currently we only support one configured target per notification rule\"\n  notificationTargets: [String!]\n  \"Policy IDs. Multiple policy IDs will be present in input only in case of bulk update of alerts, for linking all selected alerts with notification rules\"\n  policyIds: [String!]\n  \"Optional Slack channel in case of slack target\"\n  slackChannel: String\n}\ninput ObservabilityAlertNotificationTemplateInput {\n  \"Notification target identifier to which the notification template content is associated\"\n  notificationTargetId: String!\n  \"Content for notification template\"\n  notificationTemplate: String!\n  \"Notification template type\"\n  notificationTemplateType: ObservabilityNotificationTemplateType!\n}\ninput ObservabilityAlertOverrideRuleInput {\n  \"Hub entity name which needs override\"\n  labelName: String!\n  \"Entity values which needs to be applied for override\"\n  labelValues: [String!]\n  \"This will define an unique name to a override rule\"\n  ruleName: String!\n  \"alert tags\"\n  tags: [TagInput]\n  \"Override values which will be applied for defined entities\"\n  threshold: ObservabilityAlertThresholdConditionInput!\n}\n\"Observability Alert Input to update status.\"\ninput ObservabilityAlertStatusUpdateInput {\n  \"alert type\"\n  alertType: ObservabilityAlertType!\n  \"List of alerts to enable/disable\"\n  input: [HubPolicyIdInput!]\n  \"status variable\"\n  status: Boolean = true\n}\n\"Observability Alert threshold condition input\"\ninput ObservabilityAlertThresholdConditionInput {\n  \"severity of the Observability alert\"\n  alertSeverity: ObservabilityAlertSeverity!\n  \"\"\"\n  Sensitivity measure used for detecting violations from baseline.\n  0 - Highest sensitivity\n  100 - Lowest sensitivity\n  \"\"\"\n  confidenceLevel: Int\n  \"Threshold bound describing type of filtering required for dynamic alerts ex: LOWER, UPPER, BOTH\"\n  direction: ObservabilityAlertDynamicThresholdDirection\n  \"threshold to compare the metric value with\"\n  thresholdValue: Float!\n}\n\"Observability Alerts Silence Create\"\ninput ObservabilityCreateAlertSilenceInput {\n  \"comment section\"\n  comment: String!\n  \"End time for alert silence, should be greater than current time\"\n  endTime: DateTime!\n  \"Matchers for silence\"\n  matchers: [ObservabilityMatchersInput]\n  \"Start time for alert silence\"\n  startTime: DateTime!\n}\n\"Observability Alerts Silence Delete\"\ninput ObservabilityDeleteAlertSilenceInput {\n  \"Silence id to delete\"\n  silenceId: String!\n}\n\"Observability Log Alert condition input.\"\ninput ObservabilityLogAlertConditionInput {\n  \"operator to be applied\"\n  operator: ObservabilityAlertThresholdOperator!\n  \"thresholds to be applied\"\n  threshold: ObservabilityAlertThresholdConditionInput!\n}\n\"Observability Log Alert provider rule input.\"\ninput ObservabilityLogAlertRuleInput {\n  \"Aggregation which needs to be applied on queried logs\"\n  aggregation: ObservabilityAggregationFunction!\n  \"Observability alerting condition which needs to be applied on queried logs\"\n  alertCondition: ObservabilityLogAlertConditionInput!\n  \"Frequency of alert evaluation in minutes\"\n  alertEvaluationFrequencyInMins: Int!\n  \"IDs of entity on which observability alert is triggered\"\n  entityId: [String!]\n  \"Optional namespace from which to collect logs\"\n  namespace: String\n  \"Number of records to query for\"\n  numberOfRecordsToQuery: Int\n  \"Query filtering options used to evaluate threshold on\"\n  queryString: QueryFilter!\n  \"\"\"\n  If provided and the value is positive non-zero, then this indicates window in minutes the condition needs to be inactive/false to resolve Alert.\n  If not provided or the value is either zero or negative, then this indicates that the log alert doesn't need resolution management and is stateless.\n  \"\"\"\n  resolveWindowInMins: Int\n  \"Window in minutes the condition needs to be active to trigger the alert\"\n  triggerWindowInMins: Int!\n}\n\"Observability Log Alert provider create input.\"\ninput ObservabilityLogAlertUpdateInput {\n  \"Dashboard ID of the observability alert custom runbook\"\n  dashboardId: String @deprecated(reason: \"No longer supported\")\n  \"description of the Alert\"\n  description: String\n  \"ID of entity on which observability alert is triggered\"\n  entityId: String!\n  \"Type of entity on which observability alert is triggered\"\n  entityType: ObservabilityAlertEntityType!\n  \"name of the Alert\"\n  name: String!\n  \"Version\"\n  nodeVersion: ID!\n  \"Observability Policy id\"\n  policyId: String!\n  \"Metric Alert rule input\"\n  rule: ObservabilityLogAlertRuleInput!\n  \"Template ID of the observability alert runbook\"\n  runbookTemplateId: String\n  \"Source for alerts\"\n  source: String!\n}\ninput ObservabilityMatchersInput {\n  \"Key for Matchers\"\n  key: String!\n  \"Operators, can be regex like DOES_NOT_CONTAINS(!~), CONTAINS(=~), or EQUAL(=), NOT_EQUAL(!=)\"\n  operator: ObservabilityMatchersOperator!\n  \"Value for Matchers\"\n  value: String!\n}\n\"Observability Alert Condition input\"\ninput ObservabilityMetricAlertConditionInput {\n  \"frequency of alert evaluation in minutes\"\n  alertEvaluationFrequencyInMins: Int!\n  \"Alert will be evaluated only for these entities\"\n  includedEntityIds: [String]\n  \"operator to be applied\"\n  operator: ObservabilityAlertThresholdOperator!\n  \"override rule per entity\"\n  overrideRules: [ObservabilityAlertOverrideRuleInput]\n  \"window in minutes to resolve\"\n  resolveWindowInMins: Int! = 1\n  \"alert tags\"\n  tags: [TagInput]\n  \"thresholds to be applied\"\n  threshold: ObservabilityAlertThresholdConditionInput!\n  \"window in minutes to trigger\"\n  triggerWindowInMins: Int! = 5\n}\n\"Observability Metric Alert provider create input\"\ninput ObservabilityMetricAlertCreateInput {\n  \"dashboard ID of the observability alert runbook\"\n  dashboardId: String @deprecated(reason: \"No longer supported\")\n  \"description of the Alert\"\n  description: String\n  \"ID of entity on which observability alert is triggered\"\n  entityId: String\n  \"Type of entity on which observability alert is triggered\"\n  entityType: ObservabilityAlertEntityType!\n  \"name of the Alert\"\n  name: String!\n  \"Alert rule input\"\n  rule: ObservabilityMetricAlertRuleInput!\n  \"Template ID of the observability alert runbook\"\n  runbookTemplateId: String\n  \"Source for alerts\"\n  source: String!\n}\n\"Observability Metric Alert provider rule input\"\ninput ObservabilityMetricAlertRuleInput {\n  \"Alerting condition on threshold\"\n  alertConditionInput: ObservabilityMetricAlertConditionInput!\n  \"Optional namespace from which to collect stats\"\n  namespace: String\n  \"Prometheus query expression used to evaluate threshold on\"\n  queryString: String!\n  \"Optional query string which will contain addition metadata for above queryString\"\n  queryStringMetadata: String\n  \"Threshold type for observability alert\"\n  thresholdType: ObservabilityAlertThresholdType! = STATIC\n}\n\"Observability Metric Alert provider update input\"\ninput ObservabilityMetricAlertUpdateInput {\n  \"Dashboard ID of the observability alert custom runbook\"\n  dashboardId: String @deprecated(reason: \"No longer supported\")\n  \"description of the Alert\"\n  description: String\n  \"ID of entity on which observability alert is triggered\"\n  entityId: String\n  \"Type of entity on which observability alert is triggered\"\n  entityType: ObservabilityAlertEntityType!\n  \"name of the Alert\"\n  name: String!\n  \"Version\"\n  nodeVersion: ID!\n  \"Observability Policy id\"\n  policyId: String!\n  \"Metric Alert rule input\"\n  rule: ObservabilityMetricAlertRuleInput!\n  \"Template ID of the observability alert runbook\"\n  runbookTemplateId: String\n  \"Source for alerts\"\n  source: String!\n}\ninput ObservabilityRunbookAlertUpdateInput {\n  \"Dashboard ID of the observability alert custom runbook to be updated\"\n  dashboardId: String\n  \"Policy ID of the observability alert\"\n  policyId: String\n  \"Template ID of the observability alert runbook\"\n  runbookTemplateId: String @deprecated(reason: \"No longer supported\")\n}\n\"Input parameter for silence query\"\ninput ObservabilitySilenceFilter {\n  \"Filter silences by state\"\n  state: ObservabilityAlertSilenceState\n}\n\"Input for updating an existing AlertManager configuration\"\ninput ObservabilityUpdateAlertManagerConfigInput {\n  \"Global configuration as YAML string\"\n  global: String\n  \"Inhibit rules configuration as YAML string\"\n  inhibitRules: String\n  \"Receivers configuration\"\n  receivers: ObservabilityAlertManagerReceiversConfigInput\n  \"Route configuration as YAML string\"\n  routes: String\n  \"Time interval configurations\"\n  timeIntervals: [ObservabilityAlertManagerTimeIntervalInput!]\n  \"Configuration version for optimistic locking\"\n  version: Int!\n  \"Complete YAML configuration as a string (alternative to structured input)\"\n  yamlConfig: String\n}\n\"Observability Alerts Silence Update\"\ninput ObservabilityUpdateAlertSilenceInput {\n  \"comment section\"\n  comment: String!\n  \"End time for alert silence, should be greater than current time\"\n  endTime: DateTime!\n  \"Matchers for silence\"\n  matchers: [ObservabilityMatchersInput]\n  \"Silence id to update\"\n  silenceId: String!\n  \"Start time for alert silence\"\n  startTime: DateTime!\n}\ninput ObservationAggregationInput {\n  \"Aggregation type\"\n  aggregationType: ObservationAggregationType = TERMS\n  \"Field on which to aggregate\"\n  fieldName: String!\n  \"Limit number of buckets, if specified, top N buckets will be returned\"\n  maxBucketCount: Int @deprecated(reason: \"No supported.\")\n  \"Optional sub-aggregations\"\n  subAggregations: [ObservationAggregationInput!]\n}\n\"Input parameter for observations query\"\ninput ObservationFilter {\n  \"Filter observations by entities\"\n  entityId: [EntityId!]\n  \"Query observations based on observation query type\"\n  fetchType: ObservationQueryType! = ALL_OBSERVATIONS\n  \"Filter observations by impacted entities\"\n  impactedEntityId: [EntityId!]\n  \"Query observations based on the observation resource types\"\n  observationResourceKinds: [String!]\n  \"Filter observation by alert policy\"\n  policyId: String\n}\n\"Specify input details for observation histogram\"\ninput ObservationHistogramInput {\n  \"Bin interval of histogram in minutes\"\n  binIntervalInMinutes: Int!\n  \"End time for histogram. Note: Expressed in UTC ISO-8601 timestamp\"\n  endTime: DateTime!\n  \"Exclude sources\"\n  excludeSources: [String!] = [\"GOVERNANCE\"] @deprecated(reason: \"Use QueryFilter for source filtering\")\n  \"Optional field filters\"\n  filter: QueryFilter\n  \"Observation filter with filter parameters\"\n  observationFilter: ObservationFilter\n  \"Start time for histogram. Note: Expressed in UTC ISO-8601 timestamp\"\n  startTime: DateTime!\n}\ninput PixieFlamegraphQueryInput {\n  \"The kubernetes cluster ID to query\"\n  clusterId: String!\n  \"The namespace of the pod you are retrieving the flamegraph for. If this and kPodName are omitted, the flamegraph will represent the entire node.\"\n  kNamespace: String\n  \"The node where the target of your flamegraph query resides\"\n  kNodeName: String!\n  \"\"\"\n  The name of the pod for which to retrieve the flamegraph - this is not required if \"percentBasisEntity\" is \"node\"\n  \"\"\"\n  kPodName: String\n  \"\"\"\n  valid values are \"pod\" or \"node\". This will base the percentage calculation on whatever is specified.\n  \"\"\"\n  percentBasisEntity: String!\n  \"\"\"\n  The time window for the flamegraph requested. This is always now - (minus) some time. i.e. \"-5m\"\n  \"\"\"\n  relativeStartTime: String!\n}\n\"\"\"\nInput filter parameter to help filtering the output of the query.\nIf multiple filter objects are specified they are treated as an and.\nNested queries can be created using the 'and', 'or' or 'not' parameters.\nIn the filter the user should choose between one of:\n- the `field`, `operator` and `values` parameters\n- one of the `and`, `or` or `not` parameters\n\"\"\"\ninput QueryFilter {\n  \"performs 'and' for embedded query filters - does not include top-level field/operator/value in operation\"\n  and: [QueryFilter!]\n  \"\"\"\n  The field name to use for the filter.\n  \n  Nested field names should use the dot notation.\n  For example `tags.<name>` or `namespaces.<namespaceName>.properties.<propName>`\n  \"\"\"\n  field: String\n  \"performs 'not' for embedded query filter - does not include top-level field/operator/value in operation\"\n  not: [QueryFilter!]\n  \"The operator to be used for comparison\"\n  operator: QueryFilterOperator\n  \"performs 'or' for embedded query filters - does not include top-level field/operator/value in operation\"\n  or: [QueryFilter!]\n  \"The values to use for comparison\"\n  values: [Object!]\n}\n\"\"\"\nSorting order for the results, multiple fields with with independent sorting order can be specified.\nHas a default sort order of Ascending.\n\"\"\"\ninput QuerySort {\n  \"The field on which to sort\"\n  field: String!\n  \"The sort order ASC/DESC\"\n  order: QuerySortOrder! = ASC\n}\n\"Input filter parameter to help capturing a time range as an input.\"\ninput QueryTimeRangeFilter {\n  endTime: DateTime\n  startTime: DateTime\n}\ninput RepositoryAssessmentInput {\n  \"Repository assessment to be run on latest commit\"\n  isLatest: Boolean\n  \"Unique identifier for the Repository\"\n  repositoryId: String!\n}\ninput RepositoryDocumentInput {\n  \"\"\"\n  ID of the document containing the repository information. This document should be uploaded\n  to the document service and the generated ID should be passed in here.\n  \"\"\"\n  documentId: String!\n  \"Optional Git credentials for repository group\"\n  gitCreds: RepositoryGitCredentialsInput\n  \"Optional SCM provider type for all repositories in the CSV document\"\n  scmType: RepositorySCMType\n}\ninput RepositoryGitCredentialsInput {\n  \"API token for cloning these repositories\"\n  apiToken: String\n  \"Password of the user\"\n  password: String\n  \"Should skip ssl validation when cloning the repository \"\n  skipSslValidation: Boolean\n  \"user name of git repository group\"\n  userName: String\n}\ninput RepositoryGroupInput {\n  \"Description of repository group. Optional for edit operations.\"\n  description: String\n  \"Optional CSV document input corresponding to the repository files\"\n  documentInput: RepositoryDocumentInput\n  \"Name of the repository group to be created. Optional for edit operations.\"\n  name: String\n  \"Optional proxy to connect with git provider\"\n  proxy: RepositoryProxyInput\n  \"\"\"\n  The Entity ID of the repository group, if this is an edit operation. If this field is empty,\n  then a new repository group will be created.\n  \"\"\"\n  repositoryGroupEntityId: EntityId\n  \"If an analysis should be done for this repository group immediately\"\n  runAssessment: Boolean\n}\ninput RepositoryGroupOperationInput {\n  \"List of repositories to include in this operation, if left empty, operation is triggered for all repositories in given group\"\n  repositories: [EntityId!]\n  \"Entity ID of the Repository Group\"\n  repositoryGroupEntityId: EntityId!\n}\ninput RepositoryInput {\n  \"Optional branch to use. Otherwise default branch (main/master) will be considered for scan\"\n  branch: String\n  \"Git credentials for repository. Optional if the repository already exists\"\n  gitCreds: RepositoryGitCredentialsInput\n  \"Optional onboarding information for the repository\"\n  onboarding: RepositoryOnboardingInput\n  \"EntityId of the Repository if this is an edit operation\"\n  repositoryEntityId: EntityId\n  \"Repository endpoint url\"\n  repositoryURL: String\n  \"Optional SCM provider type\"\n  scmType: RepositorySCMType\n  \"\"\"\n  Optional subdirectory should be specified in case it is to be analysed separately.\n  e.g. - When a repository represents a monorepo, each individual directory represent a separate codebase of an individual\n  component/service.\n  \"\"\"\n  subDirectory: String\n  \"\"\"\n  Optional key/value tags that are associated with this repository. There are certain tags that are identified by the\n  assessment-service e.g businessApp, developerContact, businessCriticality. But user can add customs tags as well\n  \"\"\"\n  tags: [TagInput!]\n}\ninput RepositoryOnboardingInput {\n  \"Onboarding status of the repository\"\n  status: RepositoryOnboardingStatus\n}\ninput RepositoryProxyInput {\n  password: String\n  url: String!\n  username: String\n}\n\"\"\"\nTODO: this is used for both service bind and unbind\nafter we commit the FC changes we should have two separate 'ServiceBindInput' and 'ServiceBindInput'\nfor now I use this because ResolveServiceCredentialBindingCandidatesActivity depends on this and we want to work with both types\ndoing this only to save time. Gabi :)\n\"\"\"\ninput ServiceBindInput {\n  \" Tanzu.TAS.Application name\"\n  appName: String!\n  metadata: ServiceMetadata\n  \"Name of the service binding.\"\n  name: String!\n  parameters: [ServiceKeyValuePair]\n  \" Tanzu.TAS.ServiceInstance name\"\n  serviceInstanceName: String!\n  spaceGroupEntityId: EntityId!\n}\ninput ServiceCreateInput {\n  credentials: [ServiceKeyValuePair]\n  metadata: ServiceMetadata\n  \"Name of the service instance.\"\n  name: String!\n  \" Mirror underlying CF API: https://v3-apidocs.cloudfoundry.org/version/3.200.0/index.html#the-service-instance-object\"\n  parameters: [ServiceKeyValuePair]\n  routeServiceUrl: String\n  \"\"\"\n  Specifies the Service Plan when `type == managed`.\n  \n  - For `managed` services: this must be the Service Plan **name**.\n  It is resolved to the corresponding CF Service Plan GUID per Space.\n  Resolution happens in the Spaces hosting Foundation, so the given Service Plan name\n  must exist (and be consistent) across all Foundations.\n  \n  - For `self_managed` services: not applicable.\n  \"\"\"\n  servicePlan: ServicePlanInput\n  \" To be resolved to child Spaces\"\n  spaceGroupEntityId: EntityId!\n  syslogDrainUrl: String\n  tags: [String]\n  type: ServiceType!\n}\ninput ServiceDeleteInput {\n  \"The Service instance to delete\"\n  serviceInstanceName: String!\n  \"The Space Group to delete the service from\"\n  spaceGroupEntityId: EntityId!\n}\n\"\"\"\nKey-value pair to be mapped into JSON.\n\n- `key` is used as the JSON property name.\n- `value` is the corresponding JSON property value.\n\nExample:\n`[{ \"key\": \"creationTimeStamp\", \"value\": \"some_date\" }]`\nis converted to `[{ \"creationTimestamp\": \"some_date\" }]`.\n\nNote: We avoid using the GraphQL JSON type directly for this mapping.\n\"\"\"\ninput ServiceKeyValuePair {\n  key: String\n  value: String\n}\n\"Metadata is a JSON object that contains information about a resource.\"\ninput ServiceMetadata {\n  \"\"\"\n  Annotations are user-specified key-value pairs that are attached to API resources. They do not affect the operation of Cloud Foundry. Annotations cannot be used in filters.\n  \n  When a service instance is being created, the service broker is sent the annotations of the service instance, and the space and organization in which the service instance resides. Only annotations with a prefix (e.g. company.com/contacts) are sent to service brokers.\n  \"\"\"\n  annotations: [ServiceKeyValuePair]\n  \"Labels are user-specified key/value pairs that are attached to API Resources. They are queryable, identifying attributes of a resource, but they do not affect the operation of CloudFoundry.\"\n  labels: [ServiceKeyValuePair]\n}\n\"Must-have information when creating managed service. This field must be populated only when 'servicePlan' is 'managed'.\"\ninput ServicePlanInput {\n  \"service offering name\"\n  serviceOffering: String!\n  \"service plan name\"\n  servicePlan: String!\n}\ninput ServicePlanVisibilityUpdateInput {\n  \"The service offering name\"\n  offeringName: String!\n  plansInput: [ServicePlanVisibilityUpdatePlanInput!]!\n}\ninput ServicePlanVisibilityUpdatePlanInput {\n  \"Organization group names to update visibility for. Required if type is organization.\"\n  organizationGroupNames: [String!]\n  \"The service plan name\"\n  planName: String!\n  \"The type of visibility update to perform\"\n  visibilityType: ServicePlanVisibilityType!\n}\n\"\"\"\nInput filter parameters for filtering Assessments\nIf multiple filter objects are specified they are treated as an and.\n\"\"\"\ninput SpringArtifactAssessmentFilterInput {\n  \"filter assessments by application metadata id\"\n  applicationMetadataId: [String!]\n  \"filter assessments by application metadata names\"\n  applicationName: [String!]\n  \"filter assessments by artifactMetadata version ids\"\n  artifactMetadataVersionId: [String!]\n  \"filter by assessment id\"\n  assessmentId: [String!]\n  \"filter assessments by name\"\n  assessmentName: [String!]\n  \"filter assessment by type\"\n  assessmentType: SpringArtifactAssessmentType\n  \"filter assessments by repository endpoint URLs\"\n  repositoryEndpointURL: [String!]\n  \"filter assessments by repository\"\n  repositoryId: [String!]\n  \"filter assessments by repository version ids\"\n  repositoryVersionId: [String!]\n}\n\"input needed to start an assessment. If assessmentId is not passed then a new assessment will be created, else existing assessment will be updated\"\ninput SpringArtifactAssessmentInput {\n  \"Application Metadata Id for which we are performing an assessment\"\n  applicationMetaId: String\n  \"Name of Application\"\n  applicationName: String\n  \"Unique identifier for Assessment, to be used for update operation\"\n  assessmentId: String\n  \"Name of Assessment\"\n  assessmentName: String\n  \"Type of Assessment\"\n  assessmentType: SpringArtifactAssessmentType\n}\n\"input needed to create an application meta data\"\ninput SpringArtifactMetadataInput {\n  \"Unique identifier for Application Meta, to be used for update operation\"\n  applicationMetaId: String\n  \"Name of Application\"\n  applicationName: String\n}\ninput SpringArtifactRepositoryUpdateInput {\n  \"It shows whether is continuous monitoring is enabled on this repository\"\n  collectionEnabled: Boolean\n  \"Unique identifier for the Repository\"\n  repositoryId: String!\n  \"Repository Status\"\n  repositoryStatus: SpringArtifactRepositoryStatus\n}\ninput SpringArtifactSBOMFilterInput {\n  \"Name of the package\"\n  name: [String!]\n  \"OSS Support Status\"\n  ossSupportStatus: SpringArtifactSBOMSupportStatus\n  \"OSS Upgrade Effort Status\"\n  upgradeEffort: SpringArtifactUpgradeEffort\n  \"Version of the package\"\n  version: [String!]\n}\ninput SpringArtifactSBOMVulnerabilityFilterInput {\n  \"filter vulnerability by CVE ID\"\n  cveId: [String!]\n  \"filter vulnerability by CVSS score\"\n  score: [String!]\n  \"filter vulnerability by severity\"\n  severity: [String!]\n}\ninput StatsAggregationInput {\n  aggregationType: StatsAggregationType!\n  tags: [String!]\n}\ninput StatsAnomalyInput {\n  \"Optional confidence level (1-99). Stronger value will show fewer outliers, Weaker confidence will show more outliers\"\n  confidenceLevel: Int! = 95\n}\ninput StatsForecastInput {\n  \"Optional confidence level (1-99)\"\n  confidenceLevel: Int! = 95\n  \"Optional forecast end time, defaults to endTime + (endTime - startTime)\"\n  forecastEndTime: DateTime\n  \"Optional forecast start time, defaults to endTime. If set must be in range startTime..endTime\"\n  forecastStartTime: DateTime\n  \"\"\"\n  Optional forecast threshold\n  If specified, the forecasting logic will return the time to reach that threshold.\n  If threshold is not reached between forecastStartTime..forecastEndTime, the value will be set to Double.MAX_VALUE\n  If threshold has been reached before endTime, the value will be zero\n  \"\"\"\n  threshold: Float\n  \"\"\"\n  Optional boolean indicating the direction of the threshold relative to the data.\n  If it is true (default) then the threshold triggers if the stat rises to the value of the threshold or above.\n  If false, then the threshold triggers if the stat falls to the value of the threshold or below.\n  \"\"\"\n  thresholdUp: Boolean! = true\n}\n\"Filters for querying stats\"\ninput StatsInput {\n  \"Optionally aggregate stats timeseries by provided tags using the specified function.\"\n  aggregation: StatsAggregationInput\n  \"\"\"\n  \n  \n  **NOTE:** This API/functionality is in Alpha, This functionality can be unstable and schema elements may change over future iterations.\n  \"\"\"\n  anomaly: StatsAnomalyInput\n  \"Optional endTime. If empty, defaults to now. Expressed in UTC ISO-8601 timestamp\"\n  endTime: DateTime\n  forecast: StatsForecastInput\n  \"Optional interval for samples between startTime and endTime expressed in minutes.\"\n  intervalMins: Int\n  \"Optional interval for samples between startTime and endTime expressed in seconds. intervalSeconds will take precedence if both intervalMins and intervalSeconds are provided in stats query.\"\n  intervalSeconds: Int\n  \"\"\"\n  Optionally filter by keys.\n  To list available keys for an entity, don't filter on keys and specify only the \"key\" field in stats.\n  \"\"\"\n  keys: [String!]\n  \"Optional namespace from which to collect stats (defaults to provider from entityId)\"\n  namespace: String\n  \"\"\"\n  Optional value to include out-of-band NAN and POSITIVE_INFINITY / NEGATIVE_INFINITY in stats results if supported by the provider.\n  If a value is provided and the provider supports out-of-band values, then the out-of-band elements in the `data` field will be replaced by the given value\n  and the `modes` field will be populated with the mode of each data element.\n  If the value is not provided or the provider does not support out-of-band values, then any out-of-band values and their timestamps will be dropped and modes will remain null.\n  \"\"\"\n  outOfBandDataValue: Float\n  \"Some stats providers can support stats query strings, in which case the query syntax is specific to the provider\"\n  queryString: String\n  \"Optional roll-up strategy used in each interval for time-range queries.\"\n  rollupType: StatsRollupType\n  \"Optional number of digits of precision. Full precision if not specified.\"\n  significantDigits: Int\n  \"\"\"\n  Optional startTime.\n  If both startTime and endTime are null, a single latest value is fetched. The behavior of this\n  may vary by namespace:\n  \n  | VRNI  | will fetch the latest stat using 5-minute sampling from the last hour |\n  | VROPS | will fetch latest \"current\" stat as defined by vROps |\n  \n  If only startTime is null, the query defaults to 24 hours before endTime\n  \"\"\"\n  startTime: DateTime\n  \"Optional key/value tags of the underlying metrics. If the same tag key is repeated, the behavior is like an 'or'\"\n  tags: [TagInput!]\n}\ninput StatsRelatedEntitiesQueryInput {\n  \"Optional endTime. If empty, defaults to now. Expressed in UTC ISO-8601 timestamp\"\n  endTime: DateTime\n  \"\"\"\n  Traversal to use for finding related entities.\n  The filter matches if a traversal is found, unless the NOT logicalOperator is used.\n  \"\"\"\n  entitiesTraversal: [EntityTraversalInput!]!\n  \"Number of related entities to be returned\"\n  first: Int!\n  \"Namespace or provider on which related entities stats should be queried \"\n  namespace: String!\n  \"\"\"\n  Optional startTime.\n  If both startTime and endTime are null, a single latest value is fetched.\n  If only startTime is null, it defaults to 24 hours before endTime\n  \"\"\"\n  startTime: DateTime\n  \"Metric key for which we want to query\"\n  statKey: String!\n  \"Rollup type for stats on which related entities should be queried\"\n  statsRollupType: StatsRollupType!\n  \"Sort order for rolled up stats\"\n  statsSortOrder: QuerySortOrder!\n}\n\"Tag input argument for filtering by tags\"\ninput TagFilterInput {\n  key: String!\n  \"Permitted values for the given tag key\"\n  value: [String!]\n}\n\"Tag input argument for specifying tags\"\ninput TagInput {\n  key: String!\n  value: String\n}\n\"HubPolicyAlertInput\"\ninput TanzuHubPolicyAlertInput {\n  \"Alert category\"\n  category: TanzuHubPolicyAlertCategory!\n  \"Alert severity\"\n  severity: TanzuHubPolicyFindingSeverity!\n  \"Custom tags to be populated\"\n  tags: [TagInput!]\n  \"Alert type\"\n  type: TanzuHubPolicyAlertType!\n}\n\"Policy input\"\ninput TanzuHubPolicyCreateInput {\n  \"Policy description\"\n  description: String\n  \"Policy execution schedule\"\n  executionSchedule: TanzuHubPolicyExecutionScheduleInput!\n  \"Policy name\"\n  name: String!\n  \"\"\"\n  Rules for this policy.\n  A rule is a set Graphql Query + post processing that filters data in the Hub Graph.\n  Rule has associated actions.\n  A rule is considered evaluated to NON_COMPLIANT if there are resources returned by the graphQL query + post-processing\n  If a rule evaluates to NON_COMPLIANT, the associated actions are executed.\n  \n  Rules for a policy are a executed sequentially and if any rule evaluates to NON_COMPLIANT further rule execution is stopped.\n  \"\"\"\n  rule: [TanzuHubPolicyRuleInput!]!\n}\n\"Policy input for editing\"\ninput TanzuHubPolicyEditInput {\n  \"Policy description\"\n  description: String\n  \"Policy execution schedule \"\n  executionSchedule: TanzuHubPolicyExecutionScheduleInput!\n  \"Policy name\"\n  name: String!\n  \"Version\"\n  nodeVersion: ID!\n  \"Policy id\"\n  policyId: String!\n  \"Rule details\"\n  rule: [TanzuHubPolicyRuleInput!]!\n}\n\"\"\"\nPolicy Execution Schedule.\nNOTE: Either `cronExpression` or `schedule` should provided to specify the execution of policy on schedule basis.\n\"\"\"\ninput TanzuHubPolicyExecutionScheduleInput {\n  \"\"\"\n  Cron expression in \"tz sec min hour dom m dow\" format plus last-day-of-month support ('L')\n  \"\"\"\n  cronExpression: String\n  \"Schedule for policy execution on a schedule basis.\"\n  schedule: TanzuHubPolicyScheduleInput\n}\n\"Policy filter\"\ninput TanzuHubPolicyFilter {\n  \"\"\"\n  Filter by createdBy - This is account identifier string used by the user to log in. Users might not necessarily use their email.\n  e.g. If user logs in using email id, value should be 'username@email.com'\n  \"\"\"\n  createdBy: String\n  \"Filter by policy Id\"\n  policyId: [String!]\n  \"Filter by policy name. Name string matches partial text matches.\"\n  policyName: [String!]\n  \"policy run status\"\n  runStatus: [HubPolicyRunStatus]\n  \"policy run time filter\"\n  runTimeFilter: QueryTimeRangeFilter\n  \"Show enabled/disabled polices\"\n  status: Boolean\n  \"\"\"\n  Filter by updatedBy - This is account identifier string used by the user to log in. Users might not necessarily use their email.\n  e.g. If user logs in using email id, value should be 'username@email.com'\n  \"\"\"\n  updatedBy: String\n}\n\"HubPolicyRuleActionInput\"\ninput TanzuHubPolicyRuleActionInput {\n  \"HubPolicyAlertInput\"\n  alert: TanzuHubPolicyAlertInput\n}\n\"Rule input\"\ninput TanzuHubPolicyRuleInput {\n  \"graphQL query to be executed to fetch the data\"\n  graphQLQuery: String!\n  \"graphQL variables needed for query execution\"\n  graphQLQueryVariables: JSON\n  \"Rules/conditions that are going to get evaluated\"\n  paginationData: DerivedDataPaginationInput\n  \"If this rule evaluated to non complaint, the following actions/findings will be executed/created\"\n  policyRuleActions: TanzuHubPolicyRuleActionInput\n  \"Rules/conditions that are going to get evaluated\"\n  processingRules: DerivedDataProcessingRulesInput\n  \"id of the rule to be edited, if left null will create a new rule\"\n  ruleId: String\n  \"rule name\"\n  ruleName: String!\n}\n\"\"\"\nTime during the day schedule should run at, its value are in 24 hr format.\ne.g.\ntimezone -> 'Asia/Kolkata'\nhour -> 14\nmin  -> 50\n\"\"\"\ninput TanzuHubPolicyRunAtInput {\n  hour: Int!\n  min: Int!\n  timezone: String!\n}\n\"Policy Run filter\"\ninput TanzuHubPolicyRunFilter {\n  \"Filter by policy Id\"\n  policyId: [String!]\n  \"Policy status\"\n  status: HubPolicyRunStatus\n}\n\"Schedule for policy execution on a schedule basis.\"\ninput TanzuHubPolicyScheduleInput {\n  \"\"\"\n  When interval `MONTH` is selected - the `dayOfMonth` is required to specify on which day of month timer should run.\n  Value between 1-31 can be specified. If 29 is selected then it will run on 29th of every month expect February(28) i.e. it will be skipped for February.\n  \"\"\"\n  dayOfMonth: Int\n  \"\"\"\n  Day of the week that tasks run. Returns one of the following codes:\n  MONDAY\n  TUESDAY\n  WEDNESDAY\n  THURSDAY\n  FRIDAY\n  SATURDAY\n  SUNDAY\n  Returned for `WEEK` interval only.\n  \"\"\"\n  dayOfWeek: [TanzuHubPolicyDaysOfWeek!]\n  \"Frequency that the schedule runs for the specified interval. For example, if the interval is Hourly, a frequency of 2 means the task runs every 2 hours.\"\n  frequency: Int!\n  \"\"\"\n  Interval or repeat frequency at which the schedule runs.\n  NOTE:\n  1) When a `WEEKLY` interval is selected then `dayOfWeek` is required.\n  2) When a `MONTHLY` interval is selected then `dayOfMonth` is required.\n  \"\"\"\n  interval: TanzuHubPolicyIntervalType!\n  \"\"\"\n  Time during the day it should run at - any value between 00:00 to 23:59.\n  NOTE: runAt is not applicable for 'HOURLY' intervals.\n  \"\"\"\n  runAt: TanzuHubPolicyRunAtInput\n}\ninput UserPrefInput {\n  \"Optional entityId to which this userPref is associated\"\n  entityId: EntityId\n  \"name of this user-pref in the context of the user and entityId\"\n  name: String!\n  \"Scope of the preference: USER (user-specific) or GLOBAL (organization-wide). Defaults to USER\"\n  scope: UserPrefScope = USER\n  \"Max size for value in UTF-8 is 32Kb. May contain a JSON-serialized String\"\n  value: String\n}\n\"Input for validating a Warehouse credential. Only token is supported currently.\"\ninput WarehouseCredentialsValidationInput {\n  storeCredentialIfTokenIsValid: Boolean = false\n  token: String\n  verifyStoredWarehouseCredential: Boolean = false\n}\n\"Detailed control over file extraction.\"\ninput WarehouseDownloadFileExtractionInput {\n  \"Specifies how to interact w/ document service\"\n  documentOptions: DocumentOptions!\n  \"The path of the file to be extracted from the downloaded archive file\"\n  filePath: String!\n}\ninput WarehouseDownloadProductReleaseInput {\n  \"\"\"\n  Flag indicating whether the user has accepted the End User License Agreement.\n  Some products require explicit EULA acceptance before download is permitted.\n  \"\"\"\n  acceptsEula: Boolean = false\n  \"A product release to be provisioned.\"\n  productRelease: EntityId!\n  \"All the release files of the product release to download.\"\n  releaseFileInputs: [WarehouseDownloadReleaseFileInput!]!\n}\n\"Contains all necessary information to identify and download the specific release file\"\ninput WarehouseDownloadReleaseFileInput {\n  \"Specifies how to interact w/ document service\"\n  documentOptions: DocumentOptions!\n  \"All the files to extract from the release file once downloaded\"\n  filesToExtract: [WarehouseDownloadFileExtractionInput!]\n  \"Entity ID of the Tanzu.Platform.ReleaseFile entity\"\n  releaseFileEntityId: EntityId!\n}\n\"Input for forcing a warehouse re-index from the external source (e.g., TanzuNet)\"\ninput WarehouseProductReleaseInput {\n  \"Force indexation\"\n  forceExecution: Boolean = false\n  \"List of product types to include in the re-indexing process\"\n  indexingType: WarehouseIndexingType!\n}\n\"Input for reset the warehouse reconcile status and force its execution immediately if required\"\ninput WarehouseReconcileProductsInput {\n  \"Flag to force immediately the execution\"\n  forceNow: Boolean = false\n  \"Product type requested to reconcile if forceNow = true\"\n  productType: WarehouseProductType\n}\n\"Represents the input for searching workflows.\"\ninput WorkflowSearchInput {\n  \"Return records after the given cursor, as per GraphQL Relay spec\"\n  after: String\n  \"Return records before the given cursor, as per GraphQL Relay spec\"\n  before: String\n  \"Return first N records in a paged response, as per GraphQL Relay spec\"\n  first: Int = 10\n  \"List of ids of the workflow\"\n  id: [ID!]\n  \"\"\"\n  Include child workflows in the search results. Defaults to false.\n  When false, only parent workflows are returned.\n  Note that if this is set to true, the api will return the uber/parent workflow which has child workflows \n  and child workflows as separate workflows in the same API call.\n  \"\"\"\n  includeChildWorkflows: Boolean = false\n  \"Return last N records in a paged response, as per GraphQL Relay spec\"\n  last: Int\n  \"The name of the workflow. It is a case insensitive contains search.\"\n  name: String\n  \"The status of the workflow run.\"\n  status: WorkflowStatus\n  \"Type of workflows.\"\n  type: [String!]\n  \"The user id of the user who has created workflow\"\n  userId: String\n}\n\"Indicates exactly one field must be supplied and this field must not be `null`.\"\ndirective @oneOf on INPUT_OBJECT\n\"Exposes a URL that specifies the behavior of this scalar.\"\ndirective @specifiedBy(\n    \"The URL that specifies the behavior of this scalar.\"\n    url: String!\n  ) on SCALAR\n","success":true},"error":null}
